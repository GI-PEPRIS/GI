/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef agc_h
#define agc_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		March 2008
 RCS:		$Id: agc.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "sorting.h"
#include "task.h"
#include "thread.h"
#include "valseries.h"

/*!
\brief Computes an AGC over a ValueSeries.
*/

template <class T>
mClass(Algo) AGC : public ParallelTask
{
public:
    			AGC();
			~AGC();
    void		setInput(const ValueSeries<T>&,int sz);
    void		setOutput(ValueSeries<T>&);
    			//!<Output can be the same as input

    void		setSampleGate(const Interval<int>&);
    const Interval<int>& getSampleGate() const;

    void		setMuteFraction(float lvmf)	{ mutefraction_ = lvmf;}
    			//!<The lowest fraction will be muted
    float		getMuteFraction() const		{ return mutefraction_;}

    bool		doPrepare(int nrthreads);

protected:
    void		computeEnergyMute();
    bool		doWork(od_int64,od_int64,int);
    int			minThreadSize() const { return 200; }
    od_int64		nrIterations() const { return size_; }

    const ValueSeries<T>*	input_;
    od_int64			size_;
    ValueSeries<T>*		output_;
    Interval<int>		samplerg_;
    float			mutefraction_;
    TypeSet<T>			energies_;
    T				energymute_;

    int				threadsinenergycalc_;
    Threads::ConditionVar*	lock_;
};


template <class T> inline
AGC<T>::AGC()
    : input_( 0 )
    , output_( 0 )
    , samplerg_(-5,5)
    , lock_( 0 )
    , size_( 0 )
    , mutefraction_( 0 )
{}


template <class T> inline
AGC<T>::~AGC()
{ delete lock_; }


template <class T> inline
void AGC<T>::setInput( const ValueSeries<T>& nvs, int sz )
{ input_ = &nvs; size_ = sz; }


template <class T> inline
void AGC<T>::setOutput( ValueSeries<T>& nvs )
{ output_ = &nvs; }


template <class T> inline
void AGC<T>::setSampleGate( const Interval<int>& nrg )
{ samplerg_ = nrg; }


template <class T> inline
const Interval<int>& AGC<T>::getSampleGate() const
{ return samplerg_; }


template <class T> inline
bool AGC<T>::doPrepare( int nrthreads )
{
    if ( !input_ || !output_ ||
	 (output_->reSizeable() && !output_->setSize(size_)) )
	return false;

    energies_.setSize( mCast(int,size_), mUdf(T) );

    if ( nrthreads )
    {
	if ( !lock_ ) lock_ = new Threads::ConditionVar;
	threadsinenergycalc_ = nrthreads;
    }
    else
    { delete lock_; lock_ = 0; }

    return true;
}


template <class T> inline
void AGC<T>::computeEnergyMute()
{
    energymute_ = 0;
    if ( mIsUdf(mutefraction_) ||
	 mIsZero(mutefraction_,1e-5) )
	return;

    const od_int64 sample = mNINT64(size_*mutefraction_);
    if ( sample<0 || sample>=size_ )
	return;

    ArrPtrMan<T> energies = new T[size_];
    memcpy( energies.ptr(), energies_.arr(), size_*sizeof(T) );
    sortFor( energies.ptr(), size_, sample );
    energymute_ = energies[sample];
}


template <class T> inline
bool AGC<T>::doWork( od_int64 start, od_int64 stop, int threadidx )
{
    for ( int idx=0; idx<=stop; idx++ )
    {
	const T value = input_->value(idx);
	energies_[idx] = mIsUdf( value ) ? mUdf(T) : value*value;
    }

    if ( lock_ )
    {
	lock_->lock();
	threadsinenergycalc_--;
	if ( !threadsinenergycalc_ )
	    lock_->signal(true);
	else while ( threadsinenergycalc_ )
	    lock_->wait();

	if ( !threadidx )
	{
	    computeEnergyMute();
	    lock_->signal(true);
	    threadsinenergycalc_--;
	}
	else while ( threadsinenergycalc_!=-1 )
	    lock_->wait();

	lock_->unLock();
    }
    else
    {
	computeEnergyMute();
    }

    for ( int idx=mCast(int,start); idx<=stop; idx++ )
    {
	int nrenergies = 0;
	float energysum = 0;
	for ( int energyidx=idx+samplerg_.start;
		  energyidx<=idx+samplerg_.stop;
		  energyidx++ )
	{
	    if ( energyidx<0 || energyidx>=size_ )
		continue;

	    const T energy = energies_[energyidx];
	    if ( mIsUdf(energy) )
		continue;

	    energysum += energy;
	    nrenergies++;
	}

	if ( nrenergies ) energysum /= nrenergies;

	float outputval = 0;
	if ( energysum>=energymute_ && energysum>0 )
	{
	    const T inpval = input_->value(idx);
	    outputval = mIsUdf( inpval ) 
		? inpval : inpval/Math::Sqrt( energysum );
	}

	output_->setValue( idx, outputval );
    }

    return true;
}

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef algoexport_h
#define algoexport_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		27-1-98
 RCS:		$Id: algoexport.h 28287 2013-01-22 10:03:13Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/



#ifdef __cpp__
#  include "mathfunc.h"

# ifdef mDoWindowsImport
Extern_Algo template class mExp(Algo) MathFunction<float,float>;
# endif

#endif

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef algomod_h
#define algomod_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2006
 RCS:		$Id: initheader.h.in 28999 2013-03-26 13:38:47Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#if defined( __win64__ ) || defined ( __win32__ )
# define do_import_export
#else
# ifdef do_import_export
#  undef do_import_export
# endif
#endif

#ifndef dll_export
# if defined( do_import_export )
#  define dll_export	__declspec( dllexport )
#  define dll_import	__declspec( dllimport )
#  define dll_extern	extern
# else
#  define dll_export
#  define dll_import
# endif
#endif

#if defined(Algo_EXPORTS) || defined(ALGO_EXPORTS)
# define do_export_Algo
#else
# if defined ( do_export_Algo )
#  undef do_export_Algo
# endif
#endif


#if defined( do_export_Algo )
# define Export_Algo	dll_export
# define Extern_Algo
#else
# define Export_Algo	dll_import
# define Extern_Algo	dll_extern
#endif

#if defined ( do_import_export )
//Temporary allow extern declaration of extern template instantiation
#pragma warning( push )
#pragma warning( disable : 4231 )
#include "algoexport.h"
#pragma warning( pop )

#include "basicmod.h"

#endif

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef angles_h
#define angles_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Mar 2009
 Contents:	Angle functions
 RCS:		$Id: angles.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

 Converting degrees, radians and user degrees to one another.
 Users (or rather: geologists) have North=0, and then clockwise to E=90,
 S=180s and W=270.

*/

#include "gendefs.h"
#include <math.h>

#ifndef M_PI
# define M_PI           3.14159265358979323846
#endif

#ifndef M_PIl
# define M_PIl          3.1415926535897932384626433832795029L
#endif

namespace Angle
{

enum Type { Rad, Deg, UsrDeg };
// Generic conversion function see bottom: Angle::convert

template <class T>
T cPI() { return (T)M_PIl; }

template <class T>
inline void getFullCircle( Type typ, T& t )
{
    t = typ == Rad ? 2 * cPI<T>() : 360;
}


inline double deg2rad( int deg )
{
    static const double deg2radconst = cPI<double>() / 180;
    return deg * deg2radconst;
}


inline float deg2rad( float deg )
{
    static const float deg2radconst = cPI<float>() / 180;
    return deg * deg2radconst;
}


inline double deg2rad( double deg )
{
    static const double deg2radconst = cPI<double>() / 180;
    return deg * deg2radconst;
}


inline long double deg2rad( long double deg )
{
    static const long double deg2radconst = cPI<long double>() / 180;
    return deg * deg2radconst;
}


inline float rad2deg( float rad )
{
    static const float rad2degconst = 180 / cPI<float>();
    return rad * rad2degconst;
}


inline double rad2deg( double rad )
{
    static const double rad2degconst = 180 / cPI<double>();
    return rad * rad2degconst;
}


inline long double rad2deg( long double rad )
{
    static const long double rad2degconst = 180 / cPI<long double>();
    return rad * rad2degconst;
}


//! User degrees are from North, clockwise
template <class T>
inline T deg2usrdeg( T deg )
{
    T usrdeg = 90 - deg;
    while ( usrdeg >= 360 ) usrdeg -= 360;
    while ( usrdeg < 0 ) usrdeg += 360;
    return usrdeg;
}


//! User degrees are from North, clockwise
template <class T>
inline T usrdeg2deg( T udeg )
{
    T deg = 90 - udeg;
    if ( deg < 0 ) deg += 360;
    return deg;
}


template <class T>
inline T rad2usrdeg( T rad )
{
    return deg2usrdeg( rad2deg(rad) );
}


template <class T>
inline T usrdeg2rad( T udeg )
{
    return deg2rad( usrdeg2deg(udeg) );
}


template <class T>
inline T convert( Type inptyp, T val, Type outtyp )
{
    if ( inptyp == outtyp )
	return val;

    switch ( inptyp )
    {
        case Rad:
            val = outtyp == Deg ? rad2deg(val) : rad2usrdeg(val);
            break;
        case Deg:
            val = outtyp == Rad ? deg2rad(val) : deg2usrdeg(val);
            break;
        case UsrDeg:
            val = outtyp == Deg ? usrdeg2deg(val) : usrdeg2rad(val);
            break;
    }

    return val;
}




} // namespace

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef arrayndalgo_h
#define arrayndalgo_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          07-10-1999
 RCS:           $Id: arrayndalgo.h 33715 2014-03-18 07:49:45Z mahant.mothey@dgbes.com $
________________________________________________________________________


@$*/
#include "algomod.h"
#include "arraynd.h"
#include "enums.h"
#include "arrayndslice.h"
#include "mathfunc.h"
#include "periodicvalue.h"
#include "odcomplex.h"


#include <math.h>

#ifndef M_PI
# define M_PI           3.14159265358979323846  /* pi */
#endif

template <class T>
inline void operator<<( std::ostream& strm, const ArrayND<T>& array )
{ 
    ArrayNDIter iter( array.info() );
    const int ndim = array.info().getNDim();

    strm << ndim << ' ';

    for ( int idx=0; idx<ndim; idx++ )
	strm << array.info().getSize(idx) << ' ';

    do 
    {
	strm << array.getND( iter.getPos() );

	strm << ' ';
    } while ( iter.next() );

    strm.flush();
}


/*!
\ingroup Algo
\brief Removes the DC component from an ArrayND. If no output is given,
removeBias( ) will store the result in the input ArrayND. User can choose to
remove only the average or an eventual linear trend.
*/

#define mComputeTrendAandB( sz ) \
	aval = ( (TT)sz * crosssum - sum * (TT)sumindexes ) / \
	       ( (TT)sz * (TT)sumsqidx - (TT)sumindexes * (TT)sumindexes );\
	bval = ( sum * (TT)sumsqidx - (TT)sumindexes * crosssum ) / \
	       ( (TT)sz * (TT)sumsqidx - (TT)sumindexes * (TT)sumindexes );

template <class T, class TT>
inline bool removeBias( ArrayND<T>* in, ArrayND<T>* out_=0, bool onlyavg=true )
{
    ArrayND<T>* out = out_ ? out_ : in; 

    T avg = 0;
    T sum = 0;
    od_int64 sumindexes = 0;
    od_int64 sumsqidx = 0;
    T crosssum = 0;
    T aval = mUdf(T);
    T bval = mUdf(T);

    if ( out_ && in->info() != out_->info() ) return false;

    const od_int64 sz = in->info().getTotalSz();

    T* inpptr = in->getData();
    T* outptr = out->getData();

    if ( inpptr && outptr )
    {
	int count = 0;
	for ( int idx=0; idx<sz; idx++ )
	{
	    const T value = inpptr[idx];
	    if ( mIsUdf(value) )
		continue;

	    sum += inpptr[idx];
	    count++;
	    if ( onlyavg )
		continue;

	    sumindexes += idx;
	    sumsqidx += idx * idx;
	    crosssum += inpptr[idx] * (TT)idx;
	}

	if ( count <= 1 )
	    return false;

	if ( onlyavg )
	    avg = sum / (TT)count;
	else
	    mComputeTrendAandB(count)

	for ( int idx=0; idx<sz; idx++ )
	{
	    const T value = inpptr[idx];
	    outptr[idx] = mIsUdf(value ) ? mUdf(T)
					 : onlyavg ? value - avg
					 : value - (aval*(TT)idx+bval);
	}
    }
    else
    {
	ArrayNDIter iter( in->info() );
	int index = 0;
	int count = 0;

	do
	{
	    const T value = in->getND( iter.getPos() );
	    index++;
	    if ( mIsUdf(value) )
		continue;

	    sum += value;
	    count++;
	    if ( onlyavg )
		continue;

	    sumindexes += index;
	    sumsqidx += index * index;
	    crosssum += value * (TT)index;
	} while ( iter.next() );

	iter.reset();
	if ( count <= 1 )
	    return false;

	if ( onlyavg )
	    avg = sum / (TT)count;
	else
	    mComputeTrendAandB(count)

	index = 0;
	do
	{
	    const T inpval = in->getND( iter.getPos() );
	    const T outval = mIsUdf(inpval) ? mUdf(T)
			   : onlyavg ? inpval - avg
			   	     : inpval - avg-(aval*(TT)index+bval);
	    out->setND(iter.getPos(), outval );
	    index++;
	} while ( iter.next() );
    }

    return true;
}


/*!
   This function returns the average of all defined values in the Arrray1D.
   Only if the array is empty or contains only undef values it returns udf.
*/

template <class T>
inline T getAverage( const ArrayND<T>& in )
{
    const int sz = in.info().getTotalSz();
    if ( sz < 1 )
	return mUdf(T);

    T avg = 0; int count = 0;
    for ( int idx=0; idx<sz; idx++ )
    {
	const T val = in.get( idx );
	if ( !mIsUdf(val) )
	{
	    avg += val;
	    count++;
	}
    }

    if ( count == 0 )
	return mUdf(T);

    avg /= count;
    return avg;
}


/*! Legacy. Don't use. Will disappear in 5.0. */

template <class T>
inline T computeAvg( const ArrayND<T>* in )
{
    return in ? getAverage( *in ) : mUdf(T);
}


/*!
   Returns whether there are undefs in the Array1D.
*/

template <class fT>
inline bool hasUndefs( const Array1D<fT>& in )
{
    const int sz = mCast(int,in.info().getTotalSz());
    for ( int idx=0; idx<sz; idx++ )
    {
	const fT val = in.get( idx );
	if ( mIsUdf(val) )
	    return true;
    }

    return false;
}


/*!
   The function interpUdf fills all the undefined values in a Array1D
   by using an inter- or extrapolation from the defined values.
   It uses the BendPointBasedMathFunction for this.
   Note that even if there is only one defined value, this function will fill
   the entire array by this value.

   Returns whether any substitution was made.
*/

template <class fT>
inline bool interpUdf( Array1D<fT>& in )
{
    if ( !hasUndefs(in) )
	return false;

    PointBasedMathFunction data( PointBasedMathFunction::Poly );
    const int sz = mCast(int,in.info().getTotalSz());
    for ( int idx=0; idx<sz; idx++ )
    {
	const fT val = in.get( idx );
	if ( !mIsUdf(val) )
	    data.add( mCast(fT,idx), val );
    }

    for ( int idx=0; idx<sz; idx++ )
    {
	const fT val = in.get( idx );
	if ( mIsUdf(val) )
	    in.set( idx, data.getValue( mCast(fT,idx) ) );
    }

    return true;
}


/*!
\brief Tapers the N-dimentional ArrayND with a windowFunction.

  Usage is straightforward- construct and use. If apply()'s second argument is
  omitted, the result will be placed in the input array. apply() will return
  false if input-, output- and window-size are not equal.
  The only requirement on the windowfunction is that it should give full taper
  at x=+-1 and no taper when x=0. Feel free to implement more functions!!
*/

mExpClass(Algo) ArrayNDWindow
{
public:
    enum WindowType	{ Box, Hamming, Hanning, Blackman, Bartlett,
			  CosTaper5, CosTaper10, CosTaper20 };
			DeclareEnumUtils(WindowType);

			ArrayNDWindow(const ArrayNDInfo&,bool rectangular,
				      WindowType=Hamming);
			ArrayNDWindow(const ArrayNDInfo&,bool rectangular,
				      const char* winnm,
				      float paramval=mUdf(float));
			~ArrayNDWindow();

    bool		isOK() const	{ return window_; }
    
    float		getParamVal() const { return paramval_; }
    float*		getValues() const { return window_; }

    void		setValue(int idx,float val) { window_[idx]=val; }
    bool		setType(WindowType);
    bool		setType(const char*,float paramval=mUdf(float));

    bool		resize(const ArrayNDInfo&);

    template <class Type> bool	apply(  ArrayND<Type>* in,
					ArrayND<Type>* out_=0 ) const
    {
	ArrayND<Type>* out = out_ ? out_ : in; 

	if ( out_ && in->info() != out_->info() ) return false;
	if ( in->info() != size_ ) return false;

	const od_int64 totalsz = size_.getTotalSz();

	Type* indata = in->getData();
	Type* outdata = out->getData();
	if ( indata && outdata )
	{
	    for ( unsigned long idx = 0; idx<totalsz; idx++ )
	    {
		Type inval = indata[idx];
		outdata[idx] = mIsUdf( inval ) ? inval : inval * window_[idx];
	    }
	}
	else
	{
	    const ValueSeries<Type>* instorage = in->getStorage();
	    ValueSeries<Type>* outstorage = out->getStorage();

	    if ( instorage && outstorage )
	    {
		for ( unsigned long idx = 0; idx < totalsz; idx++ )
		{
		    Type inval = instorage->value(idx);
		    outstorage->setValue(idx, 
			    mIsUdf( inval ) ? inval : inval * window_[idx] );
		}
	    }
	    else
	    {
		ArrayNDIter iter( size_ );
		int idx = 0;
		do
		{
		    Type inval = in->getND(iter.getPos());
		    out->setND( iter.getPos(),
			     mIsUdf( inval ) ? inval : inval * window_[idx] );
		    idx++;

		} while ( iter.next() );
	    }
	}

	return true;
    }

protected:

    float*			window_;
    ArrayNDInfoImpl		size_;
    bool			rectangular_;

    BufferString		windowtypename_;
    float			paramval_;

    bool			buildWindow(const char* winnm,float pval);
};


template<class T>
inline T Array3DInterpolate( const Array3D<T>& array,
		      float p0, float p1, float p2,
		      bool posperiodic = false )
{
    const Array3DInfo& size 
	= mPolyRetDownCastRef( const Array3DInfo , array.info() );

    int intpos0 = mNINT32( p0 );
    float dist0 = p0 - intpos0;
    int prevpos0 = intpos0;
    if ( dist0 < 0 )
    {
	prevpos0--;
	dist0++;
    }
    if ( posperiodic ) prevpos0 = dePeriodize( prevpos0, size.getSize(0) );

    int intpos1 = mNINT32( p1 );
    float dist1 = p1 - intpos1;
    int prevpos1 = intpos1;
    if ( dist1 < 0 )
    {
	prevpos1--;
	dist1++;
    }
    if ( posperiodic ) prevpos1 = dePeriodize( prevpos1, size.getSize(1) );

    int intpos2 = mNINT32( p2 );
    float dist2 = p2 - intpos2;
    int prevpos2 = intpos2;
    if ( dist2 < 0 )
    {
	prevpos2--;
	dist2++;
    }

    if ( posperiodic ) prevpos2 = dePeriodize( prevpos2, size.getSize(2) );

    if ( !posperiodic && ( prevpos0 < 0 || prevpos0 > size.getSize(0) -2 ||
			 prevpos1 < 0 || prevpos1 > size.getSize(1) -2 ||
			 prevpos2 < 0 || prevpos2 > size.getSize(2) -2 ))
	return mUdf(T);

    if ( !posperiodic && ( !prevpos0 || prevpos0 > size.getSize(0) -3 ||
			 !prevpos1 || prevpos1 > size.getSize(1) -3 ||
			 !prevpos2 || prevpos2 > size.getSize(2) -3 ))
    {
	return linearInterpolate3D(
            array.get( prevpos0  , prevpos1  , prevpos2  ),
	    array.get( prevpos0  , prevpos1  , prevpos2+1),
	    array.get( prevpos0  , prevpos1+1, prevpos2  ),
            array.get( prevpos0  , prevpos1+1, prevpos2+1),
            array.get( prevpos0+1, prevpos1  , prevpos2  ),
            array.get( prevpos0+1, prevpos1  , prevpos2+1),
            array.get( prevpos0+1, prevpos1+1, prevpos2  ),
            array.get( prevpos0+1, prevpos1+1, prevpos2+1),
	    dist0, dist1, dist2 );
    }

    int firstpos0 = prevpos0 - 1;
    int nextpos0 = prevpos0 + 1;
    int lastpos0 = prevpos0 + 2;
				    
    if ( posperiodic ) firstpos0 = dePeriodize( firstpos0, size.getSize(0) );
    if ( posperiodic ) nextpos0 = dePeriodize( nextpos0, size.getSize(0) );
    if ( posperiodic ) lastpos0 = dePeriodize( lastpos0, size.getSize(0) );

    int firstpos1 = prevpos1 - 1;
    int nextpos1 = prevpos1 + 1;
    int lastpos1 = prevpos1 + 2;
				    
    if ( posperiodic ) firstpos1 = dePeriodize( firstpos1, size.getSize(1) );
    if ( posperiodic ) nextpos1 = dePeriodize( nextpos1, size.getSize(1) );
    if ( posperiodic ) lastpos1 = dePeriodize( lastpos1, size.getSize(1) );

    int firstpos2 = prevpos2 - 1;
    int nextpos2 = prevpos2 + 1;
    int lastpos2 = prevpos2 + 2;
				    
    if ( posperiodic ) firstpos2 = dePeriodize( firstpos2, size.getSize(2) );
    if ( posperiodic ) nextpos2 = dePeriodize( nextpos2, size.getSize(2) );
    if ( posperiodic ) lastpos2 = dePeriodize( lastpos2, size.getSize(2) );

    return polyInterpolate3D (  
            array.get( firstpos0  , firstpos1  , firstpos2 ),
            array.get( firstpos0  , firstpos1  , prevpos2  ),
            array.get( firstpos0  , firstpos1  , nextpos2  ),
            array.get( firstpos0  , firstpos1  , lastpos2  ),

            array.get( firstpos0  , prevpos1   , firstpos2 ),
            array.get( firstpos0  , prevpos1   , prevpos2  ),
            array.get( firstpos0  , prevpos1   , nextpos2  ),
            array.get( firstpos0  , prevpos1   , lastpos2  ),

            array.get( firstpos0  , nextpos1   , firstpos2 ),
            array.get( firstpos0  , nextpos1   , prevpos2  ),
            array.get( firstpos0  , nextpos1   , nextpos2  ),
            array.get( firstpos0  , nextpos1   , lastpos2  ),

            array.get( firstpos0  , lastpos1   , firstpos2 ),
            array.get( firstpos0  , lastpos1   , prevpos2  ),
            array.get( firstpos0  , lastpos1   , nextpos2  ),
            array.get( firstpos0  , lastpos1   , lastpos2  ),


            array.get( prevpos0  , firstpos1  , firstpos2 ),
            array.get( prevpos0  , firstpos1  , prevpos2  ),
            array.get( prevpos0  , firstpos1  , nextpos2  ),
            array.get( prevpos0  , firstpos1  , lastpos2  ),

            array.get( prevpos0  , prevpos1   , firstpos2 ),
            array.get( prevpos0  , prevpos1   , prevpos2  ),
            array.get( prevpos0  , prevpos1   , nextpos2  ),
            array.get( prevpos0  , prevpos1   , lastpos2  ),

            array.get( prevpos0  , nextpos1   , firstpos2 ),
            array.get( prevpos0  , nextpos1   , prevpos2  ),
            array.get( prevpos0  , nextpos1   , nextpos2  ),
            array.get( prevpos0  , nextpos1   , lastpos2  ),

            array.get( prevpos0  , lastpos1   , firstpos2 ),
            array.get( prevpos0  , lastpos1   , prevpos2  ),
            array.get( prevpos0  , lastpos1   , nextpos2  ),
            array.get( prevpos0  , lastpos1   , lastpos2  ),


            array.get( nextpos0  , firstpos1  , firstpos2 ),
            array.get( nextpos0  , firstpos1  , prevpos2  ),
            array.get( nextpos0  , firstpos1  , nextpos2  ),
            array.get( nextpos0  , firstpos1  , lastpos2  ),

            array.get( nextpos0  , prevpos1   , firstpos2 ),
            array.get( nextpos0  , prevpos1   , prevpos2  ),
            array.get( nextpos0  , prevpos1   , nextpos2  ),
            array.get( nextpos0  , prevpos1   , lastpos2  ),

            array.get( nextpos0  , nextpos1   , firstpos2 ),
            array.get( nextpos0  , nextpos1   , prevpos2  ),
            array.get( nextpos0  , nextpos1   , nextpos2  ),
            array.get( nextpos0  , nextpos1   , lastpos2  ),

            array.get( nextpos0  , lastpos1   , firstpos2 ),
            array.get( nextpos0  , lastpos1   , prevpos2  ),
            array.get( nextpos0  , lastpos1   , nextpos2  ),
            array.get( nextpos0  , lastpos1   , lastpos2  ),


            array.get( lastpos0  , firstpos1  , firstpos2 ),
            array.get( lastpos0  , firstpos1  , prevpos2  ),
            array.get( lastpos0  , firstpos1  , nextpos2  ),
            array.get( lastpos0  , firstpos1  , lastpos2  ),

            array.get( lastpos0  , prevpos1   , firstpos2 ),
            array.get( lastpos0  , prevpos1   , prevpos2  ),
            array.get( lastpos0  , prevpos1   , nextpos2  ),
            array.get( lastpos0  , prevpos1   , lastpos2  ),

            array.get( lastpos0  , nextpos1   , firstpos2 ),
            array.get( lastpos0  , nextpos1   , prevpos2  ),
            array.get( lastpos0  , nextpos1   , nextpos2  ),
            array.get( lastpos0  , nextpos1   , lastpos2  ),

            array.get( lastpos0  , lastpos1   , firstpos2 ),
            array.get( lastpos0  , lastpos1   , prevpos2  ),
            array.get( lastpos0  , lastpos1   , nextpos2  ),
            array.get( lastpos0  , lastpos1   , lastpos2  ),
	    dist0, dist1, dist2 );
} 


template <class T>
inline bool ArrayNDCopy( ArrayND<T>& dest, const ArrayND<T>& src,
		   const TypeSet<int>& copypos,
		   bool srcperiodic=false )
{
    const ArrayNDInfo& destsz = dest.info(); 
    const ArrayNDInfo& srcsz = src.info(); 

    const int ndim = destsz.getNDim();
    if ( ndim != srcsz.getNDim() || ndim != copypos.size() ) return false;

    for ( int idx=0; idx<ndim; idx++ )
    {
	if ( !srcperiodic &&
	     copypos[idx] + destsz.getSize(idx) > srcsz.getSize(idx) )
	    return false;
    }

    ArrayNDIter destposition( destsz );
    TypeSet<int> srcposition( ndim, 0 );

    do
    {
	for ( int idx=0; idx<ndim; idx++ )
	{
	    srcposition[idx] = copypos[idx] + destposition[idx];
	    if ( srcperiodic )
		srcposition[idx] =
		    dePeriodize( srcposition[idx], srcsz.getSize(idx) );
	}

	dest.setND( destposition.getPos(), src.get( &srcposition[0] ));

		
    } while ( destposition.next() );

    return true;
}    


template <class T>
inline bool Array3DCopy( Array3D<T>& dest, const Array3D<T>& src,
		   int p0, int p1, int p2,
		   bool srcperiodic=false )
{
    const ArrayNDInfo& destsz = dest.info(); 
    const ArrayNDInfo& srcsz = src.info(); 

    const int destsz0 = destsz.getSize(0);
    const int destsz1 = destsz.getSize(1);
    const int destsz2 = destsz.getSize(2);

    const int srcsz0 = srcsz.getSize(0);
    const int srcsz1 = srcsz.getSize(1);
    const int srcsz2 = srcsz.getSize(2);

    if ( !srcperiodic )
    {
	if ( p0 + destsz0 > srcsz0 ||
	     p1 + destsz1 > srcsz1 ||
	     p2 + destsz2 > srcsz2  )
	     return false;
    }

    int idx = 0;
    T* ptr = dest.getData();

    for ( int id0=0; id0<destsz0; id0++ )
    {
	for ( int id1=0; id1<destsz1; id1++ )
	{
	    for ( int id2=0; id2<destsz2; id2++ )
	    {
		ptr[idx++] = src.get( dePeriodize(id0 + p0, srcsz0),
					 dePeriodize(id1 + p1, srcsz1), 
					 dePeriodize(id2 + p2, srcsz2));

	    }
	}
    }

    return true;
}    

template <class T>
inline bool ArrayNDPaste( ArrayND<T>& dest, const ArrayND<T>& src,
		   const TypeSet<int>& pastepos,
		   bool destperiodic=false )
{
    const ArrayNDInfo& destsz = dest.info(); 
    const ArrayNDInfo& srcsz = src.info(); 

    const int ndim = destsz.getNDim();
    if ( ndim != srcsz.getNDim() || ndim != pastepos.size() ) return false;

    for ( int idx=0; idx<ndim; idx++ )
    {
	if ( !destperiodic &&
	     pastepos[idx] + srcsz.getSize(idx) > destsz.getSize(idx) )
	    return false;
    }

    ArrayNDIter srcposition( srcsz );
    TypeSet<int> destposition( ndim, 0 );

    int ptrpos = 0;
    T* ptr = src.getData();

    do
    {
	for ( int idx=0; idx<ndim; idx++ )
	{
	    destposition[idx] = pastepos[idx] + srcposition[idx];
	    if ( destperiodic )
		destposition[idx] =
		    dePeriodize( destposition[idx], destsz.getSize(idx) );
	}

	dest( destposition ) =  ptr[ptrpos++];
		
    } while ( srcposition.next() );

    return true;
}    


template <class T>
inline bool Array2DPaste( Array2D<T>& dest, const Array2D<T>& src,
		   int p0, int p1, bool destperiodic=false )
{
    const ArrayNDInfo& destsz = dest.info(); 
    const ArrayNDInfo& srcsz = src.info(); 

    const int srcsz0 = srcsz.getSize(0);
    const int srcsz1 = srcsz.getSize(1);

    const int destsz0 = destsz.getSize(0);
    const int destsz1 = destsz.getSize(1);

    if ( !destperiodic )
    {
	if ( p0 + srcsz0 > destsz0 ||
	     p1 + srcsz1 > destsz1  )
	     return false;
    }


    int idx = 0;
    const T* ptr = src.getData();

    for ( int id0=0; id0<srcsz0; id0++ )
    {
	for ( int id1=0; id1<srcsz1; id1++ )
	{
	    dest.set( dePeriodize( id0 + p0, destsz0),
		  dePeriodize( id1 + p1, destsz1),
		  ptr[idx++]);
	}
    }

    return true;
}


template <class T>
inline bool Array3DPaste( Array3D<T>& dest, const Array3D<T>& src,
		   int p0, int p1, int p2,
		   bool destperiodic=false )
{
    const ArrayNDInfo& destsz = dest.info(); 
    const ArrayNDInfo& srcsz = src.info(); 

    const int srcsz0 = srcsz.getSize(0);
    const int srcsz1 = srcsz.getSize(1);
    const int srcsz2 = srcsz.getSize(2);

    const int destsz0 = destsz.getSize(0);
    const int destsz1 = destsz.getSize(1);
    const int destsz2 = destsz.getSize(2);

    if ( !destperiodic )
    {
	if ( p0 + srcsz0 > destsz0 ||
	     p1 + srcsz1 > destsz1 ||
	     p2 + srcsz2 > destsz2  )
	     return false;
    }


    int idx = 0;
    const T* ptr = src.getData();

    for ( int id0=0; id0<srcsz0; id0++ )
    {
	for ( int id1=0; id1<srcsz1; id1++ )
	{
	    for ( int id2=0; id2<srcsz2; id2++ )
	    {
		dest.set( dePeriodize( id0 + p0, destsz0),
		      dePeriodize( id1 + p1, destsz1),
		      dePeriodize( id2 + p2, destsz2), ptr[idx++]);
	    }
	}
    }

    return true;
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef conncomponents_h
#define conncomponents_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bo Zhang/Yuancheng Liu
 Date:          July 2012
 RCS:           $Id: conncomponents.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/


#include "algomod.h"
#include "factory.h"


template <class T> class Array2D;
template <class T> class Array2DSlice;
template <class T> class Array3D;
template <class T> class TypeSet;

class TaskRunner;

/*!
\brief Classify connected components of a binarized array 2D, components are
sorted in size. User could get the best quadratic fit for the component if
needed.
*/

mExpClass(Algo) ConnComponents
{
public:    

    				ConnComponents(const Array2D<bool>&);
				~ConnComponents();

    void			compute(TaskRunner* tr=0); 

    int				nrComponents() const; 
    const TypeSet<int>*		getComponent(int compidx);
    const Array2D<int>*		getLabel() const	{ return label_; }
    void			trimCompBranches(TypeSet<int>& comp);
    static void			trimCompBranches(TypeSet<int>& comp,int sz1);
    static void			getCompSticks(TypeSet<int>& comp,int sz1,
	    				int allowgapsz, int minsticksz,
					TypeSet<TypeSet<int> >& sticks);
    				/*Will change comp, make copy before call this*/

    float			overLapRate(int componentidx);
    				/*Minimum rate of all dimensions.*/

protected:

    void			classifyMarks(Array2D<int>& mark);
    void			setMark(Array2D<int>& r,int source,int newval);

    const Array2D<bool>&	input_;
    Array2D<int>*		label_;
    TypeSet< TypeSet<int> >	components_;
    TypeSet<int>		sortedindex_;
};


/*!
\brief Classify connected components of a binarized array 3D,
components are sorted in size.
*/

mExpClass(Algo) ConnComponents3D 
{
public:    

    				ConnComponents3D(const Array3D<bool>&);
				~ConnComponents3D();

    void			compute(TaskRunner* tr=0); 

    struct VPos	{
				VPos() : i(-1),j(-1),k(-1) {}
				int i;int j;int k;
    		};
    int				nrComponents() const; 
    const ObjectSet<VPos>*	getComponent(int compidx);
    				/*<Comp size is sorted descending. */

protected:

    void			addToComponent(
	    			const TypeSet<TypeSet<TypeSet<int> > >& comps, 
				int sliceidx,int compidx,
				TypeSet<TypeSet<unsigned char> >& usedcomps,
				ObjectSet<VPos>& rescomp);

    const Array3D<bool>&	input_;
    ObjectSet< ObjectSet<VPos> > components_;
    TypeSet<int>		sortedindex_;
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef convolve2d_h
#define convolve2d_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          07-10-1999
 RCS:           $Id: convolve2d.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


*/

#include "complex"
#include "arraynd.h"
#include "task.h"
#include "rowcol.h"

#if defined(__msvc__) && (defined(ALGO_EXPORTS) || defined(Algo_EXPORTS))
# define mAlgoClass	class dll_export
#else
# define mAlgoClass	class
#endif

namespace Fourier { class CC; }
typedef std::complex<float> float_complex;

/*!
\brief Convolves (or correlates) two 2D signals.
*/

template <class T>
mAlgoClass Convolver2D : public ParallelTask
{
public:
				Convolver2D();
				~Convolver2D();

    inline void			setX(const Array2D<T>&,bool hasudfs);
    inline const Array2D<T>*	getX() const		{ return x_; }
    inline void			setY(const Array2D<T>&,bool hasudfs);
    inline const Array2D<T>*	getY() const		{ return x_; }
    inline void			setZ(Array2D<T>& z )	{ z_ = &z; }
    void			setNormalize( bool n )	{ normalize_ = n; }
				/*!<If true, the sum will be divided by
				    the sum of Y. */
    void			setCorrelate( bool yn )	{ correlate_ = yn; }
				/*!<If true, the convolution will be replaced
				    by a correllation. */
    od_int64             	nrIterations() const;

protected:
    bool		doWork(od_int64,od_int64,int);
    bool		doNonFFTWork(od_int64,od_int64,int);
    bool		doPrepare(int);
    bool		shouldFFT() const;

    const Array2D<T>*	x_;
    const Array2D<T>*	y_;
    Array2D<T>*		z_;
    bool		normalize_;
    bool		correlate_;
    bool		xhasudfs_;
    bool		yhasudfs_;

    float_complex*	xf_;
    float_complex*	yf_;
    float_complex*	zf_;

    bool		updatexf_;
    bool		updateyf_;

    Fourier::CC*	fft_;
};




template <> inline
bool Convolver2D<float>::shouldFFT() const
{
    if ( xhasudfs_ || yhasudfs_ || x_->info()!=y_->info() ||
	 x_->info()!=z_->info() )
	return false;

    return true;
}


template <> inline
od_int64 Convolver2D<float>::nrIterations() const
{
    return shouldFFT()
        ? 1 
        : z_->info().getTotalSz();
}


template <class T> inline
bool Convolver2D<T>::shouldFFT() const
{ return false; }


template <class T> inline
Convolver2D<T>::Convolver2D()
    : x_( 0 )
    , y_( 0 )
    , z_( 0 )
    , normalize_( false )
    , correlate_( false )
    , xhasudfs_( false )
    , yhasudfs_( false )
    , updatexf_( true )
    , updateyf_( true )
    , xf_( 0 )
    , yf_( 0 )
    , zf_( 0 )
    , fft_( 0 )
{}


template <>
Convolver2D<float>::~Convolver2D();


template <class T>
Convolver2D<T>::~Convolver2D()
{}

template <class T> inline
void Convolver2D<T>::setX( const Array2D<T>& x, bool hasudfs )
{
    x_ = &x;
    updatexf_ = true;
    xhasudfs_ = hasudfs;
}


template <class T> inline
void Convolver2D<T>::setY( const Array2D<T>& y, bool hasudfs )
{
    y_ = &y;
    updateyf_ = true;
    yhasudfs_ = hasudfs;
}




#define mConvolver2DSetIndex( dim ) \
const char y##dim##inc = correlate_ ? 1 : -1; \
const int idy##dim = firsty##dim+idx##dim*y##dim##inc; \
if ( idy##dim<0 ) \
{ \
    if ( correlate_ ) \
    { \
	idx##dim += (-idy##dim)-1; \
	continue; \
    } \
 \
    break; \
} \
 \
if ( idy##dim>=ysz##dim ) \
{ \
    if ( correlate_ ) \
	break; \
 \
    const int diff = idy##dim-(ysz##dim-1); \
    idx##dim += diff-1; \
    continue; \
}


template <class T> inline
od_int64 Convolver2D<T>::nrIterations() const
{
    return shouldFFT()
	? 1 
	: z_->info().getTotalSz(); 
}


template <>
bool Convolver2D<float>::doWork( od_int64 start, od_int64 stop, int );


template <class T> inline
bool Convolver2D<T>::doWork( od_int64 start, od_int64 stop, int thread )
{
    return doNonFFTWork( start, stop, thread );
}


template <class T> inline
bool Convolver2D<T>::doNonFFTWork( od_int64 start, od_int64 stop, int )
{
    const int xsz0 = x_->info().getSize( 0 );
    const int xsz1 = x_->info().getSize( 1 );
    const int ysz0 = y_->info().getSize( 0 );
    const int ysz1 = y_->info().getSize( 1 );

    int startpos[2];

    if ( !z_->info().getArrayPos( start, startpos ) )
	return false;

    ArrayNDIter iterator( z_->info() );
    iterator.setPos( startpos );

    const ValueSeries<T>* xstor_ = x_->getStorage();
    const T* xptr_ = x_->getData();

    const ValueSeries<T>* ystor_ = y_->getStorage();
    const T* yptr_ = y_->getData();

    for ( od_int64 idx=start; idx<=stop; idx++ )
    {
	const int* zvar = iterator.getPos();
	const int firsty0 = correlate_ ? -zvar[0] : zvar[0];
	const int firsty1 = correlate_ ? -zvar[1] : zvar[1];
	T sum = 0;
	T ysum = 0;
	int nrsamples = 0;

	for ( int idx0=0; idx0<xsz0 && shouldContinue(); idx0++ )
	{
	    mConvolver2DSetIndex( 0 );

	    const od_int64 yoffset = ystor_ || yptr_ ?
		y_->info().getOffset( idy0, 0 ) : 0;

            const od_int64 xoffset = xstor_ || xptr_ ?
		x_->info().getOffset( idx0, 0 ) : 0;

	    for ( int idx1=0; idx1<xsz1; idx1++ )
	    {
		mConvolver2DSetIndex( 1 );

		const T yval = yptr_
		    ? yptr_[yoffset+idy1]
		    : ystor_
			? ystor_->value( yoffset+idy1 )
			: y_->get( idy0, idy1 );

		if ( mIsUdf(yval) )
		    continue;

		const T xval = xptr_
		    ? xptr_[xoffset+idx1]
		    : xstor_
			? xstor_->value( xoffset+idx1 )
			: x_->get( idx0, idx1 );

		if ( mIsUdf(xval) )
		    continue;

		sum += xval * yval;
		ysum += yval;
		nrsamples++;
	    }
	}

	if ( !nrsamples ) z_->setND( zvar, 0 );
	else if ( normalize_ && !mIsZero(ysum,1e-8) )
	    z_->setND( zvar, sum/ysum );
	else z_->setND( zvar, sum );

	addToNrDone( 1 );

	if ( !iterator.next() && idx!=stop )
	    return false;
    }

    return true;
}


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef convolve3d_h
#define convolve3d_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          Feb 2008
 RCS:           $Id: convolve3d.h 30724 2013-07-15 04:29:53Z satyaki.maitra@dgbes.com $
________________________________________________________________________


*/

#include "arraynd.h"
#include "task.h"
#include "math2.h"

/*!
\brief Convolves (or correlates) two 3D signals.
*/

template <class T>
mClass(Algo) Convolver3D : public ParallelTask
{
public:
    inline		Convolver3D();

    inline void		setX(const Array3D<T>&,
	    		     int first0=0,int first1=0, int first2=0);
    inline void		setY(const Array3D<T>&,
	    		     int first0=0,int first1=0, int first2=0);
    inline void		setZ(Array3D<T>& z )		{ z_ = &z; }
    void		setNormalize( bool n )		{ normalize_ = n; }
    			/*!<If true, the sum will be divided by
			    the sum of Y.*/
    void		setCorrelate( bool yn )		{ correlate_ = yn; }
    			/*!<If true, the convolution will be replaced by a
			   correllation. */
    void		setHasUdfs(bool yn)		{ hasudfs_ = yn; }
    			//!<Default is false

    virtual bool	executeParallel(bool);

protected:
    inline bool		shouldFFT() const;

    bool		doFFT();
    inline bool		doWork( od_int64, od_int64, int );
    od_int64		nrIterations() const { return z_->info().getTotalSz(); }
    const Array3D<T>*	x_;
    int			xshift0_;
    int			xshift1_;
    int			xshift2_;
    const Array3D<T>*	y_;
    int			yshift0_;
    int			yshift1_;
    int			yshift2_;

    Array3D<T>*		z_;
    bool		normalize_;
    bool		correlate_;

    bool		hasudfs_;
};


template <class T> inline
Convolver3D<T>::Convolver3D()
    : x_( 0 )
    , xshift0_( 0 )
    , xshift1_( 0 )
    , xshift2_( 0 )
    , y_( 0 )
    , yshift0_( 0 )
    , yshift1_( 0 )
    , yshift2_( 0 )
    , z_( 0 )
    , normalize_( false )
    , correlate_( false )
    , hasudfs_( false )
{}


template <class T> inline
void Convolver3D<T>::setX( const Array3D<T>& x,
			   int first0, int first1, int first2 )
{
    x_ = &x;
    xshift0_ = first0;
    xshift1_ = first1;
    xshift2_ = first2;
}


template <class T> inline
void Convolver3D<T>::setY( const Array3D<T>& y, int first0, int first1,
       			   int first2 )
{
    y_ = &y;
    yshift0_ = first0;
    yshift1_ = first1;
    yshift2_ = first2;
}


#define mConvolver3DSetY( dim ) \
const int firsty##dim = correlate_ \
    ? -xshift##dim##_-zvar[dim]+yshift##dim##_ \
    : zvar[dim]+xshift##dim##_+yshift##dim##_; \
\
    const char y##dim##inc = correlate_ ? 1 : -1


#define mConvolver3DSetIndex( dim ) \
const int idy##dim = firsty##dim+idx##dim*y##dim##inc; \
if ( idy##dim<0 ) \
{ \
    if ( correlate_ ) \
    { \
	idx##dim += (-idy##dim)-1; \
	continue; \
    } \
 \
    break; \
} \
 \
if ( idy##dim>=ysz##dim ) \
{ \
    if ( correlate_ ) \
	break; \
 \
    const int diff = idy##dim-(ysz##dim-1); \
    idx##dim += diff-1; \
    continue; \
}


template <class T> inline
bool Convolver3D<T>::doWork( od_int64 start, od_int64 stop, int )
{
    const int xsz0 = x_->info().getSize( 0 );
    const int xsz1 = x_->info().getSize( 1 );
    const int xsz2 = x_->info().getSize( 2 );
    const int ysz0 = y_->info().getSize( 0 );
    const int ysz1 = y_->info().getSize( 1 );
    const int ysz2 = y_->info().getSize( 2 );

    int startpos[3];

    if ( !z_->info().getArrayPos( start, startpos ) )
	return false;

    ArrayNDIter iterator( z_->info() );
    iterator.setPos( startpos );

    const ValueSeries<T>* xstor_ = x_->getStorage();
    const T* xptr_ = x_->getData();

    const ValueSeries<T>* ystor_ = y_->getStorage();
    const T* yptr_ = y_->getData();

    for ( int idx=mCast(int,start); idx<=stop; idx++ )
    {
	const int* zvar = iterator.getPos();
	T sum = 0;
	T ysum = 0;
	int nrsamples = 0;

	mConvolver3DSetY( 0 );
	mConvolver3DSetY( 1 );
	mConvolver3DSetY( 2 );

	for ( int idx0=0; idx0<xsz0 && shouldContinue(); idx0++ )
	{
	    mConvolver3DSetIndex( 0 );

	    for ( int idx1=0; idx1<xsz1; idx1++ )
	    {
		mConvolver3DSetIndex( 1 );

		const od_int64 yoffset = ystor_ || yptr_ ?
		    y_->info().getOffset( idy0, idy1, 0 ) : 0;

		const od_int64 xoffset = xstor_ || xptr_ ?
		    x_->info().getOffset( idx0, idx1, 0 ) : 0;

		for ( int idx2=0; idx2<xsz2; idx2++ )
		{
		    mConvolver3DSetIndex( 2 );

		    const T yval = yptr_
			? yptr_[yoffset+idy2]
			: ystor_
			    ? ystor_->value( yoffset+idy2 )
			    : y_->get( idy0, idy1, idy2 );

		    if ( mIsUdf(yval) )
			continue;

		    const T xval = xptr_
			? xptr_[xoffset+idx2]
			: xstor_
			    ? xstor_->value( xoffset+idx2 )
			    : x_->get( idx0, idx1, idx2 );

		    if ( mIsUdf(xval) )
			continue;

		    sum += xval * yval;
		    ysum += yval;
		    nrsamples++;
		}
	    }
	}

	if ( !nrsamples ) z_->setND( zvar, 0 );
	else if ( normalize_ && !mIsZero(ysum,1e-8) )
	    z_->setND( zvar, sum/ysum );
	else z_->setND( zvar, sum );

	addToNrDone( 1 );

	if ( !iterator.next() && idx!=stop )
	    return false;
    }

    return true;
}


template <class T> inline
bool Convolver3D<T>::executeParallel( bool yn )
{
    if ( shouldFFT() )
	return doFFT();

    return ParallelTask::executeParallel( yn );
}


template <class T> inline
bool Convolver3D<T>::doFFT()
{
    //TODO
    return false;
}
	

template <class T> inline
bool Convolver3D<T>::shouldFFT() const
{
    return false;
}

template <> inline
bool Convolver3D<float>::shouldFFT() const
{
    return false; //Remove when doFFT is implemented
/*
    if ( correlate_ || normalize_ )
	return false;

    if ( !x_ || !y_ || !z_ )
	return false;

    const int xsz = x_->info().getTotalSz();
    const int ysz = y_->info().getTotalSz();
    const int zsz = z_->info().getTotalSz();

    int maxsz = x_->info().getTotalSz();
    maxsz = mMAX( maxsz, y_->info().getTotalSz() );
    maxsz = mMAX( maxsz, z_->info().getTotalSz() );

    const int tradsz = zsz * mMIN(ysz,xsz);
    const float fftszf = maxsz * Math::Log( (float) maxsz );
    const int fftsz = mNINT32( fftszf );


    return fftsz<tradsz;
    */
}


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef fftfilter_h
#define fftfilter_h

/*
________________________________________________________________________

(C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
Author:        Bruno
Date:          6-10-2009
RCS:           $Id: fftfilter.h 30380 2013-06-20 08:32:06Z arnaud.huck@dgbes.com $
________________________________________________________________________

*/


#include "algomod.h"
#include "arrayndalgo.h"
#include "enums.h"

#include <complex>

namespace Fourier { class CC; }
class ArrayNDWindow;

template <class T> class Array1DImpl;
typedef std::complex<float> float_complex;


/*!
\brief Classical FFT filter, use set to set up data step, min and max
frequency and type of the filter (minfreq not required for highpass, maxfreq
not required for lowpass)
*/ 

mExpClass(Algo) FFTFilter
{

public:
			FFTFilter(int sz, float step);
			~FFTFilter();	   

			enum Type		{ LowPass, HighPass, BandPass };
			DeclareEnumUtils(Type)

    void  		setLowPass(float cutf3,float cutf4);
    void  		setHighPass(float cutf1,float cutf2);
    void  		setBandPass(float cutf1,float cutf2,
	    			    float cutf3,float cutf4);
    			// The following will auto taper 5% of the filter size
    void  		setLowPass(float cutf4);
    void  		setHighPass(float cutf1);
    void  		setBandPass(float cutf1,float cutf4);

				//will taper the array before apply
    			//do not use for strictly positive/negative signal
    bool		setTimeTaperWindow(int sz, BufferString wintype,
	    				   float var=0.95);

    bool		apply(Array1DImpl<float>&);
    bool		apply(Array1DImpl<float_complex>&,bool dopreproc=true);

    Type		getFilterType() const;
    bool		isLowPass() const;
    bool		isHighPass() const;

				// Do not use, will be removed
    void  		setLowPass(float df,float cutf,bool zeropad); 
    void  		setHighPass(float df,float cutf,bool zeropad); 
    void  		setBandPass(float df,float cutf1,float cutf2,bool pad); 
    void  		set(float df,float cutf1,float cutf2,Type,bool zeropad); 
    void		apply(const float*,float*,int sz) const;
    void		apply(const float_complex*,float_complex*,int sz) const;

    void		apply(const Array1DImpl<float>&,
	    			 Array1DImpl<float>&) const;
    void		apply(const Array1DImpl<float_complex>&,
	    			 Array1DImpl<float_complex>&) const;

			//will taper the array before apply
    void		setTaperWindow( float* samp, int sz )
			{ delete timewindow_; timewindow_=new Window(samp,sz); }

			//optional cut-off the frequency with a window
    void		setFreqBorderWindow(float* win,int sz,bool forlowpass);

    int			getFFTFastSize(int nrsamps) const;

protected:

    int			fftsz_;
    int			sz_;
    float		df_;
    float		step_;
    float		cutfreq1_;
    float		cutfreq2_;
    float		cutfreq3_;
    float		cutfreq4_;

    Fourier::CC*	fft_; 
    ArrayNDWindow*	timewindownew_;
    ArrayNDWindow*	freqwindow_;
    Array1DImpl<float>*	trendreal_;
    Array1DImpl<float>*	trendimag_;
    BoolTypeSet		isudfreal_;
    BoolTypeSet		isudfimag_;

    void  		buildFreqTaperWin();

    			// will store the position of undef points
    bool		interpUdf(Array1DImpl<float>&,bool isimag=false);
    bool		interpUdf(Array1DImpl<float_complex>&);
    void		restoreUdf(Array1DImpl<float>&,bool isimag=false) const;
    void		restoreUdf(Array1DImpl<float_complex>&) const;
    			// will store the removed trend
    bool		deTrend(Array1DImpl<float>& outp,bool isimag=false);
    bool		deTrend(Array1DImpl<float_complex>&);
    bool		restoreTrend(Array1DImpl<float>& outp,
	    			     bool isimag=false) const;
    bool		restoreTrend(Array1DImpl<float_complex>&) const;
    void		reSize(const Array1DImpl<float_complex>& inp,
	    		       Array1DImpl<float_complex>& outp) const;
    void 		reSize(const Array1DImpl<float>& inp,
	    		       Array1DImpl<float>& outp) const;
    void		restoreSize(const Array1DImpl<float_complex>& inp,
	    			    Array1DImpl<float_complex>& outp) const;
    void		restoreSize(const Array1DImpl<float>& inp,
	    			    Array1DImpl<float>& outp) const;

    // Do not use, will be removed
public:
			FFTFilter();

protected:

    mStruct(Algo) Window
    {
			Window(float* win,int sz)
			    : win_(win)
			    , size_(sz)		{}

			int size_;
			float* win_;
    };

    Type		type_;
    bool		iszeropadd_;
    Window*		timewindow_;
    Window*		hfreqwindow_;
    Window*		lfreqwindow_;

    void 		FFTFreqFilter(float,float,bool,
			    const float_complex*,float_complex*,int sz) const;
    void   		FFTBandPassFilter(float,float,float,
			    const float_complex*,float_complex*,int sz) const;
};

#endif



/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef fingervein_h
#define fingervein_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bo Zhang/Yuancheng Liu
 Date:          July 2012
 RCS:           $Id: fingervein.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#include "algomod.h"
#include "factory.h"

template <class T> class Array2D;
template <class T> class Array3D;

class TaskRunner;

/*!
\brief Get a flag output for faults based on 2D input attribute data.
*/

mExpClass(Algo) FingerVein
{
public:    

    				FingerVein(const Array2D<float>&,
					   float threshold,bool isabove,
					   bool istimeslcie,
					   Array2D<bool>& output);
				~FingerVein()	{}

    bool			compute(bool domerge=false,bool dothinning=true,
	    				int minfltlength=10,
					float overlaprate=0.9,
					int sigma=3,float thresholdpercent=0.9,
					TaskRunner* tr=0);
    const TypeSet<TypeSet<int> >& validConnComponents() const 
    				{ return validconncomps_; }
    const TypeSet<int>& 	nrConnComponents() const { return nrcomps_; }
    const TypeSet<int>& 	compIndices() const  	 { return compids_; }
    void			thinning(Array2D<bool>& res,bool skeleton=true);

protected:

    void			removeSmallComponents(Array2D<bool>&,
	    				int minfltlength,float overlaprate,
					bool savecomps=true);

    const Array2D<float>&	input_;
    Array2D<bool>&		output_;
    float			threshold_;
    bool			isabove_;
    bool			istimeslice_;
    TypeSet<TypeSet<int> >	validconncomps_;
    TypeSet<int>		nrcomps_;
    TypeSet<int>		compids_;
};


/*!
\brief Calculate azimuth and dip for 3D data.
*/

mExpClass(Algo) FaultOrientation
{
public:    

    				FaultOrientation();
				~FaultOrientation();

    void			setThreshold(float threshold,bool isabove);
    void			setMinFaultLength(int minleng);
    void			setParameters(int sigma=3,float scorerate=0.9);
    				/*!<sigma is Gaussian kernel sigma, scorerate 
				  is between 0 and 1.*/
    bool			compute(const Array3D<float>& input,
	    				bool forazimuth=true,bool fordip=true,
					TaskRunner* tr=0);

    const Array3D<float>*	getAzimuth() const { return azimuth_stable_; }
    const Array3D<float>*	getDip() const	   { return dip_stable_; }

    enum ConfidenceLevel	{ Low=0, Median=1, High=2 };
    const Array3D<bool>*	getFaultConfidence(ConfidenceLevel);
    
    static bool			compute2DVeinBinary(const Array2D<float>& img, 
		    			float threshold, bool isabove,
					int minlength,int sigma,float perc,  
					bool is_t_slic,Array2D<bool>& vein_bina,
					TaskRunner* tr);
    static bool			computeMaxCurvature(const Array2D<float>& inp, 
					int sigma,bool is_t_slic,
					Array2D<float>& vein_score,
					TaskRunner* tr);
    static void			thinning(const Array2D<bool>& input,
		   			 Array2D<bool>& res);
    static void			skeletonHilditch( Array2D<char>& input);
    static void			computeComponentAngle(
	    				const Array2D<bool>& base_bina_sect,
					const Array2D<bool>& upgr_bina_sect,
					int elem_leng,float null_val,
					Array2D<float>& azimuth_sect);
protected:

    friend class		veinSliceCalculator;
    friend class		azimuthPcaCalculator;

    void			cleanAll();
    bool			compute2D(const Array3D<float>& input,
	    				  TaskRunner* tr=0);
    bool			computeVeinSlices(const Array3D<float>& input,
					Array3D<bool>& output,TaskRunner* tr);
    void			computeVerticalVeinSlice(
	    				const Array3D<float>& input,
					Array3D<bool>& vein_bina_0,
					Array3D<bool>& vein_bina_45, 
	    				Array3D<bool>& vein_bina_90,
					Array3D<bool>& vein_bina_135);
    bool			computeAzimuthPCA(const Array3D<bool>& conf_low,
					const Array3D<bool>& conf_medi,
					int elem_leng,float null_val,
					Array3D<float>& output,TaskRunner* tr);
    void			stabilizeAzimuth(const Array3D<bool>& conf_low,
	    				const Array3D<float>& azimuth_pca, 
					int elem_leng,float null_val,
			    		Array3D<float>& output);
    void			setFaultConfidence(const Array3D<bool>& vbina,
	    				const Array3D<bool>& vein_bina_0,
	    				const Array3D<bool>& vein_bina_45,
    					const Array3D<bool>& vein_bina_90,
					const Array3D<bool>& vein_bina_135,
					Array3D<bool>& conf_low, 
					Array3D<bool>& conf_medi,
					Array3D<bool>& conf_high);
    void			stablizeDip(const Array3D<bool>& conf_low,
	    				const Array3D<float>& azm_pca_stab,
	    				const Array3D<float>& dip_pca, 
    					int wind_size,int elem_leng,
					float null_val,Array3D<float>& output);
    void			computeDipPCA(const Array3D<bool>& conf_low,
					const Array3D<bool>& conf_medi, 
					const Array3D<float>& azm_pca_stab,
    					int wind_size,int elem_leng,
					float null_val,Array3D<float>& dip_pca);
    void			stabilizeAngleSection( 
	    				const Array2D<bool>& base_bina,
		    			const Array2D<float>& azimuth_orig, 
					int elem_leng,float uppr_perc,
					float lowr_perc,float angl_tole,
					float null_value,Array2D<float>& res);
    static void			thinStep(const Array2D<bool>& input,
					 Array2D<bool>& output,bool isfirst);
    static float		getAnglePCA(const TypeSet<int>& point_set_x,
					  const TypeSet<int>& point_set_y,
					  float null_value);

    float			threshold_;
    float			scorerate_;
    bool			isfltabove_;
    int				minfaultlength_;
    int				sigma_;
    Array3D<float>*		azimuth_stable_;
    Array3D<float>*		dip_stable_; 
    Array3D<bool>*		conf_low_; 
    Array3D<bool>*		conf_med_; 
    Array3D<bool>*		conf_high_; 
};

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef fourier_h
#define fourier_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl/Y. Liu
 Date:		August 2001
 RCS:		$Id: fourier.h 32175 2013-10-29 11:42:06Z arnaud.huck@dgbes.com $
________________________________________________________________________

*/

#include "algomod.h"
#include "transform.h"

#include "factory.h"


namespace Fourier
{

class FFTCC1D;

/*!
\brief Does Fourier Transforms of any size.
*/

mExpClass(Algo) CC : public GenericTransformND
{
public:
    mDefaultFactoryInstantiation( CC, CC, "PFAFFT", "FFT" );
    static ::Factory<CC>& factory();

    static CC*		createDefault();

    			CC();
    void		setNormalization(bool yn); 
    static float	getNyqvist(float samplespacing);
    static float	getDf(float samplespacing,int nrsamples);
    static void		getFrequencies(float samplespacing,int nrsamples,
	    			       TypeSet<float>&);
    bool		isFast(int sz) const;
    virtual int		getFastSize(int sz) const;
			/*!<Returns a size that is equal or larger than sz */
    
    
    static void pfarc(int isign,int n,const float* rz,float_complex* cz);
    static void pfacr(int isign,int n,const float_complex*,float* rz);
    static int npfaro(int nmin, int nmax);
    static int npfao(int nmin, int nmax);

protected:
    static void pfacc(char dir,int sz,int step,float_complex* signal);
    /*!<Prime number size FFT where the signal has a sampling not equal to 1, 
      i.e. every Nth value should be used.
      \param dir 1 for forward, -1 for backwards
      \param sz Length of signal
      \param step is the step between the samples of the signal
      \param signal Is the signal itself. The output will be written to signal.
    */
    static void pfacc(char dir,int sz,int step,int nr,const int* starts,
		      float_complex* signal);
    static void pfacc(char dir,int sz,int step,int nr,int batchstep,
		      float_complex* signal);
    static void pfacc(char dir,int sz,float_complex*);

    bool		setup();
    bool		normalize_;

    Transform1D*	createTransform() const;
    mClass(Algo) CC1D : public GenericTransformND::Transform1D, public ParallelTask
    {
	public:
			CC1D();
			~CC1D();
	bool            init();
	bool            run(bool parallel)
			{ return executeParallel( parallel ); }
	od_int64        nrIterations() const	{ return nr_; }
	bool            doPrepare(int);
	bool            doWork(od_int64 start, od_int64 stop, int );
	void		setNormalization(bool yn)	{ normalize_ = yn; }

	static int	getFastSize(int sz);
			/*!<Returns a size that is equal or larger than sz */

    protected:

	bool            	dopfa_;
	char			direction_;
	int			higheststart_;
	bool			normalize_;
	ObjectSet<FFTCC1D>	ffts_;
    };
};


/*!
\brief Computes FFT for any size of data.
*/

mExpClass(Algo) FFTCC1D
{
public:
    			FFTCC1D();
			FFTCC1D(const FFTCC1D&);
			//!<Not implemented, just here to make linker complain

    			~FFTCC1D()			{ cleanUp(); }
    bool		setSize(int); 
    			//!<the size of fft to be calculated
    void		setSample(int smp)		{ sample_ = smp; }
    			//!<step of the data from input	
    void		setDir(bool forward)		{ forward_ = forward; }
    void		setNormalization(bool yn)	{ normalize_ = yn; } 
    bool		run(float_complex* data);

protected:

    void		cleanUp();
    bool		getSizeFactors();
    bool		doFactor2() const;
    			//!<ret true means the whole FFT is over
    bool		doFactor4() const;
    void		doFactor3() const;
    void		doFactor5() const;
    void		doOtherFactor(int factor,int psz);
    void		doRotation(int psz) const;
    bool		doFinish();
    bool		setupPermutation();

    bool		forward_;
    bool		normalize_;
    int			size_;
    int			sample_;
    int			totalsmp_;
    int			extsz_;
    int			curf_;
    int			rmfid_;
    int			cycleid_;
    float		exp_;
    float		sin2_;

    float_complex*	data_;
    float*		rdata_;
    float*		idata_;
    float*		rtmp_;
    float*		itmp_;
    float*		cosv_;
    float*		sinv_;
    int*		permutation0_;
    int*		permutation1_;
    TypeSet<int>	permutfactors_;    
    TypeSet<int>	factors_;
};


};//end of namespace Fourier


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef genericnumer_h
#define genericnumer_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          07-10-1999
 RCS:           $Id: genericnumer.h 30322 2013-06-17 09:01:27Z nageswara.rao@dgbes.com $
________________________________________________________________________


*/

#include "algomod.h"
#include "mathfunc.h"
#include <math.h>

/*!>
Compute z = x convolved with y; i.e.,

           ifx+lx-1
    z[i] =   sum    x[j]*y[i-j]  ;  i = ifz,...,ifz+lz-1
            j=ifx
*/

template <class A, class B, class C>
inline void GenericConvolve( int lx, int ifx, const A& x, 
			     int ly, int ify, const B& y,
			     int lz, int ifz, C& z)
{
    int ilx=ifx+lx-1,ily=ify+ly-1,ilz=ifz+lz-1,i,j,jlow,jhigh;
    float sum;

    for ( i=ifz; i<=ilz; ++i )
    {
	jlow = i-ily;
	if ( jlow < ifx ) jlow = ifx;

	jhigh = i-ify;
	if ( jhigh > ilx ) jhigh = ilx;

	for ( j=jlow,sum=0.0; j<=jhigh; ++j )
	{
	    if( !mIsUdf(x[j-ifx]) && !mIsUdf(y[i-j-ify]) )
		sum += x[j-ifx]*y[i-j-ify];
	}

	z[i-ifz] = sum;
    }
}



/*!> similarity is the hyperspace distance between two vectors divided by
the sum of the lengths */

template <class A, class B>
inline float similarity( const A& a, const B& b, int sz, bool normalize=false,
			 int firstposa=0, int firstposb=0 )
{
    float val1, val2;
    double sqdist = 0, sq1 = 0, sq2 = 0;

    double meana = mUdf(double), stddeva = mUdf(double);
    double meanb = mUdf(double), stddevb = mUdf(double);

    if ( normalize )
    {
	if ( sz==1 ) normalize = false;
	else
	{
	    double asum=0,bsum=0;
	    for ( int idx=0; idx<sz; idx++ )
	    {
		asum += a[firstposa+idx];
		bsum += b[firstposb+idx];
	    }

	    meana = asum/sz;
	    meanb = bsum/sz;

	    asum = 0;
	    bsum = 0;
	    for ( int idx=0; idx<sz; idx++ )
	    {
		const double adiff = a[firstposa+idx]-meana;
		const double bdiff = b[firstposb+idx]-meanb;
		asum += adiff*adiff;
		bsum += bdiff*bdiff;
	    }

	    stddeva = Math::Sqrt(asum/(sz-1));
	    stddevb = Math::Sqrt(bsum/(sz-1));

	    if ( mIsZero(stddeva,mDefEps) || mIsZero(stddevb,mDefEps) )
		normalize=false;
	}
    }

    int curposa = firstposa;
    int curposb = firstposb;

    for ( int idx=0; idx<sz; idx++ )
    {
	val1 = normalize ? (float) ( (a[curposa]-meana)/stddeva ) : a[curposa];
	val2 = normalize ? (float) ( (b[curposb]-meanb)/stddevb ) : b[curposb];
	if ( mIsUdf(val1) || mIsUdf(val2) )
	    return mUdf(float);

	sq1 += val1 * val1;
	sq2 += val2 * val2;
	sqdist += (val1-val2) * (val1-val2);

	curposa ++;
	curposb ++;
    }

    if ( mIsZero(sq1,mDefEps) && mIsZero(sq2,mDefEps) )
	return 1;

    if ( mIsZero(sq1,mDefEps) || mIsZero(sq2,mDefEps) )
	return 0;

    const float rt = 
	    (float) ( Math::Sqrt(sqdist) / (Math::Sqrt(sq1) + Math::Sqrt(sq2)) );
    return 1 - rt;
}


mGlobal(Algo) float similarity(const FloatMathFunction&,const FloatMathFunction&, 
		 float x1, float x2, float dist, int sz, bool normalize );


mGlobal(Algo) float semblance( const ObjectSet<float>& signals,const Interval<int>& );

mGlobal(Algo) float semblance( const ObjectSet<float>& signals,int signalsize,
			 const TypeSet<float>& signalstarts,
			 const Interval<int>& gate );

mGlobal(Algo) double LanczosKernel( int size, double x );

/*!> uses parabolic search for the position where a function gets
a specific value. The target value must be in the interval f(x1) and f(x2).
There is no use to have a tolerance lower than the square root of the system's
float-precision. */


mGlobal(Algo) bool findValue(const FloatMathFunction&,float x1,float x2,float& res,
	       float targetval = 0,float tol=1e-5);


/*!> findValueInAperture is similar to findValue, with the difference that
findValueInAperture searches the solution that is closest to the startx. If no
solution is found, startx is returned. The parameter dx specifies how big
intervals should be used when searching for a solution. When a solution is
found in an interval, a high precision search is started in that interval.
*/

mGlobal(Algo) float findValueInAperture(const FloatMathFunction&,float startx, 
	 	const Interval<float>& aperture,float dx,float target=0,
		float tol=1e-5);

/*!>
findExtreme - finds a functions minimal or maximum value (specified by bool 
minima) within the values x1 and x2. 
f((x1+x2)/2) should be less than f(x1) and f(x2). If no minima can be found,
mUdf(float) is returned;
*/

mGlobal(Algo) float findExtreme(const FloatMathFunction&,bool minima,float x1,float x2,
		  float tol = 1e-5);


template <class A, class B> inline
void reSample( const FloatMathFunction& input, const A& samplevals,
	       B& output, int nrsamples )
{
    for ( int idx=0; idx<nrsamples; idx++ )
    {
	const float sampleval = samplevals[idx];
	output[idx] = Values::isUdf(sampleval) ? mUdf(float) :
	    	      input.getValue(sampleval);
    }
}


/*!Computes the greatest common divisor from two intigers. Uses the algorithm
   published by Josef Stein. */

mGlobal(Algo) unsigned int greatestCommonDivisor( unsigned int u, unsigned int v );


/*!>
Compute z = x cross-correlated with y; i.e.,

	   ifx+lx-1
   z[i] =   sum    x[j]*y[i+j]  ;  i = ifz,...,ifz+lz-1
	   j=ifx

Cross correlation will be performed using GenericConvolve function, here is the
method used:
1) reverse the samples in the x array ->copy them to a temporary array,
2) use the temporary array to call function GenericConvolve() 
   with ifx set to 1-ifx-lx.
*/

template <class A, class B, class C>
inline void genericCrossCorrelation( int lx, int ifx, const A& x, 
			     	     int ly, int ify, const B& y,
			     	     int lz, int ifz, C& z)
{
    ArrPtrMan<float> xreversed = new float[lx];

    for ( int i=0,j=lx-1; i<lx; ++i,--j)
	xreversed[i] = x[j];
    GenericConvolve( lx, 1-ifx-lx, xreversed, ly, ify, y, lz, ifz, z );
}


template <class A>
inline void reverseArray( A* in, int sz, A* out=0 )
{
    if ( out )
	for ( int idx=0; idx<sz; idx++ )
	    out[idx] = in[sz-1-idx];
    else
    {
	mAllocVarLenArr( A, tmparr, sz/2 );
	for ( int idx=0; idx<sz/2; idx++ )
	{
	    tmparr[idx] = in[idx];
	    int opsamp = sz-1-idx;
	    in[idx] = in[opsamp];
	    in[opsamp] = tmparr[idx];
	}
    }
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef hilberttransform_h
#define hilberttransform_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Nanne Hemstra
 Date:		December 2007
 RCS:		$Id: hilberttransform.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "algomod.h"
#include "transform.h"
#include "bufstring.h"

class ArrayNDInfo;
template <class T> class ValueSeries;
template <class T> class ArrayND;

typedef std::complex<float> float_complex;


/*!
\brief Class to compute Hilbert Transform.
*/

mExpClass(Algo) HilbertTransform
{
public:
    			HilbertTransform();
			~HilbertTransform();

    bool		setInputInfo(const ArrayNDInfo&);
    const ArrayNDInfo&	getInputInfo() const		{ return *info_; }

    bool		real2real() const		{ return true; }
    bool		real2complex() const		{ return false; }
    bool		complex2real() const		{ return false; }
    bool		complex2complex() const		{ return false; }

    bool		biDirectional() const		{ return false; }
    bool		setDir(bool fw)			{ return fw; }
    bool		getDir() const			{ return forward_; }

    bool		init();
    void		setHalfLen( int hl )		{ halflen_ = hl; }
    void		setCalcRange(int, int, int);

    bool		transform(const ValueSeries<float>&,int szin,
	    			  ValueSeries<float>&,int szout) const;
    bool		transform(const ArrayND<float>&,ArrayND<float>&) const;
    bool		transform(const ArrayND<float_complex>&,
				  ArrayND<float_complex>&) const;
    bool		transform(const ArrayND<float>&,
				  ArrayND<float_complex>&) const;

    const char*		errMsg() const		{ return errmsg_.str(); }

protected:

    float*		makeHilbWindow(int);
    bool		isPossible(int) const;
    bool		isFast( int ) const		{ return true; }

    bool		forward_;
    int			nrsamples_;
    int			halflen_;
    float*		hilbwindow_;
    ArrayNDInfo*	info_;
    int			startidx_;
    int			convstartidx_;
    int			arrminnrsamp_;

    mutable BufferString errmsg_;
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef idxable_h
#define idxable_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert & Kris
 Date:		Mar 2006
 RCS:		$Id: idxable.h 31551 2013-09-16 11:46:54Z bert.bril@dgbes.com $
________________________________________________________________________

*/

#include "gendefs.h"
#include "interpol1d.h"
#include "mathfunc.h"
#include "sets.h"
#include "sorting.h"

/*!\brief Position-sorted indexable objects

 These are objects that return a value of type T when the [] operator is
 applied. Can range from simple arrays and TypeSets to whatever supports
 the [] operator. The goal is to interpolate between the values. Therefore,
 the position of the values must be known from either the fact that the
 values are regular samples or by specifying another indexable object that
 provides the positions (in float or double).
*/

namespace IdxAble
{

/*!>
  Find value in indexable
*/

template <class T1,class T2,class T3>
inline T3 indexOf( const T1& arr, T3 sz, const T2& val, T3 notfoundval )
{
    for ( T3 idx=0; idx<sz; idx++ )
    {
	if ( arr[idx] == val )
	    return idx;
    }
    return notfoundval;
}

/*!>
  Find value in indexable filled with pointers.
*/

template <class T1,class T2,class T3>
inline T3 derefIndexOf( const T1& arr, T3 sz, const T2& val, T3 notfoundval )
{
    for ( T3 idx=0; idx<sz; idx++ )
    {
	if ( *arr[idx] == val )
	    return idx;
    }
    return notfoundval;
}


/*!>
  Find value in sorted array of positions.
  Equality is tested by == operator -> not for float/double!
  The 'arr' indexable object must return the positions.
  The return par 'idx' may be -1, which means that 'pos' is before the first
  position.
  Return value tells whether there is an exact match. If false, index of
  array member below pos is returned.
*/

template <class T1,class T2,class T3>
bool findPos( const T1& posarr, T3 sz, T2 pos, T3 beforefirst, T3& idx )
{
    idx = beforefirst;
    if ( sz < 1 || pos < posarr[0] )
	return false;

    if ( pos == posarr[0] )
	{ idx = 0; return true; }
    else if ( pos > posarr[sz-1] || pos == posarr[sz-1] )
    	{ idx = sz-1; return pos == posarr[sz-1]; }

    T3 idx1 = 0;
    T3 idx2 = sz-1;
    while ( idx2 - idx1 > 1 )
    {
	idx = (idx2 + idx1) / 2;
	T2 arrval = posarr[idx];
	if ( arrval == pos )		return true;
	else if ( arrval > pos )	idx2 = idx;
	else				idx1 = idx;
    }

    idx = idx1;
    return posarr[idx] == pos;
}


/*!>
  Find value in sorted array of floating point positions.
  Equality is tested by mIsZero.
  The 'arr' indexable object must return the positions.
  The return par 'idx' may be beforefirst, which means that 'pos' is before
  the first position.
  Return value tells whether there is an exact match. If false, index of
  array member below pos is returned.
*/

template <class T1,class T2,class T3>
bool findFPPos( const T1& posarr, T3 sz, T2 pos, T3 beforefirst, T3& idx,
		T2 eps=mDefEps )
{
    idx = beforefirst;
    if ( !sz ) return false;
    if ( sz < 2 || pos <= posarr[0] )
    {
	if ( mIsEqual(pos,posarr[0],eps) )
	    { idx = 0; return true; }
	else
	    return false;
    }
    else if ( pos >= posarr[sz-1] )
    	{ idx = sz-1; return mIsEqual(pos,posarr[sz-1],eps); }

    T3 idx1 = 0;
    T3 idx2 = sz-1;

    while ( idx2 - idx1 > 1 )
    {
	idx = (idx2 + idx1) / 2;
	T2 diff = posarr[idx] - pos;
	if ( mIsZero(diff,eps) )		return true;
	else if ( diff > 0  )		idx2 = idx;
	else				idx1 = idx;
    }

    idx = idx1;
    return mIsEqual(pos,posarr[idx],eps);
}

/*!>
  Find index of nearest point below a given position.
  The 'x' must return the positions.
  The return value may be -1, which means that 'pos' is before the first
  position.
*/

template <class X>
inline int getLowIdx( const X& x, int sz, double pos )
{
    int idx; findFPPos( x, sz, pos, -1, idx ); return idx;
}


/*!>
  Find index of nearest point above a given position.
  The 'x' must return the positions.
  The return value will be 1 if 'pos' is before the second
  The return value will be equal to sz if 'pos' if after the last
  position.
*/


template <class X>
inline int getUpperIdx( const X& x, int sz, double pos )
{
    int idx;
    const bool exactmatch = findFPPos( x, sz, pos, -1, idx );
    return idx < 1 ? 1 : ( exactmatch ? idx : idx+1 );
}


/*!>
 Irregular interpolation.
 The 'x' must return the X-positions of the 'y' values.
*/

template <class X,class Y,class RT>
inline void interpolatePositioned( const X& x, const Y& y, int sz,
				   float desiredx,
				   RT& ret, bool extrapolate=false )
{
    if ( sz < 1 )
	ret = mUdf(RT);
    else if ( sz == 1 )
	ret = extrapolate ? y[0] : mUdf(RT);

    else if ( sz == 2 )
	ret = Interpolate::linear1D( x[0], y[0], x[1], y[1], desiredx );
    else if ( desiredx < x[0] || desiredx > x[sz-1] )
    {
	if ( !extrapolate )
	    ret = mUdf(RT);
	else
	    ret = desiredx < x[0]
		? Interpolate::linear1D( x[0], y[0], x[1], y[1], desiredx )
		: Interpolate::linear1D( x[sz-2], y[sz-2], x[sz-1], y[sz-1],
					 desiredx );
	return;
    }

    int prevpos = getLowIdx( x, sz, desiredx );
    int nextpos = prevpos + 1;

    if ( sz == 3 )
	ret = Interpolate::linear1D( x[prevpos], y[prevpos],
				     x[nextpos], y[nextpos], desiredx );
    else
    {
	if ( prevpos == 0 )
	    { prevpos++; nextpos++; } 
	else if ( nextpos == sz-1 )
	    { prevpos--; nextpos--; } 

	ret = Interpolate::poly1D( x[prevpos-1], y[prevpos-1],
				   x[prevpos], y[prevpos],
				   x[nextpos], y[nextpos],
				   x[nextpos+1], y[nextpos+1],
				   desiredx );
    }
}


template <class X,class Y>
inline float interpolatePositioned( const X& x, const Y& y, int sz, float pos, 
				    bool extrapolate=false )
{
    float ret = mUdf(float);
    interpolatePositioned( x, y, sz, pos, ret, extrapolate );
    return ret;
}


/*!If pos is large, it will loose it's precision. Therefore the target
position in the array is pos+offset. */

template <class T>
inline int getInterpolateIdxsWithOff( const T& idxabl, od_int64 sz,
	od_int64 offset, float pos, bool extrap, float snapdist, od_int64 p[4] )
{
    if ( sz < 1
      || (!extrap && (pos<-snapdist || (pos+offset)>sz-1+snapdist)) )
	return -1;

    od_int64 intpos = mNINT64( pos );
    const float dist = pos - intpos;
    intpos += offset;
    if ( dist>-snapdist && dist<snapdist && intpos>-1 && intpos<sz ) 
	{ p[0] = intpos; return 0; }

    p[1] = dist > 0 ? intpos : intpos - 1;
    if ( p[1] < 0 ) p[1] = 0;
    if ( p[1] >= sz ) p[1] = sz - 1;
    p[0] = p[1] < 1 ? p[1] : p[1] - 1;
    p[2] = p[1] < sz-1 ? p[1] + 1 : p[1];
    p[3] = p[2] < sz-1 ? p[2] + 1 : p[2];
    return 1;
}


template <class T>
inline int getInterpolateIdxs( const T& idxabl, int sz, float pos, bool extrap,
			       float snapdist, od_int64 p[4] )
{
    return getInterpolateIdxsWithOff<T>(idxabl,sz,0,pos,extrap,snapdist,p);
}


template <class T,class RT>
inline bool interpolateReg( const T& idxabl, int sz, float pos, RT& ret,
			    bool extrapolate=false, float snapdist=mDefEps )
{
    od_int64 p[4];
    int res = getInterpolateIdxs( idxabl, sz, pos, extrapolate, snapdist, p );
    if ( res < 0 )
	{ ret = mUdf(RT); return false; }
    else if ( res == 0 )
	{ ret = idxabl[p[0]]; return true; }

    const float relpos = pos - p[1];
    ret = Interpolate::polyReg1D( idxabl[p[0]], idxabl[p[1]], idxabl[p[2]],
				  idxabl[p[3]], relpos );
    return true;
}


/*!If pos is large, it will loose it's precision. Therefore the target
position in the array is pos+offset. */

template <class T,class RT>
inline bool interpolateRegWithUdfWithOff( const T& idxabl, od_int64 sz,
	od_int64 offset, float pos, RT& ret, bool extrapolate=false,
	float snapdist=mDefEps )
{
    od_int64 p[4];
    int res = getInterpolateIdxsWithOff<T>( idxabl, sz, offset, pos,
	    				    extrapolate, snapdist, p );
    if ( res < 0 )
	{ ret = mUdf(RT); return false; }
    else if ( res == 0 )
	{ ret = idxabl[p[0]]; return true; }

    const float relpos = pos - p[1];
    ret = Interpolate::polyReg1DWithUdf( idxabl[p[0]], idxabl[p[1]],
	    				 idxabl[p[2]], idxabl[p[3]], relpos );
    return true;
}


template <class T,class RT>
inline bool interpolateRegWithUdf( const T& idxabl, int sz, float pos, RT& ret,
			    bool extrapolate=false, float snapdist=mDefEps )
{
    return interpolateRegWithUdfWithOff<T,RT>( idxabl, sz, 0, pos, ret,
						extrapolate, snapdist );
}


template <class T>
inline float interpolateReg( const T& idxabl, int sz, float pos,
			     bool extrapolate=false, float snapdist=mDefEps )
{
    float ret = mUdf(float);
    interpolateReg( idxabl, sz, pos, ret, extrapolate, snapdist );
    return ret;
}


template <class T>
inline float interpolateRegWithUdf( const T& idxabl, int sz, float pos,
				    bool extrapolate=false,
				    float snapdist=mDefEps )
{
    float ret = mUdf(float);
    interpolateRegWithUdf( idxabl, sz, pos, ret, extrapolate, snapdist );
    return ret;
}


/*Given an array of values and a number of calibrated values at different
  positions, compute a n array of values that is calibrated everywhere.
  Depending on usefactor, the calibration will either be with absolute numbers
  or with factors. The calibration curve can optionally be output, if
  so, it should have at least sz samples allocated. */


template <class T> inline
void calibrateArray( const T* input, int sz,
	       const T* controlpts, const int* controlsamples, int nrcontrols,
	       bool usefactor, T* output,
	       float* calibrationcurve = 0 )
{
    int firstsample = mUdf(int), lastsample = -mUdf(int);
    PointBasedMathFunction func( PointBasedMathFunction::Linear );
    for ( int idx=0; idx<nrcontrols; idx++ )
    {
	const int sample = controlsamples[idx];
	if ( sample>=sz )
	    continue;

	if ( !idx || sample<firstsample )
	    firstsample = sample;
	if ( !idx || sample>=lastsample )
	    lastsample = sample;

	const float value = usefactor
	    ? controlpts[idx]/input[sample]
	    : controlpts[idx]-input[sample];

	func.add( mCast(float,sample), value );
    }

    if ( !func.size()  )
    {
	memcpy( output, input, sizeof(T)*sz );
	return;
    }

    for ( int idx=0; idx<sz; idx++ )
    {
	float calibration;
	if ( idx<=firstsample )
	   calibration = func.yVals()[0];
	else if ( idx>=lastsample )
	   calibration = func.yVals()[func.size()-1];
	else
	   calibration = func.getValue( mCast(float,idx) );

	output[idx] = usefactor
	    ? input[idx]*calibration 
	    : input[idx]+calibration;

	if ( calibrationcurve )
	    calibrationcurve[idx] = calibration;
    }
}


//! Legacy: function name based on a typo. Don't use, will disappear in 5.0
template <class T> inline
void callibrateArray( const T* input, int sz,
	       const T* controlpts, const int* controlsamples, int nrcontrols,
	       bool usefactor, T* output,
	       float* calibrationcurve = 0 )
{
    calibrateArray( input, sz, controlpts, controlsamples, nrcontrols,
	    		usefactor, output, calibrationcurve );
}


} // namespace IdxAble

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef interpol1d_h
#define interpol1d_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert & Kris
 Date:		Mar 2006
 RCS:		$Id: interpol1d.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "undefval.h"

/*\brief Interpolation for regular and irregular sampling.

  You have to supply the values 'just around' the position.
  In regular sampling, the sample values are spaced in an equidistant manner.

  When you have undefs, there may be a utility which behaves as follows:
  * When the nearest sample value is undefined, return undefined
  * When another value is undef, use a value from a sample near that sample
    and continue the interpolation.

  The position where the interpolation is done is needed.
  A 'float x' must be provided which will be 0 <= x <= 1 in almost all
  cases.

  When things become a bit difficult, the parameters for the interpolation can
  be calculated up front. Then, you'll find a class with an 'apply' method.
  The position for apply is usually between v0 and v1, but doesn't
  _need_ to be. In that case, 0 < pos < 1. For the undef handlign classes and
  functions, this is _required_.
*/

namespace Interpolate
{

/*!>
 Linear interpolation as usual.
*/

template <class T>
inline T linearReg1D( T v0, T v1, float x )
{
    return x * v1 + (1-x) * v0;
}


/*!>
 Linear interpolation as usual with standard undef handling.
*/

template <class T>
inline T linearReg1DWithUdf( T v0, T v1, float x )
{
    if ( mIsUdf(v0) )
	return x < 0.5 ? mUdf(T) : v1;
    if ( mIsUdf(v1) )
	return x >= 0.5 ? mUdf(T) : v0;

    return linearReg1D( v0, v1, x );
}


/*!>
 Interpolate linearly when two points are known.
 Make sure these points are not at the same posistion (crash!).
*/

template <class T>
inline T linear1D( float x0, T v0, float x1, T v1, float x )
{
    return v0 + (x-x0) * (v1-v0) / (x1-x0);
} 

/*!> Same as above, use when iT is from int family */
template <class iT>
inline iT linear1Di( float x0, iT v0, float x1, iT v1, float x )
{
    const float tmp = v0 + (x-x0) * (v1-v0) / (x1-x0);
    return mRounded( iT, tmp );
} 



/*!<\brief Interpolate 1D regularly sampled, using a 3rd order polynome. */

template <class T>
mClass(Algo) PolyReg1D
{
public:

PolyReg1D() {}

PolyReg1D( const T* v )
{
    set( v[0], v[1], v[2], v[3] );
}

PolyReg1D( T vm1, T v0, T v1, T v2 )
{
    set( vm1, v0, v1, v2 );
}

inline void set( T vm1, T v0, T v1, T v2 )
{
    a_[0] = v0;
    a_[1] = v1 - (( 2*vm1 + 3*v0 + v2 ) / 6);
    a_[2] = (( v1 + vm1 ) / 2) - v0;
    a_[3] = (( v1 - vm1 ) / 2) - a_[1];
}

inline T apply( float x ) const
{
    const float xsq = x * x;
    return xsq * x * a_[3] + xsq * a_[2] + x * a_[1] + a_[0];
}

    T	a_[4];
};


template <class T>
inline T polyReg1D( T vm1, T v0, T v1, T v2, float x )
{
    return PolyReg1D<T>(vm1,v0,v1,v2).apply( x );
}


/*!
\brief PolyReg1D which smoothly handles undefined values

  Note that this class _requires_ x to be between 0 and 1 for correct undef
  handling. Correct means: if the nearest sample is undefined, return
  undefined. Otherwise always return a value.
*/

template <class T>
mClass(Algo) PolyReg1DWithUdf
{
public:

PolyReg1DWithUdf()	{}

PolyReg1DWithUdf( const T* v )
{
    set( v[0], v[1], v[2], v[3] );
}

PolyReg1DWithUdf( T vm1, T v0, T v1, T v2 )
{
    set( vm1, v0, v1, v2 );
}

inline void set( T vm1, T v0, T v1, T v2 )
{
    v0udf_ = mIsUdf(v0); v1udf_ = mIsUdf(v1);
    if ( v0udf_ && v1udf_ ) return;

    if ( mIsUdf(vm1) ) vm1 = v0udf_ ? v1 : v0;
    if ( mIsUdf(v2) ) v2 = v1udf_ ? v0 : v1;
    if ( v0udf_ ) v0 = vm1;
    if ( v1udf_ ) v1 = v2;

    intp_.set( vm1, v0, v1, v2 );
}

inline T apply( float x ) const
{
    if ( (v0udf_ && x < 0.5) || (v1udf_ && x >= 0.5) )
	return mUdf(T);
    return intp_.apply( x );
}

    PolyReg1D<T>	intp_;
    bool		v0udf_;
    bool		v1udf_;

};

template <class T>
inline T polyReg1DWithUdf( T vm1, T v0, T v1, T v2, float x )
{
    return PolyReg1DWithUdf<T>(vm1,v0,v1,v2).apply( x );
}


/*!>
 Interpolate when 3 points are known.
 Make sure none of the positions are the same. Will just crash 'silently'.
 No undefined values allowed.
*/

template <class T>
inline T parabolic1D( float x0, T v0, float x1, T v1, float x2, T v2, float x )
{
    float xx0 = x - x0, xx1 = x-x1, xx2 = x-x2;
    return 	v0 * xx1 * xx2 / ((x0 - x1) * (x0 - x2)) +
		v1 * xx0 * xx2 / ((x1 - x0) * (x1 - x2)) +
		v2 * xx0 * xx1 / ((x2 - x0) * (x2 - x1));
}


/*!>
 Interpolate when 4 points are known.
 Make sure none of the positions are the same. Will just crash 'silently'.
 No undefined values allowed.
*/

template <class T>
inline T poly1D( float x0, T v0, float x1, T v1, float x2, T v2, 
		 float x3, T v3, float x )
{
    float xx0 = x - x0, xx1 = x-x1, xx2 = x-x2, xx3 = x-x3;
    return 	v0 * xx1 * xx2 * xx3 / ((x0 - x1) * (x0 - x2) * (x0 - x3)) +
		v1 * xx0 * xx2 * xx3 / ((x1 - x0) * (x1 - x2) * (x1 - x3)) +
		v2 * xx0 * xx1 * xx3 / ((x2 - x0) * (x2 - x1) * (x2 - x3)) +
		v3 * xx0 * xx1 * xx2 / ((x3 - x0) * (x3 - x1) * (x3 - x2));
}


/*!>
 Predict at sample position 0 when two previous and two next are known.
 Returned is the value of the 3rd order polynome that goes through the points.
*/

template <class T>
inline T predictAtZero1D( T vm2, T vm1, T v1, T v2 )
{
    return (-2 * vm2 + 8 * vm1 + 8 * v1 - 2 * v2) / 12;
}


/*!>
 Predict at sample position 0 when three previous and three next are known.
 Returned is the value of the 5th order polynome that goes through the points.
*/

template <class T>
inline T predictAtZero1D( T vm3, T vm2, T vm1, T v1, T v2, T v3 )
{
    return (vm3 - 6 * vm2 + 15 * vm1 + 15 * v1 - 6 * v2 + v3) / 20;
}


} // namespace Interpolate

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef interpol2d_h
#define interpol2d_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Mar 2006
 RCS:		$Id: interpol2d.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "interpol1d.h"

namespace Interpolate
{

/*!
\brief specification for a 2D interpolator

  The 'set' method accepts values arranged like this:
  <pre>
    7 9
  5 1 3 11
  4 0 2 10
    6 8
  </pre>
  The interpolation is supposed to take place in the 0-1-3-2 'base square'.
  This looks crazy but the idea is that 0-3 are always needed, and the rest is
  provided bottom-left to top-right.
  
  In some cases, you don't have or don't want to provide data outside the base
  square.  If you want to be 100% sure that any applier is able to use the data,
  make sure that the size is at least 5, that 0-3 are filled (possibly with
  undefineds) and set the v[4] to -mUdf(T) (that is a minus there).
  
  The 'apply' method needs the relative distance in x and y direction from
  the origin (where v[0] is located), and should therefore generally be between
  0 and 1, although you can also use the classes for near extrapolation.
*/
    
template <class T>
mClass(Algo) Applier2D
{
public:
    virtual		~Applier2D()				{}
    virtual void	set(const T*)				= 0;
    virtual T		apply(float x,float y) const		= 0;
};


/*!
\brief Linear 2D interpolation.
*/

template <class T>
mClass(Algo) LinearReg2D : public Applier2D<T>
{
public:

    inline		LinearReg2D();
    inline		LinearReg2D(const T*);
    inline		LinearReg2D(T v00,T v10,T v01,T v11);

    inline void		set(const T*);
    inline void		set(T v00,T v01,T v10,T v11);
    inline T		apply(float x,float y) const;

protected:

    T			a_[4];
};


template <class T>
inline T linearReg2D( T v00, T v01, T v10, T v11, float x, float y )
{ return LinearReg2D<T>( v00, v01, v10, v11 ).apply ( x, y ); }


/*!
\brief Linear 2D interpolation with standard undef handling.
*/

template <class T>
mClass(Algo) LinearReg2DWithUdf : public Applier2D<T>
{
public:

    inline		LinearReg2DWithUdf();
    inline		LinearReg2DWithUdf(const T*);
    inline		LinearReg2DWithUdf(T v00,T v10,T v01,T v11);

    inline void		set(const T*);
    inline void		set(T v00,T v01,T v10,T v11);
    inline T		apply(float x,float y) const;

protected:

    LinearReg2D<T>	intp_;
    bool		haveudf_;
    bool		u00_;
    bool		u10_;
    bool		u01_;
    bool		u11_;
};


template <class T>
inline T linearReg2DWithUdf( T v00, T v01, T v10, T v11, float x, float y )
{
    return LinearReg2DWithUdf<T>( v00, v01, v10, v11 ).apply( x, y );
}


/*!
\brief Interpolate 2D regularly sampled, using a 2nd order surface.
  
  Contrary to teh linear approach it does matter whether deltaX is different
  from deltaY. That is why you can supply an xstretch. If xstretch > 1 then
  the deltaX < deltaY, moreover: xstretch = deltaY / deltaX;
*/

template <class T>
mClass(Algo) PolyReg2D : public Applier2D<T>
{
public:

    inline		PolyReg2D(float xstretch=1);
    inline		PolyReg2D(const T*,float xstretch=1);
    inline 		PolyReg2D(T vm10,T vm11,
			   T v0m1,T v00, T v01,T v02,
			   T v1m1,T v10, T v11,T v12,
				  T v20, T v21,		float xstretch=1);

    inline void		set(const T*);
    inline void		set(	T vm10,T vm11,
			 T v0m1,T v00, T v01, T v02,
			 T v1m1,T v10, T v11, T v12,
				T v20, T v21);

    inline T		apply(float x,float y) const;

protected:

    PolyReg1D<T>	ix0_, ix1_, iy0_, iy1_;
    T			vm10_, v0m1_, v20_, v02_;
    T			delxm1_, delym1_, delx2_, dely2_;
    float		xs_;

};


template <class T>
inline T polyReg2D( T vm10, T vm11, T v0m1, T v00, T v01, T v02,
	   T v1m1, T v10, T v11, T v12, T v20, T v21, float x, float y,
	   float xs=1 )
{
    return PolyReg2D<T>(vm10,vm11,v0m1,v00,v01,v02,v1m1,v10,v11,v12,v20,v21,xs)
	  .apply( x, y );
}


/*!
\brief PolyReg2D which smoothly handles undefined values.

  Note that this class _requires_ x and y to be between 0 and 1 for correct
  undef handling. Correct means: if the nearest sample is undefined, return
  undefined. Otherwise always return a value.
*/

template <class T>
mClass(Algo) PolyReg2DWithUdf : public Applier2D<T>
{
public:

    inline		PolyReg2DWithUdf(float xstretch=1);
    inline		PolyReg2DWithUdf(const T*,float xstretch=1);
    inline		PolyReg2DWithUdf(T vm10,T vm11,T v0m1,T v00,T v01,T v02,
				         T v1m1,T v10,T v11,T v12,T v20,T v21,
					 float xstretch=1);

    inline void		set(const T*);
    inline void		set(	T vm10,T vm11,
			 T v0m1,T v00, T v01, T v02,
			 T v1m1,T v10, T v11, T v12,
				T v20, T v21);

    inline T		apply(float x,float y) const;

protected:

    inline void		fillOuter2Inner(T,T,T,T,T,T,T,T,T&,T&,T&,T&);
    inline void		fillInner2Inner(T&,T&,T&,T&);
    inline void		fillInner2Outer(T,T,T,T,T&,T&,T&,T&,T&,T&,T&,T&);

    PolyReg2D<T>	intp_;
    bool		haveudf_;
    bool		u00_;
    bool		u10_;
    bool		u01_;
    bool		u11_;
    bool		um10_;
    bool		um11_;
    bool		u0m1_;
    bool		u02_;
    bool		u1m1_;
    bool		u12_;
    bool		u20_;
    bool		u21_;

};


template <class T>
inline T polyReg2DWithUdf( T vm10, T vm11, T v0m1, T v00, T v01, T v02,
	   T v1m1, T v10, T v11, T v12, T v20, T v21, float x, float y )
{
    return PolyReg2DWithUdf<T>(vm10,vm11,v0m1,v00,v01,v02,v1m1,v10,v11,v12,v20,
	    			v21).apply( x, y );
}

//--- LinearReg2D Implementation

template <class T> inline
LinearReg2D<T>::LinearReg2D() {}


template <class T> inline
LinearReg2D<T>::LinearReg2D( const T* v )
{
    set( v[0], v[1], v[2], v[3] );
}


template <class T> inline
LinearReg2D<T>::LinearReg2D( T v00, T v01, T v10, T v11 )
{
    set( v00, v01, v10, v11 );
}


template <class T> inline
void LinearReg2D<T>::set( const T* v )
{
    set( v[0], v[1], v[2], v[3] );
}


template <class T> inline
void LinearReg2D<T>::set( T v00, T v01, T v10, T v11 )
{
    a_[0] = v00;
    a_[1] = v10 - v00;
    a_[2] = v01 - v00;
    a_[3] = v11 + v00 - v10 - v01;
}


template <class T> inline
T LinearReg2D<T>::apply( float x, float y ) const
{
    return a_[0] + a_[1] * x + a_[2] * y + a_[3] * x * y;
}


//---  LinearReg2DWithUdf Implementation

template <class T> inline
LinearReg2DWithUdf<T>::LinearReg2DWithUdf() {}


template <class T> inline
LinearReg2DWithUdf<T>::LinearReg2DWithUdf( const T* v )
{
    set( v[0], v[1], v[2], v[3] );
}


template <class T> inline
LinearReg2DWithUdf<T>::LinearReg2DWithUdf( T v00, T v01, T v10, T v11 )
{
    set( v00, v01, v10, v11 );
}


template <class T> inline
void LinearReg2DWithUdf<T>::set( const T* v )
{
    set( v[0], v[1], v[2], v[3] );
}


#define mFillIfUdfFromSquare(nd,left,right,opp) \
    if ( u##nd##_ ) \
    { \
	if ( u##left##_ && u##right##_ ) \
	    v##nd = v##opp; \
	else \
	    v##nd = u##left##_ || u##right##_ ? \
		   (u##right##_ ? v##left : v##right) \
				: (v##left + v##right) / 2; \
    }

template <class T> inline
void LinearReg2DWithUdf<T>::set( T v00, T v01, T v10, T v11 )
{
    u00_ = mIsUdf(v00);
    u10_ = mIsUdf(v10);
    u01_ = mIsUdf(v01);
    u11_ = mIsUdf(v11);
    haveudf_ = u00_ || u10_ || u01_ || u11_;

    if ( haveudf_ )
    {
	mFillIfUdfFromSquare(00,01,10,11)
	mFillIfUdfFromSquare(10,00,11,01)
	mFillIfUdfFromSquare(01,11,00,10)
	mFillIfUdfFromSquare(11,10,01,00)
    }

    intp_.set( v00, v01, v10, v11 );
}


#define mRetUdfIfNearestUdf() \
    if ( haveudf_ && ( \
	 ( u00_ && x < 0.5 && y < 0.5 ) \
      || ( u10_ && x >= 0.5 && y < 0.5 ) \
      || ( u01_ && x < 0.5 && y >= 0.5 ) \
      || ( u11_ && x >= 0.5 && y >= 0.5 ) ) ) \
	return mUdf(T)



template <class T> inline
T LinearReg2DWithUdf<T>::apply( float x, float y ) const
{
    mRetUdfIfNearestUdf();

    return intp_.apply( x, y );
}


//--- PolyReg2D Implementation


template <class T> inline
PolyReg2D<T>::PolyReg2D( float xs )
    : xs_(xs)
{}


template <class T> inline
PolyReg2D<T>::PolyReg2D( const T* v, float xs )
    : xs_(xs)
{
    set( v );
}


template <class T> inline
PolyReg2D<T>::PolyReg2D( T vm10, T vm11,
	         T v0m1, T v00,  T v01, T v02,
	         T v1m1, T v10,  T v11, T v12,
		         T v20,  T v21, float xs )
    : xs_(xs)
{
    set( vm10, vm11, v0m1, v00, v01, v02, v1m1, v10, v11, v12, v20, v21 );
}


template <class T> inline
void PolyReg2D<T>::set( const T* v )
{
    if ( !mIsUdf(-v[4]) )
	set( v[4], v[5], v[6], v[0], v[1], v[7], v[8], v[2], v[3],
	     v[9], v[10], v[11] );
    else
	set( v[0], v[1], v[0], v[0], v[1], v[1], v[2], v[2], v[3],
	     v[3], v[2], v[3] );
}


template <class T> inline
void PolyReg2D<T>::set(  T vm10, T vm11,
		 T v0m1, T v00,  T v01, T v02,
		 T v1m1, T v10,  T v11, T v12,
			 T v20,  T v21 )
{
    vm10_ = vm10; v0m1_ = v0m1; v20_ = v20; v02_ = v02;
    delxm1_ = vm11 - vm10; delym1_ = v1m1 - v0m1;
    delx2_ = v21 - v20; dely2_ = v12 - v02;
    ix0_.set( v0m1, v00, v01, v02 ); ix1_.set( v1m1, v10, v11, v12 );
    iy0_.set( vm10, v00, v10, v20 ); iy1_.set( vm11, v01, v11, v21 );
}


template <class T> inline
T PolyReg2D<T>::apply( float x, float y ) const
{
    // Exactly on border or outside: handle now
    if ( x <= 0 ) return ix0_.apply( y );
    else if ( y <= 0 ) return iy0_.apply( x );
    else if ( x >= 1 ) return ix1_.apply( y );
    else if ( y >= 1 ) return iy1_.apply( x );

    // Values on X-line through point
    const T vxm1 = vm10_ + delxm1_ * y;
    const T vx0 = ix0_.apply( y );
    const T vx1 = ix1_.apply( y );
    const T vx2 = v20_ + delx2_ * y;

    // Values on Y-line through point
    const T vym1 = v0m1_ + delym1_ * x;
    const T vy0 = iy0_.apply( x );
    const T vy1 = iy1_.apply( x );
    const T vy2 = v02_ + dely2_ * x;

    // Result is weighted average, weight dep on distance from border
    const T estx = polyReg1D( vxm1, vx0, vx1, vx2, x );
    const T esty = polyReg1D( vym1, vy0, vy1, vy2, y );
    const float distfromedgex = x > 0.5 ? 1 - x : x;
    const float distfromedgey = y > 0.5 ? 1 - y : y;
    // wtx == distfromedgey;
    const float wty = distfromedgex * xs_;
    return (distfromedgey * estx + wty * esty) / (distfromedgey + wty);
}



//--- PolyReg2DWithUdf Implementation

template <class T> inline
PolyReg2DWithUdf<T>::PolyReg2DWithUdf( float xs )
    : intp_(xs)
{
}


template <class T> inline
PolyReg2DWithUdf<T>::PolyReg2DWithUdf( const T* v, float xs )
    : intp_(xs)
{
    set( v );
}


template <class T> inline
PolyReg2DWithUdf<T>::PolyReg2DWithUdf( T vm10,T vm11,T v0m1,T v00,T v01, T v02,
				       T v1m1,T v10, T v11, T v12, T v20,T v21,
				       float xs )
    : intp_(xs)
{
    set( vm10, vm11, v0m1, v00, v01, v02, v1m1, v10, v11, v12, v20, v21 );
}


template <class T> inline
void PolyReg2DWithUdf<T>::set( const T* v )
{
    if ( !mIsUdf(-v[4]) )
	set( v[4], v[5], v[6], v[0], v[1], v[7], v[8], v[2], v[3],
	     v[9], v[10], v[11] );
    else
	set( v[0], v[1], v[0], v[0], v[1], v[1], v[2], v[2], v[3],
	     v[3], v[2], v[3] );
}


template <class T> inline
void PolyReg2DWithUdf<T>::fillOuter2Inner( T vm10, T vm11, T v0m1, T v02,
					   T v1m1, T v12, T v20, T v21,
					   T& v00, T& v01, T& v10, T& v11 )
{
#define mFillWithEither(nd,cand1,cand2) \
    if ( u##nd##_ ) \
    { \
	if ( !u##cand1##_ ) v##nd = v##cand1; \
	else if ( !u##cand2##_ ) v##nd = v##cand2; \
    }

    mFillWithEither(00,m10,0m1)
    mFillWithEither(10,1m1,20)
    mFillWithEither(11,21,12)
    mFillWithEither(01,02,m11)

#undef mFillWithEither
}


template <class T> inline
void PolyReg2DWithUdf<T>::fillInner2Inner( T& v00, T& v01, T& v10, T& v11 )
{
    bool kpu00 = u00_, kpu10 = u10_, kpu01 = u01_, kpu11 = u11_;
    u00_ = mIsUdf(v00); u10_ = mIsUdf(v10);
    u01_ = mIsUdf(v01); u11_ = mIsUdf(v11);
    if ( u00_ || u10_ || u01_ || u11_ )
    {
	mFillIfUdfFromSquare(00,01,10,11)
	mFillIfUdfFromSquare(10,00,11,01)
	mFillIfUdfFromSquare(01,11,00,10)
	mFillIfUdfFromSquare(11,10,01,00)
    }
    u00_ = kpu00; u10_ = kpu10; u01_ = kpu01; u11_ = kpu11;
}


template <class T> inline
void PolyReg2DWithUdf<T>::fillInner2Outer( T v00, T v01, T v10, T v11,
					   T& vm10, T& vm11, T& v0m1, T& v02,
					   T& v1m1, T& v12, T& v20, T& v21 )
{
#define mFillIfUdf(nd,src) if ( mIsUdf(v##nd) ) v##nd= v##src;
    mFillIfUdf(m10,00);
    mFillIfUdf(0m1,00);
    mFillIfUdf(1m1,10);
    mFillIfUdf(20,10);
    mFillIfUdf(m11,01);
    mFillIfUdf(02,01);
    mFillIfUdf(12,11);
    mFillIfUdf(21,11);
#   undef mFillIfUdf
}


template <class T> inline
void PolyReg2DWithUdf<T>::set( T vm10, T vm11,
		       T v0m1, T v00,  T v01, T v02,
		       T v1m1, T v10,  T v11, T v12,
			       T v20,  T v21 )
{
    u00_ = mIsUdf(v00);
    u10_ = mIsUdf(v10);
    u01_ = mIsUdf(v01);
    u11_ = mIsUdf(v11);
    um10_ = mIsUdf(vm10);
    um11_ = mIsUdf(vm11);
    u0m1_ = mIsUdf(v0m1);
    u1m1_ = mIsUdf(v1m1);
    u02_ = mIsUdf(v02);
    u12_ = mIsUdf(v12);
    u20_ = mIsUdf(v20);
    u21_ = mIsUdf(v21);
    haveudf_ = u00_ || u10_ || u01_ || u11_;

    if ( haveudf_ || u02_ || u12_ || u20_ || u21_
	          || um10_ || um11_ || u0m1_ || u1m1_ )
    {
	if ( haveudf_ )
	{
	    fillOuter2Inner( vm10, vm11, v0m1, v02, v1m1, v12, v20, v21,
			     v00, v01, v10, v11 );
	    fillInner2Inner( v00, v01, v10, v11 );
	}
	fillInner2Outer( v00, v01, v10, v11,
			 vm10, vm11, v0m1, v02, v1m1, v12, v20, v21 );
    }

    intp_.set( vm10, vm11, v0m1, v00, v01, v02, v1m1, v10, v11, v12, v20, v21 );
}

template <class T> inline
T PolyReg2DWithUdf<T>::apply( float x, float y ) const
{
    mRetUdfIfNearestUdf();

    return intp_.apply( x, y );
}


#undef mFillIfUdfFromSquare
#undef mRetUdfIfNearestUdf


}// namespace Interpolate

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef interpol3d_h
#define interpol3d_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Mar 2006
 RCS:		$Id: interpol3d.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "undefval.h"


namespace Interpolate
{

/*!
\brief Linear 3D interpolation.
*/

template <class T>
mClass(Algo) LinearReg3D
{
public:

LinearReg3D()	{}

LinearReg3D( const T* const* const* v )
{
    set( v[0][0][0], v[1][0][0], v[0][1][0], v[1][1][0],
	 v[0][0][1], v[1][0][1], v[0][1][1], v[1][1][1] );
}

LinearReg3D( T v000, T v100, T v010, T v110, T v001, T v101, T v011, T v111 )
{
    set( v000, v100, v010, v110, v001, v101, v011, v111 );
}

inline void set( T v000, T v100, T v010, T v110, T v001, T v101, T v011, T v111)
{
    a_[0] = v000;
    a_[1] = v100 - v000;
    a_[2] = v010 - v000;
    a_[3] = v001 - v000;
    a_[4] = v110 + v000 - v100 - v010;
    a_[5] = v101 + v000 - v100 - v001;
    a_[6] = v011 + v000 - v010 - v001;
    a_[7] = v111 + v100 + v010 + v001 - (v000 + v110 + v101 + v011);
}

inline T apply( float x, float y, float z ) const
{
    return a_[0] + a_[1] * x + a_[2] * y + a_[3] * z
		 + a_[4] * x * y + a_[5] * x * z + a_[6] * y * z
		 + a_[7] * x * y * z;
}

    T	a_[8];

};


template <class T>
inline T linearReg3D( T v000, T v100, T v010, T v110,
		      T v001, T v101, T v011, T v111,
		      float x, float y, float z )
{
    return LinearReg3D<T>( v000, v100, v010, v110, v001, v101, v011, v111 )
		.apply( x, y, z );
}


/*!
\brief Linear 3D interpolation with standard undef handling.
*/

template <class T>
mClass(Algo) LinearReg3DWithUdf
{
public:

LinearReg3DWithUdf()	{}

LinearReg3DWithUdf( const T* const* const* v )
{
    set( v[0][0][0], v[1][0][0], v[0][1][0], v[1][1][0],
	 v[0][0][1], v[1][0][1], v[0][1][1], v[1][1][1] );
}

LinearReg3DWithUdf( T v000, T v100, T v010, T v110,
		    T v001, T v101, T v011, T v111 )
{
    set( v000, v100, v010, v110, v001, v101, v011, v111 );
}

inline static T getReplVal( T v1, T v2, T v3, bool u1, bool u2, bool u3 )
{

    if ( u1 )
	return u2 ? v3 : (u3 ? v2 : (v2 + v3) / 2);
    else if ( u2 )
	return u3 ? v1 : (v1 + v3) / 2;
    else if ( u3 )
	return (v1 + v2) / 2;

    return (v1 + v2 + v3) / 3;
}

inline void set( T v000, T v100, T v010, T v110, T v001, T v101, T v011, T v111)
{
    u000_ = mIsUdf(v000);
    u100_ = mIsUdf(v100);
    u010_ = mIsUdf(v010);
    u110_ = mIsUdf(v110);
    u001_ = mIsUdf(v001);
    u101_ = mIsUdf(v101);
    u011_ = mIsUdf(v011);
    u111_ = mIsUdf(v111);
    haveudf_ = u000_ || u100_ || u010_ || u110_
	    || u001_ || u101_ || u011_ || u111_;

    if ( haveudf_ )
    {
#	define mFillIfUdf(nd,nearx,neary,nearz,diagxy,diagxz,diagyz,opp) \
	if ( u##nd##_ ) \
	{ \
	    if ( !u##nearx##_ || !u##neary##_ || !u##nearz##_ ) \
		v##nd = getReplVal( v##nearx, v##neary, v##nearz, \
				    u##nearx##_, u##neary##_, u##nearz##_ ); \
	    else \
	    { \
		if ( u##diagxy##_ && u##diagxz##_ && u##diagyz##_ ) \
		    v##nd = v##opp; \
		else \
		    v##nd = getReplVal( v##diagxy, v##diagxz, v##diagyz, \
				u##diagxy##_, u##diagxz##_, u##diagyz##_ ); \
	    } \
	}

	mFillIfUdf(000,100,010,001,110,101,011,111)
	mFillIfUdf(100,000,110,101,010,001,111,011)
	mFillIfUdf(010,110,000,011,100,111,001,101)
	mFillIfUdf(110,010,100,111,000,011,101,001)
	mFillIfUdf(001,101,011,000,111,100,010,110)
	mFillIfUdf(101,001,111,100,011,000,110,010)
	mFillIfUdf(011,111,001,010,101,110,000,100)
	mFillIfUdf(111,011,101,110,001,010,100,000)

#	undef mFillIfUdf
    }

    intp_.set( v000, v100, v010, v110, v001, v101, v011, v111 );
}

inline T apply( float x, float y, float z ) const
{
    // return undef if the nearest node is undef
    if ( haveudf_ && (
         ( u000_ && x < 0.5 && y < 0.5 && z < 0.5 )
      || ( u100_ && x >= 0.5 && y < 0.5 && z < 0.5 )
      || ( u010_ && x < 0.5 && y >= 0.5 && z < 0.5 )
      || ( u110_ && x >= 0.5 && y >= 0.5 && z < 0.5 )
      || ( u001_ && x < 0.5 && y < 0.5 && z >= 0.5 )
      || ( u101_ && x >= 0.5 && y < 0.5 && z >= 0.5 )
      || ( u011_ && x < 0.5 && y >= 0.5 && z >= 0.5 )
      || ( u111_ && x >= 0.5 && y >= 0.5 && z >= 0.5 ) ) )
	return mUdf(T);

    return intp_.apply( x, y, z );
}

    LinearReg3D<T>	intp_;
    bool		haveudf_;
    bool		u000_;
    bool		u100_;
    bool		u010_;
    bool		u110_;
    bool		u001_;
    bool		u101_;
    bool		u011_;
    bool		u111_;

};

template <class T>
inline T linearReg3DWithUdf( T v000, T v100, T v010, T v110,
			     T v001, T v101, T v011, T v111,
			     float x, float y, float z )
{
    return LinearReg3DWithUdf<T>(v000,v100,v010,v110,v001,v101,v011,v111)
		.apply( x, y, z );
}



/*!
\brief Interpolate 3D regularly sampled, using a 3rd order surface.
  
  Current implementation takes the average of the outer squares.
  In the parameter passing, the z is the fastest dimension.
  <pre>

       ..    ..       Z  Y-dir
  ..  ....  ....  ..  ^ /
  ..  ....  ....  ..  | --> X-dir
       ..    ..

  ^- From here to -^
  x=-1   0      1     2
  
  </pre>
*/

template <class T>
mClass(Algo) PolyReg3D
{
public:

PolyReg3D() {}

PolyReg3D( const T* const* const * v )
{
    set( v[0][1][1], v[0][1][2], v[0][2][1], v[0][2][2],
	 v[1][0][1], v[1][0][2], v[1][1][0], v[1][1][1],
	 v[1][1][2], v[1][1][3], v[1][2][0], v[1][2][1],
	 v[1][2][2], v[1][2][3], v[1][3][1], v[1][3][2],
	 v[2][0][1], v[2][0][2], v[2][1][0], v[2][1][1],
	 v[2][1][2], v[2][1][3], v[2][2][0], v[2][2][1],
	 v[2][2][2], v[2][2][3], v[2][3][1], v[2][3][2],
	 v[3][1][1], v[3][1][2], v[3][2][1], v[3][2][2] );
}

PolyReg3D(
	T vm100, T vm101, T vm110, T vm111,
	T v0m10, T v0m11, T v00m1, T v000,
	T v001,  T v002,  T v01m1, T v010,
	T v011,  T v012,  T v020,  T v021,
	T v1m10, T v1m11, T v10m1, T v100,
	T v101,  T v102,  T v11m1, T v110,
	T v111,  T v112,  T v120,  T v121,
	T v200,  T v201,  T v210,  T v211 )
{
    set( vm100, vm101, vm110, vm111,
	 v0m10, v0m11, v00m1, v000,
	 v001,  v002,  v01m1, v010,
	 v011,  v012,  v020,  v021,
	 v1m10, v1m11, v10m1, v100,
	 v101,  v102,  v11m1, v110,
	 v111,  v112,  v120,  v121,
	 v200,  v201,  v210,  v211 );
}

inline void set(
	T vm100, T vm101, T vm110, T vm111,
	T v0m10, T v0m11, T v00m1, T v000,
	T v001,  T v002,  T v01m1, T v010,
	T v011,  T v012,  T v020,  T v021,
	T v1m10, T v1m11, T v10m1, T v100,
	T v101,  T v102,  T v11m1, T v110,
	T v111,  T v112,  T v120,  T v121,
	T v200,  T v201,  T v210,  T v211 )
{
    set( v000, v100, v010, v110, v001, v101, v011, v111,
	(v00m1 + v01m1 + v10m1 + v11m1) / 4,
	(v0m10 + v0m11 + v1m10 + v1m11) / 4,
	(vm100 + vm101 + vm110 + vm111) / 4,
	(v002 + v012 + v102 + v112) / 4,
	(v020 + v021 + v120 + v121) / 4,
	(v200 + v201 + v210 + v211) / 4 );
}

inline void set( T v000, T v100, T v010, T v110, T v001, T v101, T v011, T v111,
		 T vxym1, T vxzm1, T vyzm1, T vxy1, T vxz1, T vyz1 )
{
    // TODO
}

inline T apply( float x, float y, float z ) const
{
    return a_[0] + a_[1] * x + a_[2] * y + a_[3] * z
		 + a_[4] * x * y + a_[5] * x * z + a_[6] * y * z
		 + a_[7] * x * y * z
		 + a_[8]  * x * x * y + a_[9]  * x * x * z
		 + a_[10] * y * y * x + a_[11] * y * y * z
		 + a_[12] * z * z * x + a_[13] * z * z * y;
}

    T	a_[14];

};


template <class T>
inline T polyReg3D( const T* const* const * v, float x, float y, float z )
{
    return PolyReg3D<T>( v ).apply( x, y, z );
}


/*!<\brief PolyReg3D which smoothly handles undefined values

  Note that this class _requires_ x, y and z to be between 0 and 1 for correct
  undef handling. Correct means: if the nearest sample is undefined, return
  undefined. Otherwise always return a value.

*/


} // namespace Interpolate

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef interpolnd_h
#define interpolnd_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Apr 2010
 RCS:		$Id: interpolnd.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "math2.h"


namespace Interpolate
{

/*!>
 Linear ND interpolation.

Input:
 * Array sz=2^N values as following 4D example
   Arr[0] = val[0][0][0][0]
   Arr[1] = val[1][0][0][0]
   Arr[2] = val[0][1][0][0]
   Arr[3] = val[1][1][0][0]
   Arr[4] = val[0][0][1][0]
   Arr[5] = val[1][0][1][0]
   Arr[6] = val[0][1][1][0]
   Arr[7] = val[1][1][1][0]
   Arr[8] = val[0][0][0][1]
   Arr[9] = val[1][0][0][1]
   Arr[10] = val[0][1][0][1]
   Arr[11] = val[1][1][0][1]
   Arr[12] = val[0][0][1][1]
   Arr[13] = val[1][0][1][1]
   Arr[14] = val[0][1][1][1]
   Arr[15] = val[1][1][1][1]

   Fill the vals with something like:

    od_int64 sz = IntPower( 2, N );
    for ( od_int64 ipt=0; ipt<sz; ipt++ )
    {
    	TypeSet<int> idxs( N, 0 );
	od_int64 bits = ipt;
	for ( int idim=0; idim<nrdims; idim++ )
	{
	    if ( bits & 1 ) idxs[idim]++;
	    bits >>= 1;
	}
	pts += getVals( idxs );
    }

  You therefore provide all the points in the (hyper)cube around the point of
  evaluation. The [0][0]...[0] point can be determined using 'floor', as in:

    for ( int idim=0; idim<nrdims; idim++ )
    {
	const float fidx = samplings[idim].getIndex( vals[idim] );
	const int idx0 = (int)floor(fidx);
	pos[idim] = fidx - idx0; idx0s += idx0;
    }

*/

template <class T>
inline T linearRegND( int N, const T* v, const T* pos )
{
    if ( N == 0 )
	return v[0];
    else if ( N == 1 )
	return v[0] * (1-pos[0]) + v[1] * pos[0];
    else if ( N == 2 )
    {
	T a[4];
	a[0] = v[0];
	a[1] = v[1] - v[0];
	a[2] = v[2] - v[0];
	a[3] = v[3] + v[0] - v[1] - v[2];
	return a[0] + a[1]*pos[0] + a[2]*pos[1] + a[3]*pos[0]*pos[1];
    }
    else
    {
	const int lowerN = N-1;
	const od_int64 nlowerpts = Math::IntPowerOf( ((od_int64)2), lowerN );
	float* lowerv = new float [nlowerpts];
	const float lastpos = pos[lowerN];
	for ( od_int64 idx=0; idx<nlowerpts; idx++ )
	{
	    const float v0 = v[idx];
	    const float v1 = v[idx+nlowerpts];
	    lowerv[idx] = (1-lastpos) * v0 + lastpos * v1;
	}
	const float res = linearRegND( lowerN, lowerv, pos );
	delete [] lowerv;
	return res;
    }
}


} // namespace Interpolate

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef linear_h
#define linear_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Jan 2005
 RCS:		$Id: linear.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/


#include "algomod.h"
#include "mathfunc.h"
namespace Geom { template <class T> class Point2D; }


/*!
\brief Steepness and intercept.
*/

template <class T>
mClass(Algo) LineParameters : public MathFunction<T,T>
{
public:
		LineParameters( T i0=0, T i1=0 )
		: a0(i0), ax(i1)		{}
 
    inline T	getValue( T x ) const
			{ return a0 + ax * x; }
    inline T	getXValue( T y ) const
			{ return ax ? (y - a0) / ax : 0; }
    inline T	getProjectedX( T x, T y ) const
			{ return (x + ax * (y - a0)) / (1 + ax * ax); }
    inline T	getValue( const T* x ) const
			{ return getValue(*x); }
 
    T		a0, ax;
};

typedef LineParameters<float> LinePars;


/*!
\brief Steepnesses and intercept.
*/

template <class T>
mClass(Algo) PlaneParameters : public MathXYFunction<T,T>
{
public:
		PlaneParameters( T i0=0, T i1=0, T i2=0 )
		: a0(i0), ax(i1), ay(i2)	{}

    inline T	getValue( T x, T y ) const
		{ return a0 + ax * x + ay * y; }
    inline T	getValue( const T* x ) const
			{ return getValue(x[0],x[1]); }

    T		a0, ax, ay;

};

typedef PlaneParameters<float> PlanePars;


/*!
\brief linear stats in 2D.
*/

mExpClass(Algo) LinStats2D
{
public:
		LinStats2D() : corrcoeff(0)	{}

    LinePars	lp;		//!< Parameters
    LinePars	sd;		//!< Standard deviations in parameters
    float	corrcoeff;	//!< Correlation coefficient

    void	use(const float*,const float*,int nrpts);
    void	use(const Geom::Point2D<float>*,int nrpts);
};


/*!
\brief linear stats in 3D.
*/

mExpClass(Algo) LinStats3D
{
public:
		LinStats3D() : corrcoeff(0)	{}

    PlanePars	pp;		//!< Parameters
    PlanePars	sd;		//!< Standard deviations in parameters
    float	corrcoeff;	//!< Correlation coefficient

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef mathfunc_H
#define mathfunc_H

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		17-11-1999
 Contents:	Mathematical Functions
 RCS:		$Id: mathfunc.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/


#include "algomod.h"
#include "mathfunc.h"
#include "position.h"
#include "ptrman.h"
#include "samplingdata.h"
#include "varlenarray.h"

#include <math.h>

template <class T> class LineParameters;


/*!
\brief Multidimensional Mathematical function.
  
  A MathFunctionND must deliver a value at any position: F(x*).
  The positioning may need a different precision than the outcome, hence
  the two types.
*/

template <class RT,class PT>
mClass(Algo) MathFunctionND
{
public:
    virtual	~MathFunctionND() {}

    template <class IDXABL>
    RT			getValue( const IDXABL& x ) const
			{
			    const int nrdim = getNrDim();
			    mAllocVarLenArr( PT, pos, nrdim );
			    for ( int idx=0; idx<nrdim; idx++ )
				pos[idx] = x[idx];
			    return getValue( (const PT*) pos );
			}

    virtual RT		getValue(const PT*) const		= 0;
    virtual int		getNrDim() const 			= 0;
};

typedef MathFunctionND<float,float> FloatMathFunctionND;


/*!
\brief Mathematical function
  
  A MathFunction must deliver a value at any position: F(x).
  The positioning may need a different precision than the outcome, hence
  the two types.
*/

template <class RT,class PT>
mClass(Algo) MathFunction : public MathFunctionND<RT,PT>
{
public:

    virtual RT		getValue(const PT* pos) const	{ return getValue(*pos); }
    virtual int		getNrDim() const		{ return 1; }

    virtual RT		getValue( PT p ) const		= 0;

};

typedef MathFunction<float,float> FloatMathFunction;


/*!
\brief Makes a MathFunction indexable through an operator[].
*/

template <class RT,class PT>
mClass(Algo) MathFunctionSampler
{
public:
			MathFunctionSampler( const MathFunction<RT,PT>& f )
			    : func( f )
			{}
    RT			operator[](int idx) const
			{ return func.getValue( sd.atIndex(idx) ); }

    SamplingData<PT>	sd;

protected:

    const MathFunction<RT,PT>&	func;

};


/*!
\brief A Math Function as in F(x,y).
*/

template <class RT,class PT>
mClass(Algo) MathXYFunction : public MathFunctionND<RT,PT>
{
public:

    virtual RT	getValue(PT,PT) const		= 0;

    RT		getValue( const PT* pos ) const
    		        { return getValue(pos[0],pos[1]);}
    int		getNrDim() const { return 2; }

};


/*!
\brief A Math Function as in F(x,y,z).
*/
template <class RT,class PT>
mClass(Algo) MathXYZFunction : public MathFunctionND<RT,PT>
{
public:

    virtual RT	getValue(PT,PT,PT) const	= 0;

    RT		getValue( const PT* pos ) const
    		        { return getValue(pos[0],pos[1],pos[2]);}
    int		getNrDim() const { return 3; }

};



/*!
\brief MathFunction based on bend points
  
  The object maintains sorted positions (in X), so you cannot bluntly stuff
  X and Y in. You cannot change or remove positions; instead make a copy.
  
  If the given point is outside the 'defined' X-range, the value can be undef
  or the first/last defined point's value, depending on the 'extrapol_'
  setting. If no point at all is defined you will always get undef.

  You can add undefined Y-values, but not undef X-values (those add()'s simply
  return). Undef sections are therefore supported.
*/

mExpClass(Algo) PointBasedMathFunction : public FloatMathFunction
{
public:

    enum InterpolType	{ Linear, Poly, Snap };
    enum ExtrapolType   { None, EndVal, ExtraPolGradient };

    			PointBasedMathFunction( InterpolType t=Linear,
			       			ExtrapolType extr=EndVal )
			    : itype_(t)
			    , extrapol_(extr)	{}

    void		setEmpty()		{ x_.setSize(0); y_.setSize(0);}
    int			size() const		{ return x_.size(); }
    bool		isEmpty() const		{ return x_.isEmpty(); }
    void		add(float x,float y);
    void		remove(int idx);
    float		getValue( float x ) const
			{ return itype_ == Snap ? snapVal(x) : interpVal(x); }
    float		getValue( const float* p ) const { return getValue(*p); }

    const TypeSet<float>& xVals() const		{ return x_; }
    const TypeSet<float>& yVals() const		{ return y_; }

    InterpolType	interpolType() const	{ return itype_; }
    bool		extrapolate() const	{ return extrapol_; }
    void		setInterpolType( InterpolType t ) { itype_ = t; }
    void		setExtrapolate( ExtrapolType yn ) { extrapol_ = yn; }

protected:

    InterpolType	itype_;
    ExtrapolType	extrapol_;
    TypeSet<float>	x_;
    TypeSet<float>	y_;

    int			baseIdx(float) const;
    float		snapVal(float) const;
    float		interpVal(float) const;
    float		outsideVal(float) const;
};


/*!
\brief A MathFunction that cuts through another mathfunction with
higher number of dimensions.
  
  A starting point (P) and a vector (N) is used to project a line through
  a MathFunctionND (func). The value returned is:
  
  f(x) = func(P+N*x)
*/

template <class RT,class PT>
mClass(Algo) AlongVectorFunction : public MathFunction<RT,PT>
{
public:
    			AlongVectorFunction( const MathFunctionND<RT,PT>& func_,
					     const PT* P_, const PT* N_)
			    : P( P_ )
			    , N( N_ )
			    , func( func_ )
			{}

    RT			getValue( PT lambda ) const
			{
			    const int nrdim = func.getNrDim();
			    mAllocVarLenArr( PT, pos, nrdim );
			    for ( int idx=0; idx<nrdim; idx++ )
				pos[idx] = P[idx] + N[idx]*lambda;

			    return func.getValue( pos );
			}
    RT			getValue( const PT* p ) const
			{ return getValue( *p ); }

protected:

    const PT*				P;
    const PT*				N;
    const MathFunctionND<RT,PT>&	func;
};


/*!
\brief A class for 2nd order polynomials of the form: a x^2 + b x + c
*/

mExpClass(Algo) SecondOrderPoly : public FloatMathFunction
{
public:
    			SecondOrderPoly( float a_=0, float b_=0, float c_=0 )
			    : a( a_ ), b( b_ ), c( c_ )
			{}

			/*!Fits the polynomial through the points. The points
			   are considered to be sampled with y0 at x=-1 and
			   y2 at x=1
		        */
    void		setFromSamples(float y0,float y1,float y2)
			{
			    c = y1;
			    a = ( (y0+y2) / 2 ) - y1;
			    b = ( y2-y0 ) / 2;
			}

    float		getValue( float pos ) const
			{
			    if ( Values::isUdf(pos) ) return mUdf(float);
			    return pos*pos * a + pos * b + c;
			}
    float		getValue( const float* p ) const { return getValue(*p); }

    float		getExtremePos() const
			{
			    if ( mIsZero(a,mDefEps) ) return mUdf(float);
			    return -b / (2*a);
			}

    int			getRoots( float& pos0, float& pos1 ) const
			{
			    pos0 = pos1 = mUdf(float);

			    if ( mIsZero(a,mDefEps) )
			    {
				if ( mIsZero(b,mDefEps) )
				    return 0;

				pos0 = -c/b;
				return 1;
			    }

			    const double halfp = b/a/2;
			    const double q = c/a;

			    const double squareterm = halfp*halfp-q;
			    if ( squareterm<0 )
				return 0;

			    const double sq = Math::Sqrt(squareterm);


			    pos0 = (float)(-halfp+sq);
			    pos1 = (float)(-halfp-sq);
			    return 2;
			}

    LineParameters<float>* createDerivative() const;

    float		a, b, c;
};


/*!
\brief A class for 3rd order polynomials on the form: a x^3 + b x^2 + c x + d
*/

mExpClass(Algo) ThirdOrderPoly : public FloatMathFunction
{
public:
    			ThirdOrderPoly( float a_=0, float b_=0,
					float c_=0, float d_=0 )
			    : a( a_ ), b( b_ ), c( c_ ), d( d_ )
			{}

			/*!Fits the polynomial through the points. The points
			   are considered to be sampled with y0 at x=-1 and
			   y3 at x=2
		        */
    void		setFromSamples(float y0,float y1,float y2,float y3)
			{
			    b = ( (y2+y0) / 2 ) - y1;
			    c = y2 - ( ( 2*y0 + 3*y1 + y3 ) / 6 );
			    a = ( (y2-y0) / 2 ) - c;
			    d = y1;
			}

    float		getValue( float pos ) const
			{
			    if ( Values::isUdf(pos) ) return mUdf(float);
			    const float possq = pos * pos;
			    return possq * pos * a + possq * b + pos * c + d;
			}
    float		getValue( const float* p ) const { return getValue(*p); }

    SecondOrderPoly*	createDerivative() const
			{ return new SecondOrderPoly( a*3, b*2, c ); }

    int			getExtremePos( float& pos0, float& pos1 ) const
			{
			    pos0 = pos1 = mUdf(float);
			    if ( mIsZero(a,mDefEps) && mIsZero(b,mDefEps) )
				return 0;
			    else if ( mIsZero(a,mDefEps) )
			    {
				pos0 = -c / ( 2*b );
				return 1;
			    }

			    SecondOrderPoly derivate( a*3, b*2, c );
			    return derivate.getRoots(pos0, pos1);
			}

    float		a, b, c, d;
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef pca_h
#define pca_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Kristofer Tingdahl
 Date:		4-11-2002
 RCS:		$Id: pca.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#include "algomod.h"
#include "arrayndimpl.h"
#include "sets.h"
#include "trigonometry.h"
#include "threadwork.h"

template <class T> class Array2D;
class SequentialTask;
class PCACovarianceCalculator;

/*!
\brief Performs Pricipal Component Analysis on samples with N variables.
  
  Example of usage:
  \code
  //The samples will have three variables
  PCA pca( 3 );		
  
  //Samples can be added by any object that has a readable [] operator
  const float sample0[] = { 0, 1, 2 };
  pca.addSample( sample0 );
  
  const float sample1[] = { 4.343, 9.8, 2.72 };
  pca.addSample( sample1 );
  
  const float sample2[] = { 23.15, 210, -15 };
  pca.addSample( sample2 );
  
  const float sample3[] = { -0.36, 0.68, 3 };
  pca.addSample( sample3 );
  
  const float sample4[] = { 4.4, 9,6, 11 };
  pca.addSample( sample4 );
  
  TypeSet<float> sample5; sample5 += 34.1; sample5 += 8.37; sample5 += -44;
  pca.addSample( sample5 ); 
  
  pca.calculate();
  
  
  //Any object that has a writable [] operator can be used to fetch
  //the resulting vectors:
  TypeSet<float> eigenvec0(3,0);
  float eigenval0 = pca.getEigenValue(0);
  pca.getEigenVector( 0, eigenvec0 );
  
  float[3] eigenvec1;
  float eigenval1 = pca.getEigenValue(1);
  pca.getEigenVector( 1, eigenvec1 );
  
  float[3] eigenvec2;
  float eigenval2 = pca.getEigenValue(2);
  pca.getEigenVector( 2, eigenvec2 );
  \endcode
*/

mExpClass(Algo) PCA
{
public:
    					PCA( int nrvars );
					/*!<\param nrvars The number of
						  variables that the samples
						  have. */
    virtual				~PCA();

    void				clearAllSamples();
    					/*!< Removes all samples so a new
					     analysis can be made (by adding
					     new samples) */
    template <class IDXABL> void	addSample( const IDXABL& sample );
    					/*!<Adds a sample to the analysis.
					    \param sample The sample that should
					    		  be added. The sample
							  can be of any type
							  that have []
							  operators.  */
    bool				calculate();
    					/*!< Computes the pca for all
					     added samples. */
    float				getEigenValue(int idx) const;
    					/*!<\return an eigenvalue.
					  \param idx Determines which 
					  	eigenvalue to return. The
						eigenvalues are sorted in
						descending order, so idx==0
						gives the largest eigenvalue. */
    template <class IDXABL> void	getEigenVector(int idx,
	    					       IDXABL& vec) const;
    					/*!<Returns the eigenvector
					    corresponding to the eigenvalue
					    \a idx.
					    \param idx Determines which
					    	eigenvector to return. The
						eigenvectors are sorted in
						order of descending eigenvalue,
						so idx==0 gives the eigenvector
						corresponding to the largest
						eigenvalue.
					    \param vec The object where the to
					     	       store the eigenvector.
						       Any object that has a
						       writable [] operator can
						       be used, for example
						       float* and TypeSet<T>.
					*/
protected:
    bool			tqli( float[], float[], int, ObjectSet<float>&);
    void			tred2( ObjectSet<float>&, int, float[],float[]);

    const int			nrvars_;
    Array2DImpl<float>		covariancematrix_;
    ObjectSet<TypeSet<float> >	samples_;
    TypeSet<float>		samplesums_;
    TypeSet<Threads::Work>	workload_;
    ObjectSet<SequentialTask>	tasks_;
    float*			eigenvalues_;
    				/*!<The negation of the eigenval,
    				    to get the sorting right.
				*/
    int*			eigenvecindexes_;
};


template <class IDXABL> inline
void PCA::addSample( const IDXABL& sample )
{
    TypeSet<float>& ownsample = *new TypeSet<float>;
    for ( int idx=0; idx<nrvars_; idx++ )
    {
	const float val = (float) sample[idx];
	ownsample += val;
	samplesums_[idx] += val;
    }

    samples_ += &ownsample;
}

template <class IDXABL> inline
void PCA::getEigenVector(int idy, IDXABL& vec ) const
{
    for ( int idx=0; idx<nrvars_; idx++ )
	vec[idx] = covariancematrix_.get(idx, eigenvecindexes_[idy] );
}

#endif



/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef periodicvalue_h
#define periodicvalue_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Kris Tingdahl
 Date:		12-4-1999
 Contents:	Periodic value interpolation and so forth
 RCS:		$Id: periodicvalue.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "simpnumer.h"
#include "idxable.h"


/*!>
 dePeriodize returns a periodic (defined by y(x) = y(x) + N * P) value's value
 in the functions first period (between 0 and P).
*/

template <class T>
inline T dePeriodize( T val, T period )
{
    int n = (int) (val / period);
    if ( val < 0 ) n--;

    return n ? val - n * period : val; 
}


/*!
\brief PeriodicValue handles periodic data through mathematical operations.
*/

template <class T,int P>
mClass(Algo) PeriodicValue
{
public:
    T				val(bool positive=true) const
				{
				    T res = dePeriodize(val_,(T)P);
				    if ( !positive && res > ((T)P)/2 )
					return res-P;
				    return res;
				}
				/*!< Returns the value between 0 and P if
				     positive is true, or between -P/2 and P/2
				     if positive is false;
				*/

    PeriodicValue<T,P>		operator+(T nv) const
				{ return PeriodicValue<T,P>(val_+nv); }
    PeriodicValue<T,P>		operator-(T nv) const
				{ return PeriodicValue<T,P>(val_-nv); }
    PeriodicValue<T,P>		operator*(T nv) const
				{ return PeriodicValue<T,P>(val_*nv); }
    PeriodicValue<T,P>		operator/(T nv) const
				{ return PeriodicValue<T,P>(val_/nv); }
    PeriodicValue<T,P>		operator+(const PeriodicValue<T,P>& nv) const
				{ return PeriodicValue<T,P>(val_+nv.val()); }
    PeriodicValue<T,P>		operator-(const PeriodicValue<T,P>& nv) const
				{ return PeriodicValue<T,P>(val_-nv.val()); }
    PeriodicValue<T,P>		operator*(const PeriodicValue<T,P>& nv) const
				{ return PeriodicValue<T,P>(val_*nv.val()); }
    PeriodicValue<T,P>		operator/(const PeriodicValue<T,P>& nv) const
				{ return PeriodicValue<T,P>(val_/nv.val()); }

    const PeriodicValue<T,P>&	operator=(T nv) const
				{ val_ = nv; return this; }
    const PeriodicValue<T,P>&	operator+=(T nv)
				{ val_ += nv; return this; }
    const PeriodicValue<T,P>&	operator-=(T nv)
				{ val_ -= nv; return this; }
    const PeriodicValue<T,P>&	operator*=(T nv)
				{ val_ *= nv; return this; }
    const PeriodicValue<T,P>&	operator/=(T nv)
				{ val_ /= nv; return this; }
    const PeriodicValue<T,P>&	operator=(const PeriodicValue<T,P>& nv) const
				{ val_ = nv.val(); return this; }
    const PeriodicValue<T,P>&	operator+=(const PeriodicValue<T,P>& nv)
				{ val_ += nv.val(); return this; }
    const PeriodicValue<T,P>&	operator-=(const PeriodicValue<T,P>& nv)
				{ val_ -= nv.val(); return this; }
    const PeriodicValue<T,P>&	operator*=(const PeriodicValue<T,P>& nv)
				{ val_ *= nv.val(); return this; }
    const PeriodicValue<T,P>&	operator/=(const PeriodicValue<T,P>& nv)
				{ val_ /= nv.val(); return this; }

    bool			operator<(const PeriodicValue<T,P>& b) const
				{
				    PeriodicValue<T,P> tmp = *this-b;
				    if ( tmp.val(true)>P/2 ) return true;
				    return false;
				}
    bool			operator>(const PeriodicValue<T,P>& b) const
				{
				    PeriodicValue<T,P> tmp = *this-b;
				    if ( tmp.val(true)<=P/2 ) return true;
				    return false;
				}
    bool			operator<(T b) const
				{ return *this < PeriodicValue<T,P>(b); }
    bool			operator>(T b) const
				{ return *this > PeriodicValue<T,P>(b); }
				

				PeriodicValue(T nv) : val_( nv ) {}

protected:
    T				val_;
};


namespace IdxAble
{

/*!>
 interpolateYPeriodicReg interpolates in an indexable storage with
 periodic entities ( defined by y(x) = y(x) + N*P )
*/

template <class T, class RT>
inline void interpolateYPeriodicReg( const T& idxabl, int sz, float pos,
				RT& ret, RT period, bool extrapolate=false )
{
    const float halfperiod = period / 2;
    int intpos = mNINT32( pos );
    float dist = pos - intpos;
    if( mIsZero(dist,1e-10) && intpos >= 0 && intpos < sz ) 
	{ ret = idxabl[intpos]; return; }

    int prevpos = dist > 0 ? intpos : intpos - 1;
    if ( !extrapolate && (prevpos > sz-2 || prevpos < 0) )
	ret = mUdf(RT);
    else if ( prevpos < 1 )
    {
	const float val0 = idxabl[0];
	RT val1 = idxabl[1];
	while ( val1 - val0 > halfperiod ) val1 -= period; 
	while ( val1 - val0 < -halfperiod ) val1 += period; 

	ret = dePeriodize( Interpolate::linearReg1D( val0, val1, pos ),
			   period );
    }
    else if ( prevpos > sz-3 )
    {
	const RT val0 = idxabl[sz-2];
	RT val1 = idxabl[sz-1];
	while ( val1 - val0 > halfperiod ) val1 -= period; 
	while ( val1 - val0 < -halfperiod ) val1 += period; 
	ret = dePeriodize( Interpolate::linearReg1D( val0, val1, pos-(sz-2) ),
			  period );
    }
    else
    {
	const RT val0 = idxabl[prevpos-1];

	RT val1 = idxabl[prevpos];
	while ( val1 - val0 > halfperiod ) val1 -= period; 
	while ( val1 - val0 < -halfperiod ) val1 += period; 

	RT val2 = idxabl[prevpos+1];
	while ( val2 - val1 > halfperiod ) val2 -= period; 
	while ( val2 - val1 < -halfperiod ) val2 += period; 

	RT val3 = idxabl[prevpos+2];
	while ( val3 - val2 > halfperiod ) val3 -= period; 
	while ( val3 - val2 < -halfperiod ) val3 += period; 

	ret = dePeriodize(Interpolate::polyReg1D( val0, val1, val2, val3,
						  pos - prevpos ), period );
    }
}


template <class T>
inline float interpolateYPeriodicReg( const T& idxabl, int sz, float pos,
                                 float period, bool extrapolate=false )
{
    float ret = mUdf(float);
    interpolateYPeriodicReg( idxabl, sz, pos, ret, period, extrapolate );
    return ret;
}


/*!>
 interpolateXPeriodicReg interpolates in an periodic indexable ( where
 the position is periodic ), defined by y(x) = x(x+n*P). The period is equal
 to the size of the given idxabl.
*/

template <class T, class RT>
inline void interpolateXPeriodicReg( const T& idxabl, int sz, float pos,
					 RT& ret)
{
    int intpos = mNINT32( pos );
    float dist = pos - intpos;
    if( mIsZero(dist,1e-10) && intpos >= 0 && intpos < sz ) 
	{ ret = idxabl[intpos]; return; }

    int prevpos = dist > 0 ? intpos : intpos - 1;
    const float relpos = pos - prevpos;
    prevpos = dePeriodize( prevpos, sz );

    int prevpos2 = prevpos - 1; 
    prevpos2 = dePeriodize( prevpos2, sz );

    int nextpos = prevpos + 1;
    nextpos = dePeriodize( nextpos, sz );

    int nextpos2 = prevpos + 2;
    nextpos2 = dePeriodize( nextpos2, sz );

    const RT prevval2 = idxabl[prevpos2];
    const RT prevval = idxabl[prevpos];
    const RT nextval = idxabl[nextpos];
    const RT nextval2 = idxabl[nextpos2];

    ret = Interpolate::polyReg1D( prevval2, prevval, nextval, nextval2, relpos);
}

} // namespace IdxAble

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef simpnumer_H
#define simpnumer_H

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert Bril & Kris Tingdahl
 Date:		12-4-1999
 Contents:	'Simple' numerical functions
 RCS:		$Id: simpnumer.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "algomod.h"
#include "undefval.h"
#include "math2.h"
#include <math.h>
#include <limits.h>


/*!>Handles roundoff errors when looking for the previous sample in an array.*/


inline int getPrevSample( float target, int size, float& relpos )
{
    int sampl = (int) target;
    relpos = target-sampl;
    if ( sampl==-1 && mIsEqual(relpos,1,1e-3) )
    { sampl = 0; relpos = 0; }
    else if ( sampl==size-1 && mIsZero(relpos,1e-3) )
    { sampl = size-2; relpos = 1; }

    return sampl;
}


/*!>
 intpow returns the integer power of an arbitary value. Faster than
 pow( double, double ), more general than IntPowerOf(double,int).
*/

template <class T> inline
T intpow( T x, char y)
{
    T res = 1; while ( y ) { res *= x; y--; }
    return res;
}


/*!>
 isPower determines whether a value is a power of a base, i.e. if
val=base^pow.
 If that is the case, isPower returns pow, if not, it returns zero.
*/


inline
int isPower( int val, int base )
{
    if ( val==base ) return 1;

    if ( val%base )
	return 0;

    int res = isPower( val/base, base );
    if ( res ) return 1 + res;

    return 0;
}


inline
int nextPower( int val, int base )
{
    int res = 1;
    while ( res<val ) res *= base;
    return res;
}

inline int getPow2Sz(int actsz, bool above=true, int minsz=1, int maxsz=INT_MAX)
{
    char npow = 0; char npowextra = actsz == 1 ? 1 : 0;
    int sz = actsz;
    while ( sz>1 )
    {
	if ( above && !npowextra && sz % 2 )
	    npowextra = 1;
	sz /= 2; npow++;
    }
    
    sz = intpow( 2, npow + npowextra );
    if ( sz<minsz ) sz = minsz;
    if ( sz>maxsz ) sz = maxsz;
    return sz;
}


inline int nextPower2( int nr, int minnr, int maxnr )
{
    if ( nr>maxnr )
	return maxnr;
    
    int newnr = minnr;
    while ( nr > newnr )
	newnr *= 2;
    
    return newnr;
}


/*!>
 Find number of blocks when given total number of samples, the base size for  
 each block and the number of samples overlaped between two blocks.
 */


inline
int nrBlocks( int totalsamples, int basesize, int overlapsize )
{
    int res = 0;
    while ( totalsamples>basesize )
    {
	res++;
	totalsamples = totalsamples - basesize + overlapsize;
    }
    
    return res+1;
}


/*!
\brief Taper an indexable array from 1 to taperfactor. If lowpos is less 
than highpos, the samples array[0] to array[lowpos] will be set to zero. 
If lowpos is more than highpos, the samples array[lowpos]  to array[sz-1]
will be set to zero. The taper can be either cosine or linear.
*/

mExpClass(Algo) Taper
{
public:
    enum Type { Cosine, Linear };
};


template <class T>
bool taperArray( T* array, int sz, int lowpos, int highpos, Taper::Type type )
{
    if ( lowpos  >= sz || lowpos  < 0 ||
         highpos >= sz || highpos < 0 ||
	 highpos == lowpos )
	return false;

    int pos = lowpos < highpos ? 0 : sz - 1 ;
    int inc = lowpos < highpos ? 1 : -1 ;

    while ( pos != lowpos )
    {
	array[pos] = 0;
	pos += inc;
    }

    int tapersz = abs( highpos - lowpos ); 
    float taperfactor = type == Taper::Cosine ? M_PI : 0;
    float taperfactorinc = ( type == Taper::Cosine ? M_PI : 1 ) / tapersz;
				

    while ( pos != highpos )
    {
	array[pos] *= type == Taper::Cosine ? .5 + .5 * cos( taperfactor ) 
					    : taperfactor;
	pos += inc;
	taperfactor += taperfactorinc;
    }

    return true;
}


/*!>
 Gradient from a series of 4 points, sampled like:
 x:  -2  -1  0  1  2
 y: ym2 ym1 y0 y1 y2
 The gradient estimation is done at x=0. y0 is generally not needed, but it
 will be used if there are one or more undefineds.
 The function will return mUdf(T) if there are too many missing values.
*/
template <class T>
inline T sampledGradient( T ym2, T ym1, T y0_, T y1_, T y2 )
{
    bool um1 = Values::isUdf(ym1), u0 = Values::isUdf(y0_),
    		u1 = Values::isUdf(y1_);

    if ( Values::isUdf(ym2) || Values::isUdf(y2) )
    {
        if ( um1 || u1 )
	    { if ( !u0 && !(um1 && u1) ) return um1 ? y1_ - y0_ : y0_ - ym1; }
        else
            return (y1_-ym1) * .5;
    }
    else if ( (um1 && u1) || (u0 && (um1 || u1)) )
        return (y2-ym2) * .25;
    else if ( um1 || u1 )
    {
        return um1 ? ((16*y1_)   - 3*y2  - ym2) / 12 - y0_
                   : ((-16*ym1) + 3*ym2 + y2)  / 12 + y0_;
    }
    else
        return (8 * ( y1_ - ym1 ) - y2 + ym2) / 12;

    return mUdf(T);
}


template <class X, class Y, class RT>
inline void getGradient( const X& x, const Y& y, int sz, int firstx, int firsty,
		  RT* gradptr=0, RT* interceptptr=0 )
{
    RT xy_sum = 0, x_sum=0, y_sum=0, xx_sum=0;

    for ( int idx=0; idx<sz; idx++ )
    {
	RT xval = x[idx+firstx];
	RT yval = y[idx+firsty];

	x_sum += xval;
	y_sum += yval;
	xx_sum += xval*xval;
	xy_sum += xval*yval;
    }

    RT grad = ( sz*xy_sum - x_sum*y_sum ) / ( sz*xx_sum - x_sum*x_sum );
    if ( gradptr ) *gradptr = grad;

    if ( interceptptr ) *interceptptr = (y_sum - grad*x_sum)/sz;
}


template <class X>
inline float variance( const X& x, int sz )
{
    if ( sz < 2 ) return mUdf(float);

    float sum=0;
    float sqsum=0;

    for ( int idx=0; idx<sz; idx++ )
    {
	float val = x[idx];

	sum += val;
	sqsum += val*val;
    }

    return (sqsum - sum * sum / sz)/ (sz -1);
}


/*!>
solve3DPoly - finds the roots of the equation 

    z^3+a*z^2+b*z+c = 0

solve3DPoly returns the number of real roots found.

Algorithms taken from NR, page 185.

*/

inline int solve3DPoly( double a, double b, double c, 
			 double& root0,
			 double& root1,
			 double& root2 )
{
    const double a2 = a*a;
    const double q = (a2-3*b)/9;
    const double r = (2*a2*a-9*a*b+27*c)/54;
    const double q3 = q*q*q;
    const double r2 = r*r;
    

    const double minus_a_through_3 = -a/3;

    if ( r2<q3 )
    {
	const double minus_twosqrt_q = -2*Math::Sqrt(q);
	const double theta = Math::ACos(r/Math::Sqrt(q3));
	static const double twopi = 2*M_PI;


	root0 = minus_twosqrt_q*cos(theta/3)+minus_a_through_3; 
	root1=minus_twosqrt_q*cos((theta-twopi)/3)+minus_a_through_3;
	root2=minus_twosqrt_q*cos((theta+twopi)/3)+minus_a_through_3;
	return 3;
    }

    const double A=(r>0?-1:1)*pow(fabs(r)+Math::Sqrt(r2-q3),1/3);
    const double B=mIsZero(A,mDefEps)?0:q/A;

    root0 = A+B+minus_a_through_3;

    /*!
    The complex roots can be calculated as follows:
    static const double sqrt3_through_2 = Math::Sqrt(3)/2;

    root1 = complex_double( 0.5*(A+B)+minus_a_through_3,
			   sqrt3_through_2*(A-B));

    root2 = complex_double( 0.5*(A+B)+minus_a_through_3,
			   -sqrt3_through_2*(A-B));
    */
			     

    return 1;
}


template <class T>
inline bool holdsClassValue( const T val, const unsigned int maxclss=50 )
{
    if ( mIsUdf(val) ) return true;
    if ( val < -mDefEps ) return false;
    const int ival = (int)(val + .5);
    return ival <= maxclss && mIsEqual(val,ival,mDefEps);
}


template <class T>
inline bool holdsClassValues( const T* vals, od_int64 sz,
			      const unsigned int maxclss=50,
			      const unsigned int samplesz=100 )
{
    if ( sz < 1 ) return true;
    if ( sz <= samplesz )
    {
	for ( int idx=0; idx<sz; idx++ )
	{
	    if ( !holdsClassValue(vals[idx],maxclss) )
		return false;
	}
	return true;
    }

    static od_int64 seed = mUdf(od_int64);
    seed *= seed + 1; // Clumsy but cheap sort-of random generation

    for ( int idx=0; idx<samplesz; idx++ )
    {
	od_int64 arridx = ((1+idx) * seed) % samplesz;
	if ( arridx<0 ) 
	    arridx = -arridx;

	if ( !holdsClassValue(vals[arridx],maxclss) )
	    return false;
    }
    return true;
}


template <class T>
inline bool isSigned8BitesValue( const T val )
{
    if ( val>127 || val<-128 )
	return false;

    const int ival = (int)(val>0 ? val+.5 : val-.5);
    return mIsEqual(val,ival,mDefEps);
}


template <class T>
inline bool is8BitesData( const T* vals, od_int64 sz,
	const unsigned int samplesz=100 )
{
    if ( holdsClassValues(vals,sz,255,samplesz) )
	return true;

    if ( sz <= samplesz )
    {
	for ( int idx=0; idx<sz; idx++ )
	{
	    if ( !isSigned8BitesValue(vals[idx]) )
		return false;
	}
	return true;
    }

    static od_int64 seed = mUdf(od_int64);
    seed *= seed + 1; // Clumsy but cheap sort-of random generation

    for ( int idx=0; idx<samplesz; idx++ )
    {
	od_int64 arridx = ((1+idx) * seed) % samplesz;
	if ( arridx<0 ) 
	    arridx = -arridx;
	
	if ( !isSigned8BitesValue(vals[arridx]) )
	    return false;
    }
    return true;
}

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef sorting_h
#define sorting_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		19-4-2000
 Contents:	Array sorting
 RCS:		$Id: sorting.h 34883 2014-05-27 06:27:16Z aneesh.tiwari@dgbes.com $
________________________________________________________________________

-*/

#include "algomod.h"
#include "gendefs.h"
#include "general.h"
#include "ptrman.h"
#include "task.h"
#include "thread.h"


#define mDoSort(extra_var,extra_action,sztype) \
{ \
    T tmp; extra_var; \
    for ( sztype d=sz/2; d>0; d=d/2 ) \
	for ( sztype i=d; i<sz; i++ ) \
	    for ( sztype j=i-d; j>=0 && arr[j]>arr[j+d]; j-=d ) \
	    { \
		tmp = arr[j]; arr[j] = arr[j+d]; arr[j+d] = tmp; \
		extra_action; \
	    } \
}

/*!> sort quickly (algorithm taken from xv). */
template <class T,class I>
inline void sort_array( T* arr, I sz )
mDoSort(,,I)

/*!> sort and remember where it was before sorting. */
template <class T, class IT,class I>
inline void sort_coupled( T* arr, IT* idxs, I sz )
mDoSort(IT itmp,itmp = idxs[j]; idxs[j] = idxs[j+d]; idxs[j+d] = itmp,I)

#undef mDoSort
#define mDoSort(extra_var,extra_action,sztype) \
{ \
    extra_var; \
    for ( sztype d=sz/2; d>0; d=d/2 ) \
	for ( sztype i=d; i<sz; i++ ) \
	    for ( sztype j=i-d; j>=0 && arr[j]>arr[j+d]; j-=d ) \
	    { \
		Swap( arr[j], arr[j+d] ); \
		extra_action; \
	    } \
}

/*!> sort quickly (algorithm taken from xv). */
template <class T>
inline void sort_idxabl( T& arr, int sz )
mDoSort(,,int)

/*!> sort and remember where it was before sorting. */
template <class T, class IT>
inline void sort_idxabl_coupled( T& arr, IT* idxs, int sz )
mDoSort(IT itmp,itmp = idxs[j]; idxs[j] = idxs[j+d]; idxs[j+d] = itmp,int)
#undef mDoSort

/*!> Sorting for data with many duplicates. */
template <class T,class I>
inline bool duplicate_sort( T* arr, I sz, int maxnrvals )
{
    TypeSet<T> vals;
    TypeSet<int> count;
    for ( I idx=0; idx<sz; ++idx )
    {
	const int vidx = vals.indexOf( arr[idx] );
	if ( vidx<0 )
	{
	    if ( vals.size()>maxnrvals )
	    {
		return false;
	    }
	    
	    count += 1;
	    vals += arr[idx];
	}
	else
	    count[vidx] += 1;
    }

    const int vsize = mCast(int,vals.size());
    TypeSet<int> idxs;
    for ( int idx=0; idx<vsize; idx++ )
    	idxs += idx;
    sort_coupled( vals.arr(), idxs.arr(), vsize );

    I index = -1;
    for ( int idx=0; idx<vsize; ++idx )
    {
	for ( int idy=count[idxs[idx]]-1; idy>=0; --idy )
	    arr[++index] = vals[idx];
    }
    
    return true;
}

//!>Old version to mantain binary compability
template <class T,class I>
inline void duplicate_sort( T* arr, I sz )
{
    duplicate_sort( arr, sz, sz );
}


/*!
\brief Sorting in parallel. Code is still experimental.

  The basic principle is:
  1. Divide samples into subsets.
  2. Sort subsets in parallel.
  3. Merge pairs of subsets iteratively until there are only one subset left.
*/

template <class T>
mClass(Algo) ParallelSorter : public ParallelTask
{
public:
				ParallelSorter(T* vals, int sz);
				ParallelSorter(T* vals, int* idxs, int sz);
protected:
    od_int64			nrIterations() const { return nrvals_; }

    int				minThreadSize() const { return 10000; }
    bool			doPrepare(int);
    bool			doFinish(bool);
    bool			doWork(od_int64,od_int64,int);
    static bool			mergeLists(const T* vals, T* res,
	    				   int start0,int start1,int start2,
	    				   int stop, int& totalsz );
    od_int64			nrDone() const { return totalnr_; }

    T*				vals_;
    ArrPtrMan<T>		tmpbuffer_;

    int*			idxs_;
    T*				curvals_;
    T*				buf_;

    const int			nrvals_;
    int				totalnr_;

    Threads::ConditionVar	condvar_;
    TypeSet<int>		starts_;
    TypeSet<int>		newstarts_;

    Threads::Barrier		barrier_;
};


#define NSMALL 7
#define FM 7875
#define FA 211
#define FC 1663
#define NSTACK 50

template <class T,class I> inline
void partSort( T* arr, I istart, I istop,
		      I* jstart, I* jstop )
{
    I ipivot, ileft, iright;
    T pivotval, tmp;
    mDefineStaticLocalObject( long int, seed, = 0L );
    mDefineStaticLocalObject( Threads::SpinLock, seedlock, );

    seedlock.lock();
    long int localseed = seed = (seed * FA + FC) % FM;
    seedlock.unLock();

    ipivot = (int)(istart + (istop-istart) * (float)localseed / (float)FM + .5);
    if ( ipivot < istart ) ipivot = istart;
    if ( ipivot > istop ) ipivot = istop;
    pivotval = arr[ipivot];

    for ( ileft=istart, iright=istop; ; )
    {
	while ( arr[ileft] <=pivotval && ileft<istop )   ileft++;
	while ( arr[iright]>=pivotval && iright>istart ) iright--;
	if ( ileft < iright )
	{
	    tmp = arr[ileft];
	    arr[ileft++] = arr[iright];
	    arr[iright--] = tmp;
	}
	else break;
    }

    if ( ileft < ipivot )
    {
	tmp = arr[ileft];
	arr[ileft++] = arr[ipivot];
	arr[ipivot] = tmp;
    }
    else if ( ipivot < iright )
    {
	tmp = arr[iright];
	arr[iright--] = arr[ipivot];
	arr[ipivot] = tmp;
    }

    *jstart = iright;
    *jstop = ileft;
}


template <class T, class I> inline
void insertionSort( T* arr, I istart, I istop )
{
    I i, j;
    T arr_i;

    for ( i=istart+1; i<=istop; i++ )
    {
	for ( arr_i=arr[i],j=i; j>istart && arr[j-1]>arr_i; j-- )
	    arr[j] = arr[j-1];
	arr[j] = arr_i;
    }
}


template <class T,class I> inline
void sortFor( T* arr, I sz, I itarget )
/*!> sorts the array until the 'itarget' element has exactly the right
value. The rest of the array must be considered unsorted after the operation,
although it will generally be better sorted. */
{
    I j, k, p = 0, q = sz-1;

    while( q - p > NSMALL )
    {
        partSort( arr, p, q, &j, &k );

        if ( itarget <= j )             q = j;
        else if ( itarget >= k )        p = k;
        else                            return;
    }

    insertionSort( arr, p, q );
}


template <class T,class I> inline
void quickSort( T* arr, I sz )
/*!> is quicker than sort_array for arrays larger than about 100 values. */
{
    I pstack[NSTACK], qstack[NSTACK], j, k, p, q, top=0;

    pstack[top] = 0;
    qstack[top++] = sz - 1;

    while( top )
    {
	p = pstack[--top];
	q = qstack[top];

	while( q - p > NSMALL )
	{
	    partSort( arr, p, q, &j, &k );

	    if ( j-p < q-k )
	    {
		pstack[top] = k;
		qstack[top++] = q;
		q = j;
	    }
	    else
	    {
		pstack[top] = p;
		qstack[top++] = j;
		p = k;
	    }
	}
	insertionSort( arr, p, q );
    }
}


template <class T, class IT> inline
void partSort( T* arr, IT* iarr, int istart, int istop, int* jstart, int* jstop)
{
    int ipivot, ileft, iright;
    T pivotval, tmp;
    IT itmp;
    mDefineStaticLocalObject( long int, seed, = 0L );
    mDefineStaticLocalObject( Threads::SpinLock, seedlock, );

    seedlock.lock();
    long int localseed = seed = (seed * FA + FC) % FM;
    seedlock.unLock();

    ipivot = (int)(istart + (istop-istart) * (float)localseed / (float)FM);
    if ( ipivot < istart ) ipivot = istart;
    if ( ipivot > istop ) ipivot = istop;
    pivotval = arr[ipivot];

    for ( ileft=istart, iright=istop; ; )
    {
	while ( arr[ileft] <=pivotval && ileft<istop )   ileft++;
	while ( arr[iright]>=pivotval && iright>istart ) iright--;
	if ( ileft < iright )
	{
	    itmp = iarr[ileft];
	    tmp = arr[ileft];

	    iarr[ileft] = iarr[iright];
	    arr[ileft++] = arr[iright];

	    iarr[iright] = itmp;
	    arr[iright--] = tmp;
	}
	else break;
    }

    if ( ileft < ipivot )
    {
	itmp = iarr[ileft];
	tmp = arr[ileft];

	iarr[ileft] = iarr[ipivot];
	arr[ileft++] = arr[ipivot];

	iarr[ipivot] = itmp;
	arr[ipivot] = tmp;
    }
    else if ( ipivot < iright )
    {
	itmp = iarr[iright];
	tmp = arr[iright];

	iarr[iright] = iarr[ipivot];
	arr[iright--] = arr[ipivot];

	iarr[ipivot] = itmp;
	arr[ipivot] = tmp;
    }

    *jstart = iright;
    *jstop = ileft;
}


template <class T, class IT> inline
void insertionSort( T* arr, IT* iarr, int istart, int istop )
{
    int i, j;
    T arr_i;
    IT iarr_i;

    for ( i=istart+1; i<=istop; i++ )
    {
	for ( iarr_i=iarr[i],arr_i=arr[i],j=i; j>istart && arr[j-1]>arr_i; j-- )
	{
	    arr[j] = arr[j-1];
	    iarr[j] = iarr[j-1];
	}

	arr[j] = arr_i;
	iarr[j] = iarr_i;
    }
}

template <class T, class IT>
void sortFor( T* arr, IT* iarr, int sz, int itarget )
{
    int j, k, p = 0, q = sz-1;

    while( q - p > NSMALL )
    {
        partSort( arr, iarr, p, q, &j, &k );

        if ( itarget <= j )             q = j;
        else if ( itarget >= k )        p = k;
        else                            return;
    }

    insertionSort( arr, iarr, p, q );
}


template <class T, class IT> inline
void quickSort( T* arr, IT* iarr, int sz )
{
    int pstack[NSTACK], qstack[NSTACK], j, k, p, q, top=0;

    pstack[top] = 0;
    qstack[top++] = sz - 1;

    while( top )
    {
	p = pstack[--top];
	q = qstack[top];

	while( q - p > NSMALL )
	{
	    partSort( arr, iarr, p, q, &j, &k );

	    if ( j-p < q-k )
	    {
		pstack[top] = k;
		qstack[top++] = q;
		q = j;
	    }
	    else
	    {
		pstack[top] = p;
		qstack[top++] = j;
		p = k;
	    }
	}

	insertionSort( arr, iarr, p, q );
    }
}

#undef NSMALL
#undef FM
#undef FA
#undef FC 
#undef NSTACK


//ParallelSort implementation
template <class T> inline
ParallelSorter<T>::ParallelSorter(T* vals, int sz)
    : vals_( vals )
    , nrvals_( sz )
    , tmpbuffer_( 0 )
    , barrier_( -1, false )
    , totalnr_(0)		     
    , idxs_( 0 )
{
    mTryAlloc( tmpbuffer_, T[sz] );
}


template <class T> inline
ParallelSorter<T>::ParallelSorter(T* vals, int* idxs, int sz)
    : vals_( vals )
    , nrvals_( sz )
    , tmpbuffer_( 0 )
    , totalnr_(0)		     
    , barrier_( -1, false )
    , idxs_( idxs )
{
    mTryAlloc( tmpbuffer_, T[sz] );
}


template <class T> inline
bool ParallelSorter<T>::doPrepare( int nrthreads )
{
    if ( !tmpbuffer_ )
	return false;

    barrier_.setNrThreads( nrthreads );

    starts_.erase();
    newstarts_.erase();

    int nrmerges = -1;
    while ( nrthreads )
    {
	nrmerges++;
	nrthreads>>=1;
    }

    totalnr_ = (1+nrmerges)*nrvals_;
    return true;
}


template <class T> inline
bool ParallelSorter<T>::doFinish( bool success )
{
    if ( !success )
	return false;

    if ( curvals_!=vals_ )
	memcpy( vals_, curvals_, nrvals_*sizeof(T) );

    return true;
}


template <class T> inline
bool ParallelSorter<T>::doWork( od_int64 start, od_int64 stop, int thread )
{
    const int threadsize = stop-start+1;
    if ( threadsize<100 )
    {
	if ( idxs_ )
	    sort_coupled( vals_+start, idxs_+start, threadsize );
	else
	    sort_array( vals_+start, threadsize );
    }
    else
    {
	if ( idxs_ )
	    quickSort( vals_+start, idxs_+start, threadsize );
	else
	    quickSort( vals_+start, threadsize );
    }

    if ( !shouldContinue() )
	return false;

    addToNrDone( threadsize );

    barrier_.mutex().lock();
    newstarts_ += start;
    barrier_.mutex().unLock();

    while ( true )
    {
	if ( barrier_.waitForAll(false) )
	{
	    if ( curvals_==vals_ )
	    {
		curvals_ = tmpbuffer_;
		buf_ = vals_;
	    }
	    else
	    {
		buf_ = tmpbuffer_;
		curvals_ = vals_;
	    }

	    starts_ = newstarts_;
	    barrier_.setNrThreads( starts_.size()/2 );
	    barrier_.releaseAllNoLock();
	}

	if ( thread>=barrier_.nrThreads() )
	{
	    barrier_.mutex().unLock();
	    //I'm not needed any longer
	    break;
	}

	const int curstart0 = starts_[0]; starts_.removeSingle( 0 );
	const int curstart1 = starts_[0]; starts_.removeSingle( 0 );
	int curstart2;
	if ( starts_.size()==1 )
	{
	    curstart2 = starts_[0];
	    starts_.removeSingle( 0 );
	}
	else
	    curstart2 = -1;

	const int curstop = (starts_.size() ? starts_[0] : nrvals_)-1;
	newstarts_ += curstart0;
	barrier_.mutex().unLock();

	int cursize;
	if ( !mergeLists( curvals_, buf_, 
		    curstart0, curstart1, curstart2, curstop, cursize) )
	    return false;

	if ( !shouldContinue() )
	    return false;

	addToNrDone( cursize );
    }

    return true;
}


template <class T> inline
bool ParallelSorter<T>::mergeLists( const T* valptr, T* result,
				    int start0, int start1, int start2,
				    int stop, int& totalsz )
{
    const int sz0 = start1-start0;
    const int sz1 = start2==-1 ? stop-start1+1 : start2-start1;
    const int sz2 = start2==-1 ? 0 : stop-start2+1;
    totalsz = sz0+sz1+sz2;

    const T* ptr0 = valptr + start0;
    const T* stopptr0 = ptr0+sz0;
    const T* ptr1 = valptr + start1;
    const T* stopptr1 = ptr1+sz1;
    const T* ptr2 = start2==-1 ? 0 : valptr + start2;
    const T* stopptr2 = ptr2+sz2;

    while ( true )
    {
	if ( ptr0 && (!ptr1 || *ptr0<*ptr1) && (!ptr2 || *ptr0<*ptr2 ) )
	{
	    (*result++) = (*ptr0++);
	    if ( ptr0==stopptr0 )
		ptr0 = 0;
	}
	else if ( ptr1 && ( !ptr2 || *ptr1<*ptr2 ) )
	{
	    (*result++) = (*ptr1++);
	    if ( ptr1==stopptr1 )
		ptr1 = 0;
	}
	else if ( ptr2 )
	{
	    (*result++) = (*ptr2++);
	    if ( ptr2==stopptr2 )
		ptr2 = 0;
	}
	else
	    break;
    }

    return true;
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef statruncalc_h
#define statruncalc_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl (org) / Bert Bril (rev)
 Date:          10-12-1999 / Sep 2006
 RCS:           $Id: statruncalc.h 32511 2013-11-21 10:08:05Z aneesh.tiwari@dgbes.com $
________________________________________________________________________

-*/

#include "algomod.h"
#include "convert.h"
#include "math2.h"
#include "stattype.h"
#include "sorting.h"
#include "sets.h"

#define mUndefReplacement 0

/*!\brief Statistics*/

namespace Stats
{

/*!
\brief Setup for the Stats::RunCalc and Stats::ParallelCalc objects.
  
  medianEvenHandling() is tied to OD_EVEN_MEDIAN_AVERAGE, OD_EVEN_MEDIAN_LOWMID,
  and settings dTect.Even Median.Average and dTect.Even Median.LowMid.
  When medianing over an even number of points, either take the low mid (<0),
  hi mid (>0), or avg the two middles. By default, hi mid is used.
*/

mExpClass(Algo) CalcSetup
{ 
public:
    			CalcSetup( bool weighted=false )
			    : weighted_(weighted)
			    , needextreme_(false)
			    , needsums_(false)
			    , needmed_(false) 
			    , needvariance_(false) 
			    , needmostfreq_(false)	{}

    CalcSetup&       	require(Type);

    static int		medianEvenHandling();

    bool		isWeighted() const	{ return weighted_; }
    bool		needExtreme() const	{ return needextreme_; }
    bool		needSums() const	{ return needsums_; }
    bool		needMedian() const	{ return needmed_; }
    bool		needMostFreq() const	{ return needmostfreq_; }
    bool		needVariance() const	{ return needvariance_; }

protected:

    template <class T>
    friend class	BaseCalc;
    template <class T>
    friend class	RunCalc;
    template <class T>
    friend class	WindowedCalc;
    template <class T>
    friend class	ParallelCalc;

    bool		weighted_;
    bool		needextreme_;
    bool		needsums_;
    bool		needmed_;
    bool		needmostfreq_;
    bool		needvariance_;

};


/*!
\brief Base class to calculate mean, min, max, etc.. can be used either as
running values (Stats::RunCalc) or in parallel (Stats::ParallelCalc).
  
  The mostFrequent assumes the data contains integer classes. Then the class
  that is found most often will be the output. Weighting, again, assumes integer
  values. Beware that if you pass data that is not really class-data, the
  memory consumption can become large (and the result will be rather
  uninteresting).
  
  The variance won't take the decreasing degrees of freedom into consideration
  when weights are provided.
  
  The object is ready to use with int, float and double types. If other types
  are needed, you may need to specialise an isZero function for each new type.

-*/

template <class T>
mClass(Algo) BaseCalc
{
public:

    virtual		~BaseCalc()		{}

    inline void		clear();
    const CalcSetup&	setup() const		{ return setup_; }
    bool		isWeighted() const	{ return setup_.weighted_; }

    inline double	getValue(Type) const;
    inline int		getIndex(Type) const; //!< only for Median, Min and Max

    inline bool		hasUndefs() const	{ return nrused_ != nradded_; }
    inline int		size( bool used=true ) const
    			{ return used ? nrused_ : nradded_; }

    inline bool		isEmpty() const		{ return size() == 0; }

    inline int		count() const		{ return nrused_; }
    inline double	average() const;
    inline T		mostFreq() const;
    inline T		sum() const;
    inline T		min(int* index_of_min=0) const;
    inline T		max(int* index_of_max=0) const;
    inline T		extreme(int* index_of_extr=0) const;
    inline T		median(int* index_of_median=0) const;
    inline T		sqSum() const;
    inline double	rms() const;
    inline double	stdDev() const;
    inline double	normvariance() const;
    virtual inline double variance() const; 

    inline T		clipVal(float ratio,bool upper) const;
    			//!< require median; 0 <= ratio <= 1

    TypeSet<T>		medvals_;

protected:
			BaseCalc( const CalcSetup& s )
			    : setup_(s) { clear(); }

    CalcSetup		setup_;

    int			nradded_; 
    int			nrused_;
    int			minidx_;
    int			maxidx_;
    T			minval_;
    T			maxval_;
    T			sum_x_;
    T			sum_xx_;
    T			sum_w_;
    T			sum_wx_;
    T			sum_wxx_;

    TypeSet<int>	clss_;
    TypeSet<T>		clsswt_;
    TypeSet<T>		medwts_;

    inline bool		isZero( const T& t ) const;
};


template <> inline
bool BaseCalc<float>::isZero( const float& val ) const
{ return mIsZero(val,1e-6); }


template <> inline
bool BaseCalc<double>::isZero( const double& val ) const
{ return mIsZero(val,1e-10); }


template <class T> inline
bool BaseCalc<T>::isZero( const T& val ) const
{ return !val; }


/*!
\brief Calculates mean, min, max etc., as running values.
  
  The idea is that you simply add values and ask for a stat whenever needed.
  The clear() method resets the object and makes it able to work with new data.
  
  Adding values can be doing with weight (addValue) or without (operator +=).
  You can remove a value; for Min or Max this has no effect as this would
  require buffering all data.
-*/

template <class T>
mClass(Algo) RunCalc : public BaseCalc<T>
{
public:
    			RunCalc( const CalcSetup& s )
			    : BaseCalc<T>(s) {}

    inline RunCalc<T>&	addValue(T data,T weight=1);
    inline RunCalc<T>&	addValues(int sz,const T* data,const T* weights=0);
    inline RunCalc<T>&	replaceValue(T olddata,T newdata,T wt=1);
    inline RunCalc<T>&	removeValue(T data,T weight=1);

    inline RunCalc<T>&	operator +=( T t )	{ return addValue(t); }

    using BaseCalc<T>::medvals_;

protected:

    using BaseCalc<T>::setup_;
    using BaseCalc<T>::nradded_;
    using BaseCalc<T>::nrused_;
    using BaseCalc<T>::minidx_;
    using BaseCalc<T>::maxidx_;
    using BaseCalc<T>::maxval_;
    using BaseCalc<T>::minval_;
    using BaseCalc<T>::sum_x_;
    using BaseCalc<T>::sum_xx_;
    using BaseCalc<T>::sum_w_;
    using BaseCalc<T>::sum_wx_;
    using BaseCalc<T>::sum_wxx_;
    using BaseCalc<T>::clss_;
    using BaseCalc<T>::clsswt_;
    using BaseCalc<T>::medwts_;
};



/*!
\brief RunCalc manager which buffers a part of the data.
 
  Allows calculating running stats on a window only. Once the window is full,
  WindowedCalc will replace the first value added (fifo).
*/

template <class T>
mClass(Algo) WindowedCalc
{
public:
			WindowedCalc( const CalcSetup& rcs, int sz )
			    : calc_(rcs)
			    , sz_(sz)
			    , wts_(calc_.isWeighted() ? new T [sz] : 0)
			    , vals_(new T [sz])	{ clear(); }
			~WindowedCalc()	
				{ delete [] vals_; delete [] wts_; }
    inline void		clear();

    inline WindowedCalc& addValue(T data,T weight=1);
    inline WindowedCalc& operator +=( T t )	{ return addValue(t); }

    inline int		getIndex(Type) const;
    			//!< Only use for Min, Max or Median
    inline double	getValue(Type) const;

    inline T		count() const	{ return full_ ? sz_ : posidx_; }

#   define			mRunCalc_DefEqFn(ret,fn) \
    inline ret			fn() const	{ return calc_.fn(); }
    mRunCalc_DefEqFn(double,	average)
    mRunCalc_DefEqFn(double,	variance)
    mRunCalc_DefEqFn(double,	normvariance)
    mRunCalc_DefEqFn(T,		sum)
    mRunCalc_DefEqFn(T,		sqSum)
    mRunCalc_DefEqFn(double,	rms)
    mRunCalc_DefEqFn(double,	stdDev)
    mRunCalc_DefEqFn(T,		mostFreq)
#   undef			mRunCalc_DefEqFn

    inline T			min(int* i=0) const;
    inline T			max(int* i=0) const;
    inline T			extreme(int* i=0) const;
    inline T			median(int* i=0) const;

protected:

    RunCalc<T>	calc_; // has to be before wts_ (see constructor inits)
    const int	sz_;
    T*		wts_;
    T*		vals_;
    int		posidx_;
    bool	empty_;
    bool	full_;
    bool	needcalc_;

    inline void	fillCalc(RunCalc<T>&) const;
};



template <class T> inline
void BaseCalc<T>::clear()
{
    sum_x_ = sum_w_ = sum_xx_ = sum_wx_ = sum_wxx_ = 0;
    nradded_ = nrused_ = minidx_ = maxidx_ = 0;
    minval_ = maxval_ = mUdf(T);
    clss_.erase(); clsswt_.erase(); medvals_.erase(); medwts_.erase();
}


template <class T> inline
double BaseCalc<T>::getValue( Stats::Type t ) const
{
    switch ( t )
    {
	case Count:		return count();
	case Average:		return average();
	case Median:		return median();
	case RMS:		return rms();
	case StdDev:		return stdDev();
	case Variance:		return variance();
	case NormVariance:	return normvariance();			
	case Min:		return min();
	case Max:		return max();
	case Extreme:		return extreme();
	case Sum:		return sum();
	case SqSum:		return sqSum();
	case MostFreq:		return mostFreq();
    }

    return 0;
}


template <class T> inline
int BaseCalc<T>::getIndex( Type t ) const
{
    int ret;
    switch ( t )
    {
	case Min:		(void)min( &ret );	break;
	case Max:		(void)max( &ret );	break;
	case Extreme:		(void)extreme( &ret );	break;
	case Median:		(void)median( &ret );	break;
	default:		ret = 0;	break;
    }
    return ret;
}



#undef mBaseCalc_ChkEmpty
#define mBaseCalc_ChkEmpty(typ) \
    if ( nrused_ < 1 ) return mUdf(typ);

template <class T>
inline double BaseCalc<T>::stdDev() const
{
    mBaseCalc_ChkEmpty(double);

    double v = variance();
    return v > 0 ? Math::Sqrt( v ) : 0;
}


template <class T>
inline double BaseCalc<T>::average() const
{
    mBaseCalc_ChkEmpty(double);

    if ( !setup_.weighted_ )
	return ((double)sum_x_) / nrused_;

    return this->isZero(sum_w_) ? mUdf(double) : ((double)sum_wx_) / sum_w_;
}


template <class T>
inline T BaseCalc<T>::sum() const
{
    mBaseCalc_ChkEmpty(T);
    return sum_x_;
}


template <class T>
inline T BaseCalc<T>::sqSum() const
{
    mBaseCalc_ChkEmpty(T);
    return sum_xx_;
}


template <class T>
inline double BaseCalc<T>::rms() const
{
    mBaseCalc_ChkEmpty(double);

    if ( !setup_.weighted_ )
	return Math::Sqrt( ((double)sum_xx_) / nrused_ );

    return this->isZero(sum_w_) ? mUdf(double) : Math::Sqrt( ((double)sum_wxx_)/sum_w_ );
}


template <class T>
inline double BaseCalc<T>::variance() const 
{
    if ( nrused_ < 2 ) return 0;

    if ( !setup_.weighted_ )
	return ( sum_xx_ - (sum_x_ * ((double)sum_x_) / nrused_) )
	     / (nrused_ - 1);

    return (sum_wxx_ - (sum_wx_ * ((double)sum_wx_) / sum_w_) )
	 / ( (nrused_-1) * ((double)sum_w_) / nrused_ );
}


template <class T>
inline double BaseCalc<T>::normvariance() const
{
    if ( nrused_ < 2 ) return 0;

    double fact = 0.1;
    double avg = average();
    double var = variance();
    const double divisor = avg*avg + fact*var;
    if ( mIsZero(divisor,mDefEps) )
	return 0;

    return var / divisor;
}


template <class T>
inline T BaseCalc<T>::min( int* index_of_min ) const
{
    if ( index_of_min ) *index_of_min = minidx_;
    mBaseCalc_ChkEmpty(T);
    return minval_;
}


template <class T>
inline T BaseCalc<T>::max( int* index_of_max ) const
{
    if ( index_of_max ) *index_of_max = maxidx_;
    mBaseCalc_ChkEmpty(T);
    return maxval_;
}


template <class T>
inline T BaseCalc<T>::extreme( int* index_of_extr ) const
{
    if ( index_of_extr ) *index_of_extr = 0;
    mBaseCalc_ChkEmpty(T);

    const T maxcmp = maxval_ < 0 ? -maxval_ : maxval_;
    const T mincmp = minval_ < 0 ? -minval_ : minval_;
    if ( maxcmp < mincmp )
    {
	if ( index_of_extr ) *index_of_extr = minidx_;
	return minval_;
    }
    else
    {
	if ( index_of_extr ) *index_of_extr = maxidx_;
	return maxval_;
    }
}


template <class T>
inline T BaseCalc<T>::clipVal( float ratio, bool upper ) const
{
    mBaseCalc_ChkEmpty(T);
    (void)median();
    const int lastidx = medvals_.size();
    const float fidx = ratio * lastidx;
    const int idx = fidx <= 0 ? 0 : (fidx > lastidx ? lastidx : (int)fidx);
    return medvals_[upper ? lastidx - idx : idx];
}


template <class T>
inline T BaseCalc<T>::mostFreq() const
{
    if ( clss_.isEmpty() )
	return mUdf(T);

    T maxwt = clsswt_[0]; int ret = clss_[0];
    for ( int idx=1; idx<clss_.size(); idx++ )
    {
	if ( clsswt_[idx] > maxwt )
	    { maxwt = clsswt_[idx]; ret = clss_[idx]; }
    }

    return (T)ret;
}


template <class T> inline
T computeMedian( const T* data, int sz, int pol, int* idx_of_med ) 
{
    if ( idx_of_med ) *idx_of_med = 0;
    if ( sz < 2 )
	return sz < 1 ? mUdf(T) : data[0];

    int mididx = sz / 2;
    T* valarr = const_cast<T*>( data );
    if ( !idx_of_med )
	quickSort( valarr, sz );
    else
    {
	mGetIdxArr(int,idxs,sz)
	quickSort( valarr, idxs, sz );
	*idx_of_med = idxs[ mididx ];
	delete [] idxs;
    }

    if ( sz%2 == 0 )
    {
	if ( pol == 0 )
	    return (data[mididx] + data[mididx-1]) / 2;
	else if ( pol == 1 )
	   mididx--;
    }

    return data[ mididx ];
}


template <class T> inline
T computeWeightedMedian( const T* data, const T* wts, int sz, 
				int* idx_of_med ) 
{
    if ( idx_of_med ) *idx_of_med = 0;
    if ( sz < 2 )
	return sz < 1 ? mUdf(T) : data[0];

    T* valarr = const_cast<T*>( data );
    mGetIdxArr(int,idxs,sz)
    quickSort( valarr, idxs, sz );
    T* wtcopy = new T[sz];
    memcpy( wtcopy, wts, sz*sizeof(T) );
    float wsum = 0;
    for ( int idx=0; idx<sz; idx++ )
    {
	const_cast<T&>(wts[idx]) = wtcopy[ idxs[idx] ];
	wsum += (float) wts[idx];
    }
    delete [] idxs;

    const float hwsum = wsum * 0.5f;
    wsum = 0;
    int medidx = 0;
    for ( int idx=0; idx<sz; idx++ )
    {
	wsum += (float) wts[idx];
	if ( wsum >= hwsum )
	    { medidx = idx; break; }
    }
    if ( idx_of_med ) *idx_of_med = medidx;
    return valarr[ medidx ];
}


template <class T>
inline T BaseCalc<T>::median( int* idx_of_med ) const
{
    const int policy = setup_.medianEvenHandling();
    const int sz = medvals_.size();
    const T* vals = medvals_.arr();
    return setup_.weighted_ ? 
	  computeWeightedMedian( vals, medwts_.arr(), sz, idx_of_med ) 
	: computeMedian( vals, sz, policy, idx_of_med );
}




template <class T> inline
RunCalc<T>& RunCalc<T>::addValue( T val, T wt )
{
    nradded_++;
    if ( mIsUdf(val) )
	return *this;
    if ( setup_.weighted_ && (mIsUdf(wt) || this->isZero(wt)) )
	return *this;

    if ( setup_.needmed_ )
    {
	medvals_ += val;
	if ( setup_.weighted_ )
	    medwts_ += wt;
    }

    if ( setup_.needextreme_ )
    {
	if ( nrused_ == 0 )
	    minval_ = maxval_ = val;
	else
	{
	    if ( val < minval_ ) { minval_ = val; minidx_ = nradded_ - 1; }
	    if ( val > maxval_ ) { maxval_ = val; maxidx_ = nradded_ - 1; }
	}
    }

    if ( setup_.needmostfreq_ )
    {
	int ival; Conv::set( ival, val );
	int setidx = clss_.indexOf( ival );

	if ( setidx < 0 )
	    { clss_ += ival; clsswt_ += wt; }
	else
	    clsswt_[setidx] += wt;
    }

    if ( setup_.needsums_ )
    {
	sum_x_ += val;
	sum_xx_ += val * val;
	if ( setup_.weighted_ )
	{
	    sum_w_ += wt;
	    sum_wx_ += wt * val;
	    sum_wxx_ += wt * val * val;
	}
    }

    nrused_++;
    return *this;
}


template <class T> inline
RunCalc<T>& RunCalc<T>::removeValue( T val, T wt )
{
    nradded_--;
    if ( mIsUdf(val) )
	return *this;
    if ( setup_.weighted_ && (mIsUdf(wt) || this->isZero(wt)) )
	return *this;

    if ( setup_.needmed_ )
    {
	int idx = medvals_.size();
	while ( true )
	{
	    idx = medvals_.indexOf( val, false, idx-1 );
	    if ( idx < 0 ) break;
	    if ( medwts_[idx] == wt )
	    {
		medvals_.removeSingle( idx );
		medwts_.removeSingle( idx );
		break;
	    }
	}
    }

    if ( setup_.needmostfreq_ )
    {
	int ival; Conv::set( ival, val );
	int setidx = clss_.indexOf( ival );
	int iwt = 1;
	if ( setup_.weighted_ )
	    Conv::set( iwt, wt );

	if ( setidx >= 0 )
	{
	    clsswt_[setidx] -= wt;
	    if ( clsswt_[setidx] <= 0 )
	    {
		clss_.removeSingle( setidx );
		clsswt_.removeSingle( setidx );
	    }
	}
    }

    if ( setup_.needsums_ )
    {
	sum_x_ -= val;
	sum_xx_ -= val * val;
	if ( setup_.weighted_ )
	{
	    sum_w_ -= wt;
	    sum_wx_ -= wt * val;
	    sum_wxx_ -= wt * val * val;
	}
    }

    nrused_--;
    return *this;
}


template <class T> inline
RunCalc<T>& RunCalc<T>::addValues( int sz, const T* data, const T* weights )
{
    for ( int idx=0; idx<sz; idx++ )
	addValue( data[idx], weights ? weights[idx] : 1 );
    return *this;
}


template <class T> inline
RunCalc<T>& RunCalc<T>::replaceValue( T oldval, T newval, T wt )
{
    removeValue( oldval, wt );
    return addValue( newval, wt );
}




template <class T> inline
void WindowedCalc<T>::clear()
{
    posidx_ = 0; empty_ = true; full_ = false;
    needcalc_ = calc_.setup().needSums() || calc_.setup().needMostFreq();
    calc_.clear();
}


template <class T> inline
void WindowedCalc<T>::fillCalc( RunCalc<T>& calc ) const
{
    if ( empty_ ) return;

    const int stopidx = full_ ? sz_ : posidx_;
    for ( int idx=posidx_; idx<stopidx; idx++ )
	calc.addValue( vals_[idx], wts_ ? wts_[idx] : 1 );
    for ( int idx=0; idx<posidx_; idx++ )
	calc.addValue( vals_[idx], wts_ ? wts_[idx] : 1 );
}


template <class T> inline
double WindowedCalc<T>::getValue( Type t ) const
{
    switch ( t )
    {
    case Min:		return min();
    case Max:		return max();
    case Extreme:	return extreme();
    case Median:	return median();
    default:		break;
    }
    return calc_.getValue( t );
}


template <class T> inline
int WindowedCalc<T>::getIndex( Type t ) const
{
    int ret;
    switch ( t )
    {
	case Min:		(void)min( &ret );	break;
	case Max:		(void)max( &ret );	break;
	case Extreme:		(void)extreme( &ret );	break;
	case Median:		(void)median( &ret );	break;
	default:		ret = 0;	break;
    }
    return ret;
}


template <class T> inline
T WindowedCalc<T>::min( int* index_of_min ) const
{
    RunCalc<T> calc( CalcSetup().require(Stats::Min) );
    fillCalc( calc );
    return calc.min( index_of_min );
}


template <class T> inline
T WindowedCalc<T>::max( int* index_of_max ) const
{
    RunCalc<T> calc( CalcSetup().require(Stats::Max) );
    fillCalc( calc );
    return calc.max( index_of_max );
}


template <class T> inline
T WindowedCalc<T>::extreme( int* index_of_extr ) const
{
    RunCalc<T> calc( CalcSetup().require(Stats::Extreme) );
    fillCalc( calc );
    return calc.extreme( index_of_extr );
}


template <class T> inline
T WindowedCalc<T>::median( int* index_of_med ) const
{
    CalcSetup rcs( calc_.setup().weighted_ );
    RunCalc<T> calc( rcs.require(Stats::Median) );
    fillCalc( calc );
    return calc.median( index_of_med );
}


template <class T>
inline WindowedCalc<T>&	WindowedCalc<T>::addValue( T val, T wt )
{
    if ( needcalc_ )
    {
	if ( !full_ )
	    calc_.addValue( val, wt );
	else
	{
	    if ( !wts_ || wt == wts_[posidx_] )
		calc_.replaceValue( vals_[posidx_], val, wt );
	    else
	    {
		calc_.removeValue( vals_[posidx_], wts_[posidx_] );
		calc_.addValue( val, wt );
	    }
	}
    }

    vals_[posidx_] = val;
    if ( wts_ ) wts_[posidx_] = wt;

    posidx_++;
    if ( posidx_ >= sz_ )
	{ full_ = true; posidx_ = 0; }

    empty_ = false;
    return *this;
}

#undef mRunCalc_ChkEmpty

}; // namespace Stats

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef stattype_h
#define stattype_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bert Bril
 Date:          Sep 2006
 RCS:           $Id: stattype.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "enums.h"
#include "algomod.h"

namespace Stats
{

    /* One-dimensional statistical properties of value series */
enum Type
{
    	Count,
	Average, Median, RMS,
	StdDev, Variance, NormVariance,
	Min, Max, Extreme,
	Sum, SqSum,
	MostFreq
};
DeclareNameSpaceEnumUtils(Algo,Type)

    /* When resampling a denser sampling */
enum UpscaleType
{
	TakeNearest,
	UseAvg, UseMed, UseRMS, UseMostFreq
};
DeclareNameSpaceEnumUtils(Algo,UpscaleType)

inline Type typeFor( UpscaleType ut )
{
    return ut == UseAvg ?	Average
	: (ut == UseRMS ?	RMS
	: (ut == UseMostFreq ?	MostFreq
	:			Median));
}

inline UpscaleType upscaleTypeFor( Type st )
{
    return st == Average ?	UseAvg
	: (st == RMS ?		UseRMS
	: (st == MostFreq ?	UseMostFreq
	: (st == Median ?	UseMed
	:			TakeNearest)));
}


}; // namespace Stats


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef transform_h
#define transform_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          10-12-1999
 RCS:           $Id: transform.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#include "algomod.h"
#include "complex"
#include "task.h"
#include "sets.h"

class ArrayNDInfo;
template <class T> class ArrayND;

typedef std::complex<float> float_complex;

/*!
\brief Lets any 1D orthogonal transform (GenericTransformND::GenericTransform1D)be extended to ND. Most transform fftw can be implemented as a subclass of
GenericTransformND.
*/

mExpClass(Algo) GenericTransformND : public SequentialTask
{
public:
			GenericTransformND();
    bool		setInputInfo(const ArrayNDInfo&);
    const ArrayNDInfo&	getInputInfo() const;

    void		setInput(const float*);
    void		setInput(const float_complex*);
    void		setOutput(float*);
    void		setOutput(float_complex*);

    void		setSampling(int);
    void		setScope(int nr,int batchsampling);
			/*!<\param nr number of signals
			    \param batchsampling number of samples between
			    	   signal starts. */
    void		setScope(int nr,const int* batchstarts);
			/*!<\param nr number of signals
			    \param batchstarts pointer to array with the indices
				   of the signal starts.*/

    bool		setDir(bool forward);
    bool		getDir() const	{ return forward_; }
    			//true for forward
    bool		run(bool parallel);
    			//SequentialTask::execute can be used as well

			~GenericTransformND();
mProtected:
    virtual bool		setup();			
    int				nextStep();

    class			Transform1D;
    virtual Transform1D*	createTransform() const		= 0;

    ObjectSet<Transform1D>	transforms_;
    ObjectSet<int>		transforms1dstarts_;
    TypeSet<int>		nr1dtransforms_;

    bool			forward_;
    int				sampling_;
    int				batchsampling_;
    const int*			batchstarts_;
    int				nr_;

    ArrayNDInfo*		info_;
    int				curdim_;
    bool			parallel_;

    const float_complex*	cinput_;
    const float*		rinput_;
    float_complex*		coutput_;
    float*			routput_;

    mExpClass(Algo) Transform1D
    {
    public:
	virtual		~Transform1D()				{}
	void		setInputData(const float_complex*);
	void		setInputData(const float*);
	void		setOutputData(float_complex*);
	void		setOutputData(float*);

	void		setSize(int);
	void		setDir(bool forward);
	void		setSampling(int);
			//!<\param samplespacing sampling within a signal.
	void		setScope(int nr,int batchsampling);
			/*!<\param nr number of signals
			    \param batchsampling number of samples between
			    	   signal starts. */
	void		setScope(int nr,const int* batchstarts);
			/*!<\param nr number of signals
			    \param batchstarts pointer to array with the indices
				   of the signal starts.*/

	virtual bool	init() { return true; }
	virtual bool	run(bool parallel)				= 0;

    mProtected:
				
    				Transform1D();

	int			sz_;
	bool			forward_;
	int			sampling_;
	int			nr_;
	int			batchsampling_;
	const int*		batchstarts_;

	const float_complex*	cinput_;
	const float*		rinput_;
	float_complex*		coutput_;
	float*			routput_;
    };
};

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef trigonometry_h
#define trigonometry_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Kristofer Tingdahl
 Date:		23-11-2002
 RCS:		$Id: trigonometry.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#include "algomod.h"
#include "position.h"
#include <math.h>

template <class T> class TypeSet;
template <class T> class ObjectSet;
class Plane3;

/*!\brief
Given a point pt in a triangle ABC, we calculate the interpolation weights for
each vertex.
 */
inline void interpolateOnTriangle2D( const Coord pt, 
			const Coord a, const Coord b, const Coord c, 
			float& weight_a, float& weight_b, float& weight_c )
{
    const Coord d0 = b-a;
    const Coord d1 = pt-a;
    const Coord d2 = b-c;
    const float para_pt = (float)((d0.x*d2.y-d0.y*d2.x)/(d1.x*d2.y-d1.y*d2.x));
    const float para_bc = (float)((d1.x*d0.y-d1.y*d0.x)/(d1.x*d2.y-d1.y*d2.x));

    if ( mIsZero(para_pt, 1e-5) )
    {
	weight_a = 1;
	weight_b = 0;
	weight_c = 0;
	return;
    }

    weight_a = 1-1/para_pt;
    weight_b = (1-para_bc)/para_pt;
    weight_c = para_bc/para_pt;
}


/*!\brief
Here are some commonly used functions to judge the position relation between 
point and line, point and triangle, point and circle or sphere.
*/

/*Calculate a 3x3 matrix's determinent given by v[0]-v[8] with 9 elements. */
inline double determinent33( const double* v )
{
    return v[0]*(v[4]*v[8]-v[5]*v[7])+v[1]*(v[5]*v[6]-v[3]*v[8])+
	v[2]*(v[3]*v[7]-v[4]*v[6]);
}


/*Calculate a 4x4 matrix's determinent given by rows r0, r1, r2, r3 with the 
  last column 1, 1, 1, 1. */
inline double determinent44( const Coord3& r0, const Coord3& r1, 
		             const Coord3& r2, const Coord3& r3 )
{
    const double d0[9] = { r1.y, r1.z, 1, r2.y, r2.z, 1, r3.y, r3.z, 1 };
    const double d1[9] = { r1.x, r1.z, 1, r2.x, r2.z, 1, r3.x, r3.z, 1 };
    const double d2[9] = { r1.x, r1.y, 1, r2.x, r2.y, 1, r3.x, r3.y, 1 };
    const double d3[9] = { r1.x, r1.y, r1.z, r2.x, r2.y, r2.z, r3.x, r3.y,r3.z};
    return r0.x*determinent33( d0 )-r0.y*determinent33( d1 )+
	   r0.z*determinent33( d2 )-determinent33( d3 );
}

/*!<Each ri represents a row of 4 elements. */
inline double determinent44( const double* r0, const double* r1, 
			     const double* r2, const double* r3 )
{
    const double d0[9] = { r1[1], r1[2], r1[3], r2[1], r2[2], r2[3], 
			   r3[1], r3[2], r3[3] };
    const double d1[9] = { r1[0], r1[2], r1[3], r2[0], r2[2], r2[3], 
			   r3[0], r3[2], r3[3] };
    const double d2[9] = { r1[0], r1[1], r1[3], r2[0], r2[1], r2[3], 
			   r3[0], r3[1], r3[3] };
    const double d3[9] = { r1[0], r1[1], r1[2], r2[0], r2[1], r2[2], 
			   r3[0], r3[1], r3[2] };
    return r0[0]*determinent33( d0 )-r0[1]*determinent33( d1 )+
	   r0[2]*determinent33( d2 )-r0[3]*determinent33( d3 );
}

/*!<Check the point pt is inside the circumcircle of p1, p2, p3 or not. */
inline bool isInsideCircle( const Coord& pt, 
			    const Coord& p1, const Coord& p2, const Coord& p3 )
{
    Coord center;
    const Coord d12 = p1-p2;
    const Coord d13 = p1-p3;
    const Coord d = p1-pt;
    const double deter=d13.x*d12.y-d13.y*d12.x;
    const double a12 = ( p1.dot(p1)-p2.dot(p2) )/2;
    const double a13 = ( p1.dot(p1)-p3.dot(p3) )/2;
    center.x = (a13*d12.y-a12*d13.y)/deter;
    center.y = (d13.x*a12-d12.x*a13)/deter;
    return pt.sqAbs()-p1.sqAbs()+2*center.dot(d)<0;
}


/*!<Check the point p is inside the circumsphere of a, b, c, d or not. */
inline bool isInsideCircumSphere( const Coord3& p, const Coord3& a,
	const Coord3& b, const Coord3& c, const Coord3& d )
{
    const Coord3 ab = a-b;
    const Coord3 ac = a-c;
    const Coord3 ad = a-d;
    const double t[9] = { ab.x, ab.y, ab.z, ac.x, ac.y, ac.z, ad.x, ad.y, ad.z};
    const double deter = determinent33( t );
    
    const double sqra = a.x*a.x+a.y*a.y+a.z*a.z;
    const double d0 = (sqra-(b.x*b.x+b.y*b.y+b.z*b.z))/2;
    const double d1 = (sqra-(c.x*c.x+c.y*c.y+c.z*c.z))/2;
    const double d2 = (sqra-(d.x*d.x+d.y*d.y+d.z*d.z))/2;
    const double t0[9] = { d0, ab.y, ab.z, d1, ac.y, ac.z, d2, ad.y, ad.z };
    const double t1[9] = { ab.x, d0, ab.z, ac.x, d1, ac.z, ad.x, d2, ad.z };
    const double t2[9] = { ab.x, ab.y, d0, ac.x, ac.y, d1, ad.x, ad.y, d2 };
    const double centerx = determinent33(t0)/deter;
    const double centery = determinent33(t1)/deter;
    const double centerz = determinent33(t2)/deter;
    
    return (p.x*p.x+p.y*p.y+p.z*p.z-sqra+
	2*(centerx*(a.x-p.x)+centery*(a.y-p.y)+centerz*(a.z-p.z)))<0;
}


/*! Check p1, p2 are on the same side of the edge AB or not.*/
inline bool sameSide2D( const Coord& p1, const Coord& p2, 
			const Coord& a, const Coord& b, double epsilon )
{
    double xdiff = b.x-a.x;
    double ydiff = b.y-a.y;
    return ((p1.x-a.x)*ydiff-(p1.y-a.y)*xdiff)*
	((p2.x-a.x)*ydiff-(p2.y-a.y)*xdiff)>=-epsilon;
}


/*!<Only when four points are coplanar. */
inline bool sameSide3D( const Coord3& p1, const Coord3& p2, 
			const Coord3& a, const Coord3& b, double epsilon )
{
    const Coord3 cpp1 = (b-a).cross(p1-a);
    const Coord3 cpp2 = (b-a).cross(p2-a);
    return cpp1.dot(cpp2)>=-epsilon;
}


/*!<Use this function only when the 4 points are all in a plane. */
inline bool pointInTriangle2D( const Coord& p, const Coord& a, const Coord& b, 
			       const Coord& c, double epsilon )
{
    if ( (p.x>a.x && p.x>b.x && p.x>c.x) || (p.x<a.x && p.x<b.x && p.x<c.x) ||
     	 (p.y>a.y && p.y>b.y && p.y>c.y) || (p.y<a.y && p.y<b.y && p.y<c.y) )
	return false;

    return sameSide2D(p,a,b,c,epsilon) && sameSide2D(p,b,a,c,epsilon) && 
	   sameSide2D(p,c,a,b,epsilon);
}


/*!<Only when four points are coplanar. */
inline bool pointInTriangle3D( const Coord3& p, const Coord3& a, 
			const Coord3& b, const Coord3& c, double epsilon )
{
    return sameSide3D(p,a,b,c,epsilon) && sameSide3D(p,b,a,c,epsilon) && 
	   sameSide3D(p,c,a,b,epsilon);
}


/*!< Check to see if the point P is on the edge AB or not.*/
inline bool pointOnEdge2D( const Coord& p, const Coord& a, const Coord& b, 
			   double epsilon )
{
    const Coord pa = p-a;
    const Coord ba = b-a;
    const double t = pa.dot(ba)/ba.sqAbs();
    if ( t<0 || t>1 )
	return false;

    const Coord intersectpt = a+Coord(t*ba.x, t*ba.y);
    const Coord pq = p-intersectpt;
    return pq.sqAbs()<epsilon*epsilon;
}


inline bool pointOnEdge3D( const Coord3& p, const Coord3& a, const Coord3& b, 
			   double epsilon )
{
    const Coord3 pa = p-a;
    const Coord3 ba = b-a;
    const double t = pa.dot(ba)/ba.sqAbs();
    if ( t<0 || t>1 )
	return false;

    const Coord3 pq = pa-t*ba;
    return pq.sqAbs()<epsilon*epsilon;
}


/*!<For point and polygon lie on the same plane only. In 2D case, set all zs'
    to be 0, we also consider the case that the point is exactly on a vertex as
    inside. Use the check that all the angle sum should be 2 Pi. */
inline bool pointInPolygon( const Coord3& pt, const TypeSet<Coord3>& plgknots,
			    double epsilon )
{
    const int nrvertices = plgknots.size();
    if ( nrvertices==2 )
    {
	const double newepsilon = plgknots[0].distTo(plgknots[1])*0.001;
	return pointOnEdge3D( pt, plgknots[0], plgknots[1], newepsilon );
    }
    else if ( nrvertices==3 )
	return pointInTriangle3D( pt, plgknots[0], plgknots[1], plgknots[2],
				  epsilon );
    else
    {
	Coord3 p1, p2;
	double anglesum = 0, cosangle;
	for ( int idx=0; idx<nrvertices; idx++ )
	{
	    p1 = plgknots[idx] - pt;
	    p2 = plgknots[(idx+1)%nrvertices] - pt;
	    
	    const double d1 = p1.abs();
	    const double d2 = p2.abs();
	    if ( d1*d2 <= epsilon*epsilon || d1 <= epsilon || d2 <= epsilon )
		return true;
	    else
		cosangle = p1.dot(p2) / (d1*d2);
	    
	    anglesum += acos( cosangle );
	}
	
	return mIsEqual( anglesum, 6.2831853071795862, 1e-4 );
    }
}


typedef Coord3 Vector3;

/*! \brief
Divides a sphere in a number of vectors, divided by approximately dangle from
each other. dradius is given in radians
*/

TypeSet<Vector3>* makeSphereVectorSet( double dangle );

/*!\brief
Computes an average of a number of vectors using:
1. Summation
2. PCA estimation
*/

Coord3 estimateAverageVector( const TypeSet<Coord3>&, bool normalize,
			      bool checkforundefs );


/*!
\brief Quaternion is an extension to complex numbers.
  
  A Quaternion is represented by the equation:<br>
  q = s + xi + yj + zk <br>
  where: i*i = j*j = k*k = -1.
*/

mExpClass(Algo) Quaternion
{
public:
    			Quaternion(double s,double x,double y,double z);
			Quaternion(const Vector3& axis,float angle);

    void		setRotation(const Vector3& axis,float angle);
    void		getRotation(Vector3& axis,float& angle) const;
    			/*!<\note axis is not normalized. */
    Coord3		rotate(const Coord3&) const;

    Quaternion		operator+(const Quaternion&) const;
    Quaternion& 	operator+=(const Quaternion&);
    Quaternion		operator-(const Quaternion&) const;
    Quaternion& 	operator-=(const Quaternion&);
    Quaternion		operator*(const Quaternion&) const;
    Quaternion& 	operator*=(const Quaternion&);

    Quaternion		inverse() const;

    double		s_;
    Vector3		vec_;
};


/*!
\brief A Line2 is a line on XY-plane, and it is defined in slope-intercept
form y = slope*x + y-intercept; for making operations easier.
*/

mExpClass(Algo) Line2
{
public:			
    			Line2(double slope=0,double intcpt=0);
    			Line2(const Coord&,double slope);
			Line2(const Coord&,const Coord&);

    bool		operator==(const Line2&) const;

    Coord		direction() const;	/*!<Normalized */

    Coord		closestPoint(const Coord& point) const;
    			/*!<\return the point on the line that is closest to
			 	     the given point */

    Coord		intersection(const Line2&,bool checkinlimit=true) const;

    double		distanceTo(const Line2&) const;
    			/*!<Gives distance to another parallel line */
    bool		getParallelLine(Line2& line,double dist) const;
			/*!<Gives a parallel line at a distance dist */
    bool		getPerpendicularLine(Line2& line,const Coord& pt) const;
    			/*!<Gives a perpendicular line through point pt*/
    bool		isOnLine(const Coord& pt) const;

    double		slope_;
    double		yintcpt_;

    bool		isvertical_;		/*!<Parallel to y-axis */
    double		xintcpt_;		/*!<only if isvertical_ true */

    Coord		start_;			/*!<For line-segments only */
    Coord		stop_;			/*!<For line-segments only */
};


/*!
\brief A Line3 is a line in space, with the following equations:
  
  x = x0 + alpha*t
  y = y0 + beta*t
  z = z0 + gamma*t
*/

mExpClass(Algo) Line3
{
public:			
    			Line3();
    			Line3(	double x0, double y0, double z0,
				double alpha, double beta, double gamma );
    			Line3( const Coord3&, const Vector3& );

    Vector3		direction( bool normalize = true ) const
    			{
			    const Vector3 res( alpha_, beta_, gamma_ );
			    return normalize ? res.normalize() : res;
			}

    Coord3		getPoint(double t) const;
    bool		intersectWith( const Plane3&, double& t ) const;
    			/*!<Calculates the intersection between the line
			    and the plane. If success, it sets t. */
    			
 
    double		distanceToPoint( const Coord3& point ) const;
    double		sqDistanceToPoint( const Coord3& point ) const;
    double		closestPoint( const Coord3& point ) const;
    			/*!<\returns the point on the line that is closest to
			 	     the given point */
    void		closestPoint( const Line3& line, double& t_this,
	   			      double& t_line ) const;
    			/*!<\returns the t for the point point on the line
			   	     that is closest to the given line*/
 
    double		x0_;
    double		y0_;
    double		z0_;
    double		alpha_;
    double		beta_;
    double		gamma_;
};


/*!
\brief A Plane3 is a plane in space, with the equation: Ax + By + Cz + D = 0
*/

mExpClass(Algo) Plane3
{
public:
			Plane3();
			Plane3(double, double, double, double);
			Plane3( const Coord3& vectors, const Coord3&,
				bool twovectors );
			/*!<\param twovectors	Specifies if the second argument
			  			is a vector or a position
			*/
			Plane3( const Coord3&, const Coord3&, const Coord3& );
			Plane3( const TypeSet<Coord3>& );

    void		set( const Coord3& vector, const Coord3&,
	    		     bool twovectors );
			/*!<\param twovectors	Specifies if the second argument
			  			is a vector or a position
			*/
    void		set( const Coord3&, const Coord3&, const Coord3& );
    float		set( const TypeSet<Coord3>& );
    			/*!< \returns	a value between 0-1 that indicates how
		     			well the points fit to a plane.
					1 = perfect fit 0 = no fit
			*/

    bool		operator==(const Plane3&) const;
    bool		operator!=(const Plane3&) const;

    Coord3		normal() const { return Coord3( A_, B_, C_ ); }
 
    double		distanceToPoint( const Coord3&,
	    				bool wichside=false ) const;
    			/*!<\param wichside if true, the distance along the
			  	   normal will be returned, wich can be
				   negative.
		        */
    bool		intersectWith( const Line3&, Coord3& ) const;
    			/*!< Returns true if the plane intersects with the
			     line. If it returns true, the Coord3 is set */
    bool		intersectWith( const Plane3&, Line3& ) const;
    			/*!< Returns true if the planes intersects.
			     If it returns true, the Line3 is set */
    Coord3		getProjection(const Coord3& pos);
    bool		onSameSide(const Coord3& p1,const Coord3& p2);
    			/*!<Check p1, p2 are on the same side of the plane or 
			    not, will return true if one is on the plane.*/

    double		A_;
    double		B_;
    double		C_;
    double		D_;
};


/*!
\brief Defines a 2D coordinate system on a 3D plane and transforms between the
3D space and the coordinate system.
*/

mExpClass(Algo) Plane3CoordSystem
{
public:
    			Plane3CoordSystem(const Coord3& normal,
					  const Coord3& origin,
				          const Coord3& pt10);
			/*!<\param normal The normal of the plane
			    \param origin A point on the plane
			    \param pt10   A point on the plane, not identical
			    		  to origin. */
    virtual 		~Plane3CoordSystem() {}
    bool		isOK() const;
    			/*!<\returns false if two identical points were given
			             in the constructor. */

    const Plane3&	plane() const { return plane_; }

    Coord		transform(const Coord3&,bool project) const;
    			/*!<\param project should be true if the coord is
			           not located on the plane. If true, the
				   point will be projected onto the plane. */
			
    Coord3		transform(const Coord&) const;

protected:

    const Plane3	plane_;
    const Coord3	origin_;
    Coord3		vec10_;
    Coord3		vec01_;
    bool		isok_;
};


/*!
\brief Represents a point in spherical coordinates.
The angle phi lies in the horizontal plane, theta in the vertical plane.
*/

mExpClass(Algo) Sphere
{
public:
			Sphere(float r=0,float t=0,float p=0)
			    : radius(r),theta(t),phi(p) {}

			Sphere(const Coord3& crd)
			    : radius((float) crd.x),theta((float) crd.y),
											phi((float) crd.z) {}
    bool		operator ==( const Sphere& s ) const;

    float		radius;
    float		theta;
    float		phi;
};


mGlobal(Algo) Sphere cartesian2Spherical(const Coord3&,bool math);
	    /*!< math=true: transformation done in math-system
		 math=false: transformation done in geo-system */
mGlobal(Algo) Coord3 spherical2Cartesian(const Sphere&,bool math);
	    /*!< math=true: transformation done in math-system
		 math=false: transformation done in geo-system */

inline bool Sphere::operator ==( const Sphere& s ) const
{
    const float dr = radius-s.radius;
    const float dt = theta-s.theta;
    const float dp = phi-s.phi;
    return mIsZero(dr,1e-8) && mIsZero(dt,1e-8) && mIsZero(dp,1e-8);
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef windowfunction_h
#define windowfunction_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Kristofer
 Date:		2007
 RCS:		$Id: windowfunction.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/
 
 
#include "algomod.h"
#include "factory.h"
#include "mathfunc.h"

class IOPar;

/*!
\brief Base class for window functions. The inheriting classes will give a
value between 0 and 1 in the interval -1 to 1. Outside that interval, the
result is zero.
*/

mExpClass(Algo) WindowFunction : public FloatMathFunction
{
public:
    virtual const char*	name() const			= 0;
    virtual bool	hasVariable() const		{ return false; }
    virtual float	getVariable() const		{ return mUdf(float); }
    virtual bool  	setVariable(float)		{ return true; }
    virtual const char*	variableName() const		{ return 0; }

    static const char*	sKeyVariable() 			{ return "Variable"; }

    void		fillPar(IOPar&) const;
    bool		usePar(const IOPar&);

#define mDeclWFStdFns(nm) \
    static void			initClass(); \
    static const char*		sName()		{ return #nm; }\
    static WindowFunction*	create()	{ return new nm##Window; } \
    const char*			name() const	{ return #nm; } \
    float	getValue(float) const; \
    float	getValue( const float* x ) const { return getValue(*x); }

    static void		addAllStdClasses(); // done by Algo/initalgo.cc

};


#define mDeclWFSimpleClass(nm) \
mExpClass(Algo) nm##Window : public WindowFunction \
{ \
public: \
    mDeclWFStdFns(nm); \
};

mDeclWFSimpleClass(Box)
mDeclWFSimpleClass(Hamming)
mDeclWFSimpleClass(Hanning)
mDeclWFSimpleClass(Blackman)
mDeclWFSimpleClass(Bartlett)
mDeclWFSimpleClass(FlatTop)


/*!
\brief Tapered Cosine Window Function.
*/

mExpClass(Algo) CosTaperWindow : public WindowFunction
{
public:

    mDeclWFStdFns(CosTaper)

				CosTaperWindow()	{ setVariable( 0.05 ); }

    bool			hasVariable() const	{ return true; }
    float			getVariable() const	{ return threshold_; }
    bool  			setVariable(float);
    const char*			variableName() const{return "Taper length";}

protected:

    float			threshold_;
    float			factor_;
};


mDefineFactory(Algo,WindowFunction,WINFUNCS);


#endif


