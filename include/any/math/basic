/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef ailayer_h
#define ailayer_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Nov 2010
 RCS:		$Id: ailayer.h 30923 2013-07-26 12:46:09Z arnaud.huck@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "commondefs.h"
#include "math.h"
#include "sets.h"

/*!
\brief Acoustic Impedance layer.
*/


mExpClass(Basic) AILayer
{
public:
		AILayer( float thkness, float vel, float den )
		    : thickness_(thkness), vel_(vel), den_(den)	{}
    bool	operator ==( const AILayer& p ) const
		{ return thickness_ == p.thickness_; }
    
    float	thickness_, vel_, den_;
    float	getAI() const;
    

};


typedef TypeSet<AILayer> AIModel;

mGlobal(Basic) float getLayerDepth( const AIModel& mod, int layer );



/*!
\brief A table of elastic prop layers.
*/

mExpClass(Basic) ElasticLayer : public AILayer
{
public:
		ElasticLayer( float thkness, float pvel, float svel, float den )
		    : AILayer(thkness,pvel,den), svel_(svel) {}
		ElasticLayer(const AILayer& ailayer)
		    : AILayer(ailayer), svel_(mUdf(float)) {}

    bool	operator ==( const ElasticLayer& p ) const
		{ return thickness_ == p.thickness_; }

    float	svel_;
    float	getSI() const;
};


/*!\brief A table of elastic prop layers with processing utilities*/
mExpClass(Basic) ElasticModel : public TypeSet<ElasticLayer>
{
public:

		/*! ensures a model does not have layers below a given thickness
		  last layer may not comply though */

    void	upscale(float maxthickness);

		/*! Smashes every consecutive set of nblock layers
		  into one output layer */

    void	upscaleByN(int nblock);

		/*! Ensures that all layers in the elastic model are not thicker
		    than a maximum thickness. Splits the blocks if necessary */

    void	setMaxThickness(float maxthickness);

    		/*! Merged consecutive layers with same properties. */

    void	mergeSameLayers();

		/*! Block elastic model so that no blocks have larger difference
		  than the threshold. Attempts will be made to put boundaries at
		  large changes.
		  \param pvelonly Will use density and SVel as well if false */

    void	block(float relthreshold,bool pvelonly);

		/*! compute an upscaled elastic layer from an elastic model
		  using simple weighted averaging.
		  The thickness of the input and output remains constant.
		  returns false if the input model contain not a single valid
		  input layer */

    bool	getUpscaledByThicknessAvg(ElasticLayer& outlay) const;

		/* computes an upscaled elastic layer from an elastic model
		   using backus upscaling method. The thickness of the input and
		   output remains constant.
		   returns false if the input model contain not a single valid
		   input layer
		   \param theta Incidence angle in radians */

    bool	getUpscaledBackus(ElasticLayer& outlay,float theta=0.) const;


    		// Legacy functions, do not use
public:
    void	upscale( float maxthickness, ElasticModel& outmdl )
				{ outmdl.upscale( maxthickness ); }
    void	upscaleByN( int nblock, ElasticModel& outmdl )
				{ outmdl.upscaleByN( nblock ); }
    void	block( float relthreshold, bool pvelonly, ElasticModel& outmdl )
				{ outmdl.block( relthreshold, pvelonly ); }
    bool	upscaleByThicknessAvg( ElasticModel& inmdl,ElasticLayer& outlay)
			{ return inmdl.getUpscaledByThicknessAvg( outlay ); }
    bool	upscaleBackus( ElasticModel& inmdl, ElasticLayer& outlay,
	    		       float theta=0. )
			{ return inmdl.getUpscaledBackus( outlay, theta ); }
    void	setMaxThickness( float maxthickness, ElasticModel& outmdl )
				{ outmdl.setMaxThickness( maxthickness ); }
    void	mergeSameLayers( ElasticModel& outmdl )
				{ outmdl.mergeSameLayers(); }

};

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef arraynd_h
#define arraynd_h
/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		9-3-1999
 RCS:		$Id: arraynd.h 29753 2013-05-13 10:45:51Z bert.bril@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "valseries.h"
#include "arrayndinfo.h"
#include "varlenarray.h"
#include "odmemory.h"
#include "ptrman.h"
#include <string.h>

#define mPolyArray1DInfoTp mPolyRet(ArrayNDInfo,Array1DInfo)
#define mPolyArray2DInfoTp mPolyRet(ArrayNDInfo,Array2DInfo)
#define mPolyArray3DInfoTp mPolyRet(ArrayNDInfo,Array3DInfo)

/*!
\brief An ArrayND is an array with a given number of dimensions and a size.

  The ArrayND can be accessed via set() and get().
  
  The ArrayND can give away a pointer to its storage, but there is no
  guarantee that it will. If no pointer is given, the user can copy the
  ArrayND by constructing an ArrayNDImpl with the original array as an argument
  to the constructor.
*/

template <class T>
mClass(Basic) ArrayND 
{
public:

    virtual				~ArrayND()	{}

    virtual inline bool			isOK() const;
    virtual inline bool			isEmpty() const;

    virtual T	                	getND(const int*) const	= 0;
    virtual bool			isSettable() const	{ return true; }
    virtual void			setND(const int*,T)	= 0;

    inline const ValueSeries<T>*	getStorage() const
					{ return getStorage_(); }
    inline ValueSeries<T>*		getStorage();
    virtual bool			canSetStorage() const { return false; }
    virtual bool			setStorage(ValueSeries<T>* s)
    					{ delete s; return true; }
    					/*!<becomes mine. The size must be
					    settable, or I return false. */

    inline const T*			getData() const
					{ return getData_(); }
    inline T*				getData();
    virtual const T*			get1D(const int*) const;
    virtual T*				get1D(const int*);
    virtual int				get1DDim() const;


    virtual const ArrayNDInfo&		info() const		= 0;
    virtual bool			canSetInfo() const
    					{ return false; }
    virtual bool			canChangeNrDims() const
    					{ return false; }
    virtual bool			setInfo( const ArrayNDInfo& )
					{ return false; }

    virtual void			setAll(T);
    virtual void			getAll(T* ptr) const;
    					/*!<Fills ptr with values from array.
					    ptr is assumed to be allocated
					    with info().getTotalSz() number
					    of values. */
    virtual void			getAll(ValueSeries<T>& vs) const;
    					/*!<Fills vs with values from array.
					    ptr is assumed to be allocated
					    with info().getTotalSz() number
					    of values. */

protected:
 
    virtual const ValueSeries<T>* getStorage_() const { return 0; }

    virtual const T*		getData_() const
				{
				    if ( getStorage_() )
					return getStorage()->arr();
				    return 0;
				}

};


/*!
\brief Array1D ( Subclass of ArrayND ) is a one dimensional array.
*/

template <class T>
mClass(Basic) Array1D : public ArrayND<T>
		      , public ValueSeries<T>
{
public: 

    virtual void		set(int,T)				= 0;
    virtual T			get(int) const				= 0;
    void			setND(const int* pos,T v) { set( pos[0], v ); }
    T	                	getND(const int* pos) const {return get(pos[0]);}

				// implement ValueSeries interface
    T				value(od_int64 i) const	{ return get( (int) i); }
    bool			writable() const	{ return true; }
    void			setValue(od_int64 i,T t){ set( (int) i,t); }
    virtual void		setAll( T t )         { ArrayND<T>::setAll(t); }

    virtual const Array1DInfo&	info() const = 0;

    inline T			operator []( int idx ) const
				{ return get( idx ); }

};


/*!
\brief Array2D ( Subclass of ArrayND ) is a two dimensional array.
*/

template <class T>
mClass(Basic) Array2D : public ArrayND<T>
{
public: 
    virtual void		set( int, int, T ) 			= 0;
    virtual T        		get( int p0, int p1 ) const		= 0;
    void			setND(  const int* pos, T v )
				    { set( pos[0], pos[1], v);}
    T		                getND( const int* pos ) const
				    { return get( pos[0], pos[1] ); }

    virtual const Array2DInfo&	info() const = 0;
};


/*!
\brief Array3D ( Subclass of ArrayND ) is a three dimensional array.
*/

template <class T>
mClass(Basic) Array3D : public ArrayND<T>
{
public: 

    virtual void		set( int, int, int, T ) 		= 0;
    virtual T        		get( int p0, int p1, int p2 ) const	= 0;
    void			setND( const int* pos, T v )
				    { set( pos[0], pos[1], pos[2], v);}
    T		                getND( const int* pos ) const
				    { return get( pos[0], pos[1], pos[2] ); }

    virtual const Array3DInfo&	info() const = 0;
};


/*!
\brief Iterates through all samples in an ArrayND.
  
  ArrayNDIter will be on the first position when initiated, and move to
  the second at the first call to next(). next() will return false when
  no more positions are available.
*/

mExpClass(Basic) ArrayNDIter
{
public:
				ArrayNDIter( const ArrayNDInfo& );
				~ArrayNDIter();

    bool			next();
    void			reset();

    template <class T> void inline setPos(const T& idxabl);
    const int*			getPos() const { return position_; }
    int				operator[](int) const;

protected:

    bool			inc(int);

    int*			position_;
    const ArrayNDInfo&		sz_;

};

#define mArrayNDVSAdapterNrDim 20


/*!
\brief Adapter that makes any ArrayND to a (slow) value series.

  Try using other methods (like getting the storage) as this is slow.
*/

template <class T>
mClass(Basic) ArrayNDValseriesAdapter : public ValueSeries<T>
{
public:
			ArrayNDValseriesAdapter( const ArrayND<T>& a )
			    : array_( a )
			{
			    if ( array_.getData() || array_.getStorage() )
			    {
				pErrMsg("Not a good idea to use adapter. "
					"Use getStorage() instead");
			    }
			}
    
    bool		isOK() const
			{
			    if ( array_.info().getNDim()>mArrayNDVSAdapterNrDim)
			    {
				pErrMsg( "Too many dimensions");
				return false;
			    }
			    
			    return true;
			}
			
    ValueSeries<T>*	clone() const
			{ return new ArrayNDValseriesAdapter<T>( *this ); }
    
    T			value(od_int64 idx) const
			{
			    int pos[mArrayNDVSAdapterNrDim];
			    array_.info().getArrayPos( idx, pos );
			    return array_.getND( pos );
			}
    
    const T*		arr() const { return array_.getData(); }
    T*			arr() { return 0; }
    
protected:

    const ArrayND<T>&	array_;
};


template <class T> inline void ArrayNDIter::setPos( const T& idxable )
{
    for ( int idx=sz_.getNDim()-1; idx>=0; idx-- )
	position_[idx] = idxable[idx];
}


#define mDefArrayNDConverter(nd) \
template <class T, class TT> \
class Array##nd##Conv : public Array##nd<T> \
{ \
public: \
 \
    			Array##nd##Conv(Array##nd<TT>* arr) \
			    : arr_(arr)	{} \
    			~Array##nd##Conv()	{ delete arr_; } \
 \
    const Array##nd##Info&	info() const	{ return arr_->info(); } \
 \
protected: \
 \
    Array##nd<TT>*	arr_; \
 \
public:


mDefArrayNDConverter(1D)

    T        		get( int p0 ) const
    					{ return (T)arr_->get( p0 ); }
    void		set( int p0, T v )
    					{ arr_->set( p0, (TT)v ); }

};

mDefArrayNDConverter(2D)

    T        		get( int p0, int p1 ) const
    					{ return (T)arr_->get( p0, p1 ); }
    void		set( int p0, int p1, T v )
    					{ arr_->set( p0, p1, (TT)v ); }

};

mDefArrayNDConverter(3D)

    T        		get( int p0, int p1, int p2 ) const
    					{ return (T)arr_->get( p0, p1, p2 ); }
    void		set( int p0, int p1, int p2, T v )
    					{ arr_->set( p0, p1, p2, (TT)v ); }

};


// Only implementations below

template <class T> inline
bool ArrayND<T>::isOK() const
{
    return getStorage() ? getStorage()->isOK() : true;
}


template <class T> inline
bool ArrayND<T>::isEmpty() const
{
    return !isOK() || info().getTotalSz() == 0;
}


template <class T> inline
const T* ArrayND<T>::get1D( const int* i ) const
{
    const T* ptr = getData();
    if ( !ptr ) return 0;

    int ndim = info().getNDim();

    ArrPtrMan<int> pos = new int[ndim];
    memcpy(pos,i, (int) sizeof(int)*(ndim-1));

    pos[ndim-1] = 0;
    
    return &ptr[info().getOffset( pos )];
}


template <class T> inline
int ArrayND<T>::get1DDim() const
{ return info().getNDim()-1; }


template <class T> inline
T* ArrayND<T>::getData()
{
    return !isSettable() ? 0
			 : const_cast<T*>(((const ArrayND*)this)->getData_());
}


template <class T> inline
ValueSeries<T>* ArrayND<T>::getStorage()
{
    return !isSettable() ? 0 : 
	const_cast<ValueSeries<T>* >(((const ArrayND*)this)->getStorage_());
}


template <class T> inline
T* ArrayND<T>::get1D( const int* i )
{
    return !isSettable() ? 0 : const_cast<T*>(((const ArrayND*)this)->get1D(i));
}


template <class T> inline
void ArrayND<T>::setAll( T val )
{
    ValueSeries<T>* stor = getStorage();
    if ( stor )
    {
	if ( stor->canSetAll() )
	    stor->setAll( val );
	else
	{
	    MemSetter<T> setter( *stor, val, info().getTotalSz() );
	    setter.execute();
	}

	return;
    }

    ArrayNDIter iterator( info() );
    do
    {
	setND( iterator.getPos(), val );
    } while ( iterator.next() );
}

/*!
\brief Gets a one dimensional array from an ArrayND.
*/

template <class T>
mClass(Basic) ArrayNDGetAll : public ParallelTask
{
public:
    		ArrayNDGetAll( T* ptr, const ArrayND<T>& arr )
		    : ptr_( ptr )
		    , arr_( arr )
		    , totalnr_( arr.info().getTotalSz() )
		    , vs_( 0 )
		{}

    		ArrayNDGetAll( ValueSeries<T>& vs, const ArrayND<T>& arr )
		    : ptr_( vs.arr() )
		    , arr_( arr )
		    , totalnr_( arr.info().getTotalSz() )
		    , vs_( vs.arr() ? 0 : &vs )
		{}

    bool	doWork( od_int64 start, od_int64 stop, int )
		{
		    mAllocVarLenArr( int, pos, arr_.info().getNDim() );
		    if ( !arr_.info().getArrayPos( start, pos ) )
			return false;

		    ArrayNDIter iterator( arr_.info() );
		    iterator.setPos( (int*) pos );

		    if ( vs_ )
		    {
			for ( od_int64 idx=start; idx<=stop; idx++ )
			{
			    vs_->setValue( idx,
				    arr_.getND( iterator.getPos() ) );
			    if ( idx==stop )
				break;

			    if ( !iterator.next() )
				return false;
			}
		    }
		    else
		    {
			T* res = ptr_ + start;
			for ( od_int64 idx=start; idx<=stop; idx++, res++ )
			{
			    *res = arr_.getND( iterator.getPos() );
			    if ( idx==stop )
				break;

			    if ( !iterator.next() )
				return false;
			}
		    }

		    return true;
		}
		    
    od_int64	nrIterations() const { return totalnr_; }
protected:

    od_int64		totalnr_;
    const ArrayND<T>&	arr_;
    T*			ptr_;
    ValueSeries<T>*	vs_;
};


template <class T> inline
void ArrayND<T>::getAll( ValueSeries<T>& vs ) const
{
    if ( vs.arr() )
    {
	getAll( vs.arr() );
	return;
    }

    const od_int64 totalsz = info().getTotalSz();
    if ( !totalsz )
	return;

    const ValueSeries<T>* stor = getStorage();
    if ( stor )
    {
	stor->getValues( vs, totalsz );
	return;
    }

    ArrayNDGetAll<T> getter( vs, *this );
    getter.execute();
}


template <class T> inline
void ArrayND<T>::getAll( T* ptr ) const
{
    const od_int64 totalsz = info().getTotalSz();
    if ( !totalsz )
	return;

    const T* tp = getData();
    if ( tp )
    {
	MemCopier<T> cpier( ptr, tp, totalsz );
	cpier.execute();
	return;
    }

    const ValueSeries<T>* stor = getStorage();
    if ( stor )
    {
	MemCopier<T> cpier( ptr, *stor, totalsz );
	cpier.execute();
	return;
    }

    ArrayNDGetAll<T> getter( ptr, *this );
    getter.execute();
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef arrayndfilestor_h
#define arrayndfilestor_h
/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		9-3-1999
 RCS:		$Id: arrayndfilestor.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/


#include "arraynd.h"
#include "envvars.h"
#include <fstream>

#define mArrNDChunkSz 1024


/*!
\brief ArrayND I/O from/to a file.
*/

template <class T>
mClass(Basic) ArrayNDFileStor : public ValueSeries<T>
{
public:

    inline bool		isOK() const;
    inline T		value( od_int64 pos ) const;
    inline void		setValue( od_int64 pos, T val );
    inline const T*	arr() const				{ return 0; }
    inline T*		arr()					{ return 0; }

    inline bool		setSize( od_int64 nsz );
    inline od_int64	size() const				{ return sz_; }

    inline		ArrayNDFileStor( od_int64 nsz );
    inline		ArrayNDFileStor();
    inline		~ArrayNDFileStor();

    inline void		setTempStorageDir( const char* dir );
private:

    inline void		open();
    inline void		close();

protected:

    std::fstream*		strm_;
    BufferString		name_;
    od_int64			sz_;
    bool			openfailed_;
    bool			streamfail_;
    mutable Threads::Mutex	mutex_;

};


template <class T> inline
bool ArrayNDFileStor<T>::isOK() const
{ return strm_; }


#define mArrNDChkStrm() \
    if ( strm_->fail() ) \
    { \
	const_cast<ArrayNDFileStor*>(this)->close(); \
	const_cast<ArrayNDFileStor*>(this)->streamfail_ = true; \
	return T(); \
    }

template <class T> inline
T ArrayNDFileStor<T>::value( od_int64 pos ) const
{
    Threads::MutexLocker mlock( mutex_ );
    if ( !strm_ ) const_cast<ArrayNDFileStor*>(this)->open();
    if ( !strm_ ) return T();

    strm_->seekg(pos*sizeof(T), std::ios::beg );
    mArrNDChkStrm()

    T res;
    strm_->read( (char *)&res, sizeof(T));
    mArrNDChkStrm()

    return res;
}

#undef mArrNDChkStrm
#define mArrNDChkStrm() \
    if ( strm_->fail() ) { close(); streamfail_ = true; return; }

template <class T> inline
void ArrayNDFileStor<T>::setValue( od_int64 pos, T val ) 
{
    Threads::MutexLocker mlock( mutex_ );
    if ( !strm_ ) open();
    if ( !strm_ ) return;

    strm_->seekp( pos*sizeof(T), std::ios::beg );
    mArrNDChkStrm()

    strm_->write( (const char *)&val, sizeof(T));
    mArrNDChkStrm()
}


template <class T> inline
bool ArrayNDFileStor<T>::setSize( od_int64 nsz )
{
    Threads::MutexLocker mlock( mutex_ );
    if ( strm_ ) close();
    sz_ = nsz;
    openfailed_ = streamfail_ = false;
    open();
    return strm_;
}


template <class T> inline
ArrayNDFileStor<T>::ArrayNDFileStor( od_int64 nsz )
    : sz_( nsz )
    , strm_( 0 )
    , name_(FilePath::getTempName("dat"))
    , openfailed_(false)
    , streamfail_(false)
{
    const char* stordir = GetEnvVar( "OD_ARRAY_TEMP_STORDIR" );
    if ( stordir )
	setTempStorageDir( stordir );
}


template <class T> inline
ArrayNDFileStor<T>::~ArrayNDFileStor()
{
    Threads::MutexLocker mlock( mutex_ );
    if ( strm_ ) close();
    File_remove( name_.buf(), mFile_NotRecursive );
}


template <class T> inline
void ArrayNDFileStor<T>::setTempStorageDir( const char* dir )
{
    close();
    File_remove( name_.buf(), mFile_NotRecursive );
    FilePath fp( name_.buf() );
    fp.setPath( File_isDirectory(dir) && File_isWritable(dir) ? dir : "/tmp/" );
    name_ = fp.fullPath();
}

#undef mArrNDChkStrm
#define mArrNDChkStrm() \
    if ( strm_->fail() ) { close(); openfailed_ = streamfail_ = true; return; }

template <class T> inline
void ArrayNDFileStor<T>::open()
{
    if ( strm_ ) close();
    else if ( openfailed_ || streamfail_ ) return;

    strm_ = new std::fstream( name_.buf(), std::fstream::binary
				     | std::fstream::out
				     | std::fstream::trunc );
    mArrNDChkStrm()

    char tmp[mArrNDChunkSz*sizeof(T)];
    memset( tmp, 0, mArrNDChunkSz*sizeof(T) );
    for ( int idx=0; idx<sz_; idx+=mArrNDChunkSz )
    {
	if ( (sz_-idx)/mArrNDChunkSz )
	    strm_->write( tmp, mArrNDChunkSz*sizeof(T) );
	else if ( sz_-idx )
	    strm_->write( tmp, (sz_-idx)*sizeof(T) );

	mArrNDChkStrm()
    }

    strm_->close();
    strm_->open( name_.buf(), std::fstream::binary
		    | std::fstream::out | std::fstream::in );
    mArrNDChkStrm()
}

template <class T> inline
void ArrayNDFileStor<T>::close()
{
    if ( strm_ ) strm_->close();
    delete strm_; strm_ = 0;
}


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef arrayndimpl_h
#define arrayndimpl_h
/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		9-3-1999
 RCS:		$Id: arrayndimpl.h 30315 2013-06-14 13:47:40Z bert.bril@dgbes.com $
________________________________________________________________________

*/


#include "arraynd.h"

#ifdef __debug__
# include "debug.h"
#endif

#define mDeclArrayNDProtMemb(inftyp) \
    inftyp			in_; \
    ValueSeries<T>*		stor_; \
 \
    const ValueSeries<T>*	getStorage_() const { return stor_; }

#define mDeclArrayNDCopyTools(nd) \
    inline			Array##nd##Impl(const Array##nd<T>&); \
    inline			Array##nd##Impl(const Array##nd##Impl<T>&); \
    inline Array##nd##Impl<T>&	operator =( const Array##nd<T>& ai ) \
				{ copyFrom(ai); return *this; } \
    inline Array##nd##Impl<T>&	operator =( const Array##nd##Impl<T>& ai ) \
				{ copyFrom(ai); return *this; } \
    inline bool			setStorageNoResize(ValueSeries<T>*);


/*!
\brief Implementation of Array1D.
*/

template <class T>
mClass(Basic) Array1DImpl : public Array1D<T>
{
public:

    inline			Array1DImpl(int sz);
    inline			~Array1DImpl();
    				mDeclArrayNDCopyTools(1D);

    ValueSeries<T>*		clone() const
    				{ return new Array1DImpl<T>(*this); }
    		
    inline bool			isOK() const { return stor_ && stor_->isOK(); }
    inline void			copyFrom(const Array1D<T>&);
    inline bool			setStorage(ValueSeries<T>*);
    inline bool			canSetStorage() const	{ return true; }

    inline void			set(int pos,T);
    inline T			get(int pos) const;
			
    inline const Array1DInfo&	info() const		{ return in_; }
    inline bool			canSetInfo() const	{ return true; }
    inline bool			setInfo(const ArrayNDInfo&);
    inline bool			setSize(int);
    inline bool			setSize( od_int64 sz )
    				{ return setSize( ((int)sz) ); }

				// ValueSeries interface
    inline T*			arr()			{ return ptr_; }
    inline const T*		arr() const		{ return ptr_; }

protected:
    inline const T*		getData_() const	{ return ptr_; }
    T*				ptr_;	//not owned, only a shortcut
    					//for the 99% percent case

    mDeclArrayNDProtMemb(Array1DInfoImpl);

};


/*!
\brief Implementation of Array2D.
*/

template <class T>
mClass(Basic) Array2DImpl : public Array2D<T>
{
public:
			Array2DImpl(int sz0,int sz1);
			Array2DImpl(const Array2DInfo&);
			~Array2DImpl();
			mDeclArrayNDCopyTools(2D)

    inline bool		isOK() const { return stor_ && stor_->isOK(); }
    bool		canSetStorage() const		{ return true; }
    bool		setStorage(ValueSeries<T>*);

    virtual void	set(int,int,T);
    virtual T		get(int,int) const;
    void		copyFrom(const Array2D<T>&);

    inline const Array2DInfo& info() const		{ return in_; }
    inline bool		canSetInfo() const		{ return true; }

    bool		setInfo(const ArrayNDInfo&);
    bool		setSize(int,int);

protected:

    inline const T*		getData_() const	{ return ptr_; }
    T*				ptr_;	//not owned, only a shortcut
    					//for the 99% percent case

    mDeclArrayNDProtMemb(Array2DInfoImpl);

};


/*!
\brief Implementation of Array3D.
*/

template <class T>
mClass(Basic) Array3DImpl : public Array3D<T>
{
public:
    inline		Array3DImpl(int sz0,int sz1,int sz2);
    inline		Array3DImpl(const Array3DInfo&);
			mDeclArrayNDCopyTools(3D)
    inline		~Array3DImpl();

    inline bool		isOK() const { return stor_ && stor_->isOK(); }
    inline bool		canSetStorage() const	{ return true; }
    inline bool		setStorage(ValueSeries<T>*);

    inline void		set(int,int,int,T);
    inline T		get(int,int,int) const;
    inline void		copyFrom(const Array3D<T>&);

    inline const Array3DInfo& info() const		{ return in_; }
    inline bool		canSetInfo() const		{ return true; }
    inline bool		setInfo(const ArrayNDInfo&);
    inline bool		setSize(int,int,int);

protected:
    inline const T*	getData_() const	{ return ptr_; }
    T*			ptr_;	//not owned, only a shortcut
    					//for the 99% percent case

    mDeclArrayNDProtMemb(Array3DInfoImpl);
};


/*!
\brief Implementation of ArrayND.
*/

template <class T>
mClass(Basic) ArrayNDImpl : public ArrayND<T>
{
public:

    static ArrayND<T>*		create(const ArrayNDInfo& nsz);

    inline			ArrayNDImpl(const ArrayNDInfo&);
				mDeclArrayNDCopyTools(ND)
    inline			~ArrayNDImpl();

    inline bool			isOK() const { return stor_ && stor_->isOK(); }
    inline bool			canSetStorage() const	{ return true; }
    inline bool			setStorage(ValueSeries<T>*);

    inline void			setND(const int*,T);
    inline T			getND(const int*) const;

    inline const ArrayNDInfo&	info() const		{ return *in_; }
    inline bool			canSetInfo() const	{ return true; }
    inline bool			canChangeNrDims() const	{ return true; }
    inline bool			setInfo(const ArrayNDInfo&);
 
    inline bool			setSize(const int*);
    inline void			copyFrom(const ArrayND<T>&);

protected:

    inline const T*		getData_() const	{ return ptr_; }
    T*				ptr_;	//not owned, only a shortcut
    					//for the 99% percent case

    mDeclArrayNDProtMemb(ArrayNDInfo*)

}; 


#define mArrNDImplCreateStor \
    setStorageNoResize( (ValueSeries<T>*)new MultiArrayValueSeries<T,T>( \
					info().getTotalSz()))
#define mArrayNDImplSetSize(s) \
    if ( !stor_ ) \
	mArrNDImplCreateStor; \
    if ( !stor_ || !stor_->setSize(s) ) \
	{ ptr_ = 0; delete stor_; stor_ = 0; return false; } \
    ptr_ = stor_->arr()

#define mArrNDImplConstructor \
    , stor_(0) \
    , ptr_(0) \
{ \
    if ( !info().isOK() ) return; \
    mArrNDImplCreateStor; \
}

#define mArrNDImplCopyConstructor(clss,from) \
template <class T> inline \
clss<T>::clss( const from<T>& templ ) \
    : in_(templ.info())  \
    , stor_(0) \
    , ptr_(0) \
{ \
    const ValueSeries<T>* storage = templ.getStorage(); \
    ValueSeries<T>* newstor = storage && storage->selfSufficient() \
    	? storage->clone() \
	: 0; \
    if ( !newstor || !setStorageNoResize( newstor ) )  \
    { \
	if ( !info().isOK() ) \
	{ \
	    pErrMsg( "Invalid size" ); \
	    return; \
	} \
	setStorageNoResize( \
		new MultiArrayValueSeries<T,T>(info().getTotalSz()) ); \
	copyFrom( templ ); \
    } \
}

#define mArrNDImplDestructor( clss ) \
	template <class T> inline clss<T>::~clss() { delete stor_; }

#define mArrNDImplSetStorage( clss ) \
template <class T> inline \
bool clss<T>::setStorage( ValueSeries<T>* s ) \
{ \
    ptr_ = 0; \
    if ( !s->setSize(info().getTotalSz()) ) \
    { \
	delete s; \
	return false; \
    } \
    return setStorageNoResize( s ); \
} \
 \
 \
template <class T> inline \
bool clss<T>::setStorageNoResize( ValueSeries<T>* s ) \
{ \
    ptr_ = 0; \
    delete stor_; stor_ = s; ptr_ = stor_->arr(); \
    return true; \
}

#define mArrNDImplDoNormalCopy \
    if ( !this->isOK() ) \
	return; \
    if ( this->getData() ) \
    { \
	templ.getAll( this->getData() ); \
	return; \
    } \
    else if ( this->getStorage() ) \
    { \
	templ.getAll( *this->getStorage() ); \
	return; \
    }
#define mArrNDImplHandleNormalCopy(inf) \
    if ( inf != templ.info() ) \
	setInfo( templ.info() ); \
    mArrNDImplDoNormalCopy; \


template <class T> inline
Array1DImpl<T>::Array1DImpl( int nsz )
    : in_(nsz)
mArrNDImplConstructor
mArrNDImplCopyConstructor(Array1DImpl,Array1D)
mArrNDImplCopyConstructor(Array1DImpl,Array1DImpl)
mArrNDImplDestructor( Array1DImpl )
mArrNDImplSetStorage( Array1DImpl )

template <class T> inline
void Array1DImpl<T>::set( int pos, T v )	
{
#ifdef __debug__
    if ( !in_.validPos( pos ) )
	{ pErrMsg("Invalid access"); DBG::forceCrash(true); }
#endif
    if ( ptr_ ) ptr_[pos] = v;
    else stor_->setValue(pos,v);
}


template <class T> inline
T Array1DImpl<T>::get( int pos ) const
{
#ifdef __debug__
    if ( !in_.validPos( pos ) )
	{ pErrMsg("Invalid access"); DBG::forceCrash(true); }
#endif
    return ptr_ ? ptr_[pos] : stor_->value(pos);
}


template <class T> inline
void Array1DImpl<T>::copyFrom( const Array1D<T>& templ )
{
    mArrNDImplHandleNormalCopy(in_)

    const int totsz = (int) in_.getTotalSz();

    for ( int idx=0; idx<totsz; idx++ )
	set( idx, templ.get(idx) );
}


template <class T> inline
bool Array1DImpl<T>::setInfo( const ArrayNDInfo& ni )
{
    if ( ni.getNDim() != 1 ) return false; 
    return setSize( ni.getSize(0) );
}


template <class T> inline
bool Array1DImpl<T>::setSize( int s )
{
    in_.setSize( 0, s );
    mArrayNDImplSetSize( s );
    return true;
}


template <class T> inline
Array2DImpl<T>::Array2DImpl( int sz0, int sz1 )
    : in_(sz0,sz1)
mArrNDImplConstructor
template <class T> inline
Array2DImpl<T>::Array2DImpl( const Array2DInfo& nsz )
    : in_( nsz )
mArrNDImplConstructor
mArrNDImplCopyConstructor(Array2DImpl,Array2D)
mArrNDImplCopyConstructor(Array2DImpl,Array2DImpl)
mArrNDImplDestructor(Array2DImpl)
mArrNDImplSetStorage(Array2DImpl)


template <class T> inline
void Array2DImpl<T>::set( int p0, int p1, T v )
{
#ifdef __debug__
    if ( !in_.validPos( p0, p1 ) )
    {
	pErrMsg("Invalid access");
	DBG::forceCrash(true);
    }
#endif
    const od_int64 offset = in_.getOffset( p0, p1 );
    if ( ptr_ ) ptr_[offset] = v;
    else stor_->setValue( offset, v );
}


template <class T> inline
T Array2DImpl<T>::get( int p0, int p1 ) const
{
#ifdef __debug__
    if ( !in_.validPos( p0, p1 ) )
    {
	pErrMsg("Invalid access");
	DBG::forceCrash(true);
    }
#endif
    const od_int64 offset = in_.getOffset( p0, p1 );
    return ptr_ ? ptr_[offset] : stor_->value( offset );
}


template <class T> inline
void Array2DImpl<T>::copyFrom( const Array2D<T>& templ )
{
    mArrNDImplHandleNormalCopy(in_)

    const int sz0 = in_.getSize(0);
    const int sz1 = in_.getSize(1);
    for ( int id0=0; id0<sz0; id0++ )
    {
	for ( int id1=0; id1<sz1; id1++ )
	    set( id0, id1, templ.get(id0,id1) );
    }
}


template <class T> inline
bool Array2DImpl<T>::setInfo( const ArrayNDInfo& ni )
{
    if ( ni.getNDim() != 2 ) return false; 
    return setSize( ni.getSize(0), ni.getSize(1) );
}


template <class T> inline
bool Array2DImpl<T>::setSize( int d0, int d1 )
{
    in_.setSize( 0, d0 ); in_.setSize( 1, d1 );
    mArrayNDImplSetSize( in_.getTotalSz() );
    return true;
}


template <class T> inline
Array3DImpl<T>::Array3DImpl( int sz0, int sz1, int sz2 )
    : in_(sz0,sz1,sz2)
mArrNDImplConstructor
template <class T> inline
Array3DImpl<T>::Array3DImpl( const Array3DInfo& nsz )
    : in_(nsz)
mArrNDImplConstructor
mArrNDImplCopyConstructor(Array3DImpl,Array3D)
mArrNDImplCopyConstructor(Array3DImpl,Array3DImpl)
mArrNDImplDestructor(Array3DImpl)
mArrNDImplSetStorage(Array3DImpl)

template <class T> inline
void Array3DImpl<T>::set( int p0, int p1, int p2, T v )
{
#ifdef __debug__
    if ( !in_.validPos( p0, p1, p2 ) )
	{ pErrMsg("Invalid access"); DBG::forceCrash(true); }
#endif
    const od_int64 offset = in_.getOffset( p0, p1, p2 );
    if ( ptr_ ) ptr_[offset] = v;
    else stor_->setValue( offset, v );
}


template <class T> inline
T Array3DImpl<T>::get( int p0, int p1, int p2 ) const
{
#ifdef __debug__
    if ( !in_.validPos( p0, p1, p2 ) )
	{ pErrMsg("Invalid access"); DBG::forceCrash(true); }
#endif
    const od_int64 offset = in_.getOffset( p0, p1, p2 );
    return ptr_ ? ptr_[offset] : stor_->value( offset );
}


template <class T> inline
void Array3DImpl<T>::copyFrom( const Array3D<T>& templ )
{
    mArrNDImplHandleNormalCopy(in_)

    int sz0 = in_.getSize(0);
    int sz1 = in_.getSize(1);
    int sz2 = in_.getSize(2);
    for ( int id0=0; id0<sz0; id0++ )
	for ( int id1=0; id1<sz1; id1++ )
	    for ( int id2=0; id2<sz2; id2++ )
		set( id0, id1, id2, templ.get(id0,id1,id2) );
}


template <class T> inline
bool Array3DImpl<T>::setInfo( const ArrayNDInfo& ni )
{
    if ( ni.getNDim() != 3 ) return false; 
    return setSize( ni.getSize(0), ni.getSize(1), ni.getSize(2) );
}


template <class T> inline
bool Array3DImpl<T>::setSize( int d0, int d1, int d2 )
{
    in_.setSize( 0, d0 ); in_.setSize( 1, d1 ); in_.setSize( 2, d2 );
    mArrayNDImplSetSize( in_.getTotalSz() );
    return true;
}


#undef mArrNDImplCopyConstructor
#define mArrNDImplCopyConstructor(clss,from) \
template <class T> inline \
clss<T>::clss( const from<T>& templ ) \
    : in_(templ.info().clone())  \
    , stor_(0) \
    , ptr_(0) \
{ \
    if ( !info().isOK() ) \
    { \
	pErrMsg( "Invalid size" ); \
	return; \
    } \
    setStorage( new MultiArrayValueSeries<T,T>(in_->getTotalSz()) ); \
    copyFrom( templ ); \
}

template <class T> inline
ArrayNDImpl<T>::ArrayNDImpl( const ArrayNDInfo& nsz )
    : in_(nsz.clone())
mArrNDImplConstructor
mArrNDImplCopyConstructor(ArrayNDImpl,ArrayND)
mArrNDImplCopyConstructor(ArrayNDImpl,ArrayNDImpl)
template <class T> inline ArrayNDImpl<T>::~ArrayNDImpl()
{ delete stor_; delete in_; }

mArrNDImplSetStorage( ArrayNDImpl )

template <class T> inline
void ArrayNDImpl<T>::copyFrom( const ArrayND<T>& templ )
{
    if ( info()!=templ.info() )
    {
	delete in_;
	in_ = templ.info().clone();
    }

    mArrNDImplDoNormalCopy;

    if ( in_->getTotalSz() > 0 )
    {
	ArrayNDIter iter( *in_ );
	do
	{
	    const int* pos = iter.getPos();
	    setND( pos, templ.getND(pos) );
	} while ( iter.next() );
    }
}


template <class T> inline
void ArrayNDImpl<T>::setND( const int* pos, T v )
{
#ifdef __debug__
    if ( !in_->validPos( pos ) )
	{ pErrMsg("Invalid access"); DBG::forceCrash(true); }
#endif
    const od_int64 offset = in_->getOffset(pos);
    if ( ptr_ ) ptr_[offset] = v ;
    else stor_->setValue( offset, v);
}


template <class T> inline
T ArrayNDImpl<T>::getND( const int* pos ) const
{
#ifdef __debug__
    if ( !in_->validPos( pos ) )
	{ pErrMsg("Invalid access"); DBG::forceCrash(true); }
#endif
    const od_int64 offset = in_->getOffset(pos);
    return ptr_ ? ptr_[offset] : stor_->value( offset );
}


template <class T> inline
bool ArrayNDImpl<T>::setInfo( const ArrayNDInfo& ni )
{
    if ( ni.getNDim() != in_->getNDim() )
	return false;

    const int ndim = in_->getNDim();
    TypeSet<int> sizes( ndim, 0 );
    for ( int idx=0; idx<ndim; idx++ )
	sizes[idx] = ni.getSize(idx);

    return setSize( sizes.arr() );
}

 
template <class T> inline
bool ArrayNDImpl<T>::setSize( const int* d )
{
    const int ndim = in_->getNDim();
    for ( int idx=0; idx<ndim; idx++ )
	in_->setSize( idx, d[idx] );

    mArrayNDImplSetSize( in_->getTotalSz() );
    return true;
}


template <class T> inline
ArrayND<T>* ArrayNDImpl<T>::create( const ArrayNDInfo& nsz )
{
    int ndim = nsz.getNDim();

    if ( ndim==1 ) return new Array1DImpl<T>( nsz.getSize(0) );
    if ( ndim==2 ) return new Array2DImpl<T>( nsz.getSize(0), nsz.getSize(1) );
    if ( ndim==3 ) return new Array3DImpl<T>( nsz.getSize(0), nsz.getSize(1),
					      nsz.getSize(2) );

    return new ArrayNDImpl<T>( nsz );
}


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef arrayndinfo_h
#define arrayndinfo_h
/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		9-3-1999
 RCS:		$Id: arrayndinfo.h 30145 2013-06-03 14:05:08Z bert.bril@dgbes.com $
________________________________________________________________________


*/

#include "basicmod.h"
#include "gendefs.h"

/*!
\brief Contains the information about the size of ArrayND, and
in what order the data is stored (if accessable via a pointer).
*/

mExpClass(Basic) ArrayNDInfo
{
public:

    virtual ArrayNDInfo* clone() const					= 0;
    virtual		~ArrayNDInfo()					{} 

    virtual int		getNDim() const					= 0;
    virtual int		getSize(int dim) const				= 0;
    virtual bool	setSize(int dim,int sz);
    
    virtual bool	isOK() const;
 
    virtual od_uint64	getTotalSz() const;
    virtual od_uint64	getOffset(const int*) const;
    			/*!<Returns offset in a 'flat' array.*/
    virtual bool	validPos(const int*) const;
    			/*!<Checks if the position exists. */
    bool		validDimPos(int dim,int pos) const;
    			/*!<Checks if the position exists on a certain dim. */
    virtual bool	getArrayPos(od_uint64, int*) const;
    			/*!<Given an offset, what is the ND position. */

protected:

    od_uint64		calcTotalSz() const;

};


inline bool operator ==( const ArrayNDInfo& a1, const ArrayNDInfo& a2 )
{
    int nd = a1.getNDim();
    if ( nd != a2.getNDim() ) return false;
    for ( int idx=0; idx<nd; idx++ )
	if ( a1.getSize(idx) != a2.getSize(idx) ) return false;
    return true;
}

inline bool operator !=( const ArrayNDInfo& a1, const ArrayNDInfo& a2 )
{ return !(a1 == a2); }


/*!
\brief Contains the information about the size of Array1D, and
in what order the data is stored (if accessable via a pointer).
*/

mExpClass(Basic) Array1DInfo : public ArrayNDInfo
{
public:

    virtual int		getNDim() const			{ return 1; }

    virtual od_uint64	getOffset( int pos ) const
			{ return pos; }
    virtual bool	validPos( int pos ) const
			{ return ArrayNDInfo::validPos( &pos ); }

    virtual od_uint64	getOffset( const int* iarr ) const
			{ return getOffset( *iarr ); }
    virtual bool	validPos( const int* iarr ) const
			{ return ArrayNDInfo::validPos( iarr ); }

};


/*!
\brief Contains the information about the size of Array2D, and
in what order the data is stored (if accessable via a pointer).
*/

mExpClass(Basic) Array2DInfo : public ArrayNDInfo
{
public:

    virtual int		getNDim() const			{ return 2; }

    virtual od_uint64	getOffset(int,int) const;
			/*!<Returns offset in a 'flat' array.*/
    virtual bool	validPos(int,int) const;

    virtual od_uint64	getOffset( const int* iarr ) const
			{ return ArrayNDInfo::getOffset( iarr ); }
    virtual bool	validPos( const int* iarr ) const
			{ return ArrayNDInfo::validPos( iarr ); }

};


/*!
\brief Contains the information about the size of Array3D, and
in what order the data is stored (if accessable via a pointer).
*/

mExpClass(Basic) Array3DInfo : public ArrayNDInfo
{
public:

    virtual int		getNDim() const			{ return 3; }

    virtual od_uint64	getOffset(int, int, int) const;
			/*!<Returns offset in a 'flat' array.*/
    virtual bool	validPos(int,int,int) const;

    virtual od_uint64	getOffset( const int* iarr ) const
			{ return ArrayNDInfo::getOffset( iarr ); }
    virtual bool	validPos( const int* iarr ) const
			{ return ArrayNDInfo::validPos( iarr ); }

};


/*!
\brief Implementation of Array1DInfo.
*/

mExpClass(Basic) Array1DInfoImpl : public Array1DInfo
{
public:

    virtual Array1DInfo* clone() const
			{ return new Array1DInfoImpl(*this); }

			Array1DInfoImpl(int nsz=0); 
			Array1DInfoImpl(const Array1DInfo&);

    virtual int		getSize(int dim) const; 
    virtual bool	setSize(int dim,int nsz);
    virtual bool	isOK() const			{ return dimsz_>=0; }
    virtual od_uint64	getTotalSz() const		{ return dimsz_; }

protected:

    int			dimsz_;

};


/*!
\brief Implementation of Array2DInfo.
*/

mExpClass(Basic) Array2DInfoImpl : public Array2DInfo
{
public:

    virtual Array2DInfo* clone() const { return new Array2DInfoImpl(*this); }

			Array2DInfoImpl(int sz0=0, int sz1=0);
			Array2DInfoImpl(const Array2DInfo&);

    virtual int		getSize(int dim) const;
    virtual bool	setSize(int dim,int nsz);
    virtual bool	isOK() const		{ return cachedtotalsz_ > 0; }

    virtual od_uint64	getTotalSz() const	{ return cachedtotalsz_; }
    
protected:

    int                 dimsz_[2];
    od_uint64		cachedtotalsz_;

};


/*!
\brief Implementation of Array3DInfo.
*/

mExpClass(Basic) Array3DInfoImpl : public Array3DInfo
{
public:

    virtual Array3DInfo* clone() const { return new Array3DInfoImpl(*this); }

			Array3DInfoImpl(int sz0=0, int sz1=0, int sz2=0);
			Array3DInfoImpl(const Array3DInfo&);

    virtual int		getSize(int dim) const; 
    virtual bool	setSize(int dim,int nsz);
    virtual bool	isOK() const		{ return cachedtotalsz_ > 0; }
    virtual od_uint64	getTotalSz() const	{ return cachedtotalsz_; }

protected:

    int                 dimsz_[3];
    od_uint64		cachedtotalsz_;

};  


/*!
\brief Implementation of ArrayNDInfo.
*/

mExpClass(Basic) ArrayNDInfoImpl : public ArrayNDInfo
{
public:

    virtual ArrayNDInfo* clone() const;
    static ArrayNDInfo*	create(int ndim);

			ArrayNDInfoImpl(int ndim);
			ArrayNDInfoImpl(const ArrayNDInfo&);
			~ArrayNDInfoImpl();
    virtual bool	isOK() const		{ return cachedtotalsz_ > 0; }

    virtual od_uint64	getTotalSz() const	{ return cachedtotalsz_; }
    virtual int		getNDim() const;
    virtual int		getSize(int dim) const;
    virtual bool	setSize(int dim,int nsz);

protected:

    int 		ndim_;
    int*		dimsz_;

    od_uint64		cachedtotalsz_;
};


inline int Array1DInfoImpl::getSize( int dim ) const
{
    return dim ? 0 : dimsz_;
}


inline int Array2DInfoImpl::getSize( int dim ) const
{
    return dim>1 || dim<0 ? 0 : dimsz_[dim];
}


inline int Array3DInfoImpl::getSize( int dim ) const
{
    return dim>2 || dim<0 ? 0 : dimsz_[dim];
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef arrayndslice_h
#define arrayndslice_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          10-12-1999
 RCS:           $Id: arrayndslice.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

@$*/

#include "basicmod.h"
#include "arraynd.h"
#include "varlenarray.h"

/*!
\brief Base class of Array1DSlice and Array2DSlice. Access-tool to another
ArrayND with higher dimensionality.

  ArrayXDSlice is an ArrayND that is an access-tool to another ArrayND with
  higher dimensionality. It can be used to get Array1D through a Array3D cube.
  Use setPos(int,int) to set the fixed positions and leave out the positions
  that should vary. When all positions are set, call init().
  
  To unset a position, set it to -1. If positions are unset, init has to be
  called prior to dataaccesing functions.
*/

mExpClass(Basic) ArrayNDSliceBase
{
public:				
    virtual			~ArrayNDSliceBase();
    int				getDimSize(int dim) const;
    int				getPos(int dim) const;
    bool			setPos(int dim,int pos);
    bool			init();
    void			setDimMap(int localdim, int remotedim );
protected:
    				ArrayNDSliceBase( ArrayNDInfo*,
						  const ArrayNDInfo& );
    void			getSourcePos(const int* localpos,
	    				     int* sourcepos) const;
    ArrayNDInfo&		info_;
    const ArrayNDInfo&		sourceinfo_;

    TypeSet<int>		vardim_;
    TypeSet<int>		position_;
    od_int64			offset_;
};


/*!
\brief Subclass of Array1D and ArrayNDSliceBase.
*/

template <class T>
mClass(Basic) Array1DSlice : public Array1D<T>, public ArrayNDSliceBase
{
public:
				Array1DSlice(ArrayND<T>&);
				Array1DSlice(const ArrayND<T>&);
				~Array1DSlice();

    ValueSeries<T>*		clone() const;

    T				get( int ) const;
    void			set( int, T );
    const Array1DInfo&		info() const;
    bool			isSettable() const;

protected:
    const ValueSeries<T>*	getStorage_() const;

    bool				writable_;
    ArrayND<T>&				source_;
    mutable OffsetValueSeries<T>*	storage_;
};


/*!
\brief Subclass of Array2D and ArrayNDSliceBase.
*/

template <class T>
mClass(Basic) Array2DSlice : public Array2D<T>, public ArrayNDSliceBase
{
public:
				Array2DSlice(ArrayND<T>&);
				Array2DSlice(const ArrayND<T>&);
				~Array2DSlice();

    T				get(int,int) const;
    void			set(int,int, T );
    const Array2DInfo&		info() const;
    bool			isSettable() const;

protected:
    const ValueSeries<T>*	getStorage_() const;
    bool			writable_;

    ArrayND<T>&				source_;
    mutable OffsetValueSeries<T>*	storage_;
};


//Array1DSlice
template <class T> inline
Array1DSlice<T>::Array1DSlice( ArrayND<T>& source )
    : ArrayNDSliceBase( new Array1DInfoImpl, source.info() )
    , source_( source )
    , storage_( 0 )
    , writable_( true )
{}


template <class T> inline
Array1DSlice<T>::Array1DSlice( const ArrayND<T>& source )
    : ArrayNDSliceBase( new Array1DInfoImpl, source.info() )
    , source_( const_cast<ArrayND<T>& >(source) )
    , storage_( 0 )
    , writable_( false )
{}


template <class T> inline
Array1DSlice<T>::~Array1DSlice()
{ delete storage_; }


template <class T> inline
bool Array1DSlice<T>::isSettable() const
{ return writable_ && source_.isSettable(); }


template <class T> inline
void Array1DSlice<T>::set( int pos, T val )
{
    if ( !writable_ ) return;
    mAllocVarLenArr( int, srcpos, position_.size() );
    getSourcePos( &pos, srcpos );
    source_.setND( srcpos, val );
}


template <class T> inline
T Array1DSlice<T>::get( int pos ) const
{
    mAllocVarLenArr( int, srcpos, position_.size() );
    getSourcePos( &pos, srcpos );
    return source_.getND( srcpos );
}


template <class T> inline
ValueSeries<T>* Array1DSlice<T>::clone() const
{
    Array1DSlice<T>* res = new Array1DSlice<T>( source_ );
    res->info_ = info_;
    res->vardim_ = vardim_;
    res->position_ = position_;
    res->offset_ = offset_;

    return res;
}

template <class T> inline
const Array1DInfo& Array1DSlice<T>::info() const	
{ return (const Array1DInfo&) info_; }


template <class T> inline
const ValueSeries<T>* Array1DSlice<T>::getStorage_() const
{
    if ( offset_<0 )
	return 0;

    if ( !source_.getStorage() )
	return 0;

    if ( offset_==0 )
    {
	delete storage_;
	storage_ = 0;
	return source_.getStorage();
    }

    if ( !storage_ || &storage_->source() != source_.getStorage() )
    {
	delete storage_;
	storage_ =
	    new OffsetValueSeries<T>( *source_.getStorage(), offset_ );
    }
    else
	storage_->setOffset( offset_ );
    return storage_;
}


//Array2DSlice
template <class T> inline
Array2DSlice<T>::Array2DSlice( ArrayND<T>& source )
    : ArrayNDSliceBase( new Array2DInfoImpl, source.info() )
    , source_( source )
    , storage_( 0 )
    , writable_( true )
{}


template <class T> inline
Array2DSlice<T>::Array2DSlice( const ArrayND<T>& source )
    : ArrayNDSliceBase( new Array2DInfoImpl, source.info() )
    , source_( const_cast<ArrayND<T>&>(source) )
    , storage_( 0 )
    , writable_( false )
{}


template <class T> inline
Array2DSlice<T>::~Array2DSlice()
{ delete storage_; }


template <class T> inline
bool Array2DSlice<T>::isSettable() const
{ return writable_ && source_.isSettable(); }


template <class T> inline
void Array2DSlice<T>::set( int pos0, int pos1, T val )
{
    if ( !writable_ ) return;

    const int localpos[] = { pos0, pos1 };
    mAllocVarLenArr( int, srcpos, position_.size() );
    getSourcePos( localpos, srcpos );
    source_.setND( srcpos, val );
}


template <class T> inline
T Array2DSlice<T>::get( int pos0, int pos1 ) const
{
    const int localpos[] = { pos0, pos1 };
    mAllocVarLenArr( int, srcpos, position_.size() );
    getSourcePos( localpos, srcpos );
    return source_.getND( srcpos );
}


template <class T> inline
const Array2DInfo& Array2DSlice<T>::info() const	
{ return (const Array2DInfo&) info_; }


template <class T> inline
const ValueSeries<T>* Array2DSlice<T>::getStorage_() const
{
    if ( offset_<0 )
	return 0;

    if ( !source_.getStorage() )
	return 0;

    if ( offset_==0 )
    {
	delete storage_;
	storage_ = 0;
	return source_.getStorage();
    }

    if ( !storage_ || &storage_->source() != source_.getStorage() )
    {
	delete storage_;
	storage_ =
	    new OffsetValueSeries<T>( *source_.getStorage(), offset_ );
    }
    else
	storage_->setOffset( offset_ );

    return storage_;
}



#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef arrayndstacker_h
#define arrayndstacker_h

/*+

________________________________________________________________________ 

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
  Author:        Arnaud Huck
  Date:		 Nov 2013
  RCS:		 $Id: arrayndstacker.h 32388 2013-11-12 15:15:11Z arnaud.huck@dgbes.com $
________________________________________________________________________ 
 
-*/

#include "algomod.h"
#include "arraynd.h"
#include "task.h"

/*!
\brief Gently stacks ArrayND by summation along the secondary axis
Currently implemented only 1D, and Array1D's need to return getData() non-null.
With normalize_, will return the average instead of the sum
*/

template <class fT,class ArrT >
mClass(Algo) Array1DStacker : public ParallelTask
{
public:

		Array1DStacker( const ObjectSet<ArrT>& inp,
				ArrT& out )
		    : inp_(inp)
		    , out_(out)
		    , totalnr_(-1)
		    , normalize_(false)
		{
		    if ( !inp.isEmpty() && inp[0] )
			totalnr_ = inp[0]->info().getTotalSz();
		}

    bool	doPrepare( int nrthreads )
		{
		    if ( totalnr_ < 1 )
			return false;

		    for ( int iarr=1; iarr<inp_.size(); iarr++ )
		    {
			if ( !inp_[iarr] )
			    continue;

			if ( inp_[iarr]->info().getTotalSz() > totalnr_ )
			    totalnr_ = inp_[iarr]->info().getTotalSz();
		    }

		    out_.setSize( totalnr_ );
		    if ( !out_.getData() )
		    {
			msg_ = "Cannot stack this type of object";
			return false;
		    }

		    out_.setAll( 0 );
		    return true;
		}

    bool	doWork( od_int64 start, od_int64 stop, int threadidx )
		{
		    fT* outarr = out_.getData();
		    int count = 0;
		    for ( od_int64 idx=start; idx<=stop; idx++ )
		    {
			fT& outval = outarr[idx];
			for ( int iarr=0; iarr<inp_.size(); iarr++ )
			{
			    if ( !inp_[iarr] ) continue;
			    const fT* inparr = inp_[iarr]->getData();
			    if ( !inparr ||
				 idx >= inp_[iarr]->info().getTotalSz() )
			       continue;

			    const fT val = inparr[idx];
			    if ( !mIsUdf(val) )
			    {
				outval += val;
				count++;
			    }
			}

			if ( normalize_ && count )
			    outval /= count;
		    }

		    return true;
		}

    od_int64	nrIterations() const { return totalnr_; }
    void	doNormalize( bool normalize )	{ normalize_ = normalize; }
    const char*	errMsg() const { return msg_.str(); }

protected:

    od_int64		totalnr_;
    const ObjectSet<ArrT>&	inp_;
    ArrT&		out_;
    bool		normalize_;
    FixedString		msg_;

};


//TODO implement the ND version

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef arrayndwrapper_h
#define arrayndwrapper_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Nanne Hemstra
 Date:		October 2007
 RCS:		$Id: arrayndwrapper.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/


/*!
\brief Access tool to another array with a lower number of dimensions
*/

//TODO: Write more info
mClass(Basic) ArrayNDWrapper
{
public:
    void		setDimMap(int srcdim,int targetdim);
    virtual void	init()		= 0;
    virtual bool	isOK() const	= 0;

protected:
    			ArrayNDWrapper(const ArrayNDInfo&);
    TypeSet<int>	dimmap_;
};


ArrayNDWrapper::ArrayNDWrapper( const ArrayNDInfo& info )
{ dimmap_.setSize( info.getNDim(), 0 ); }

void ArrayNDWrapper::setDimMap( int srcdim, int targetdim )
{ dimmap_[srcdim] = targetdim; }


/*!
\brief Subclass of ArrayNDWrapper.
*/

template <class T>
mClass(Basic) Array3DWrapper : public Array3D<T>, public ArrayNDWrapper
{
public:
    			Array3DWrapper(ArrayND<T>&);
			~Array3DWrapper();

    void		init();
    bool		isOK() const;

    void		set(int,int,int,T);
    T			get(int,int,int) const;

    const Array3DInfo&	info() const		{ return info_; }

protected:

    Array3DInfo&	info_;
    ArrayND<T>&		srcarr_;
};



template <class T>
Array3DWrapper<T>::Array3DWrapper( ArrayND<T>& arr )
    : ArrayNDWrapper(arr.info())
    , srcarr_(arr)
    , info_(*new Array3DInfoImpl(1,1,1))
{
}

template <class T>
Array3DWrapper<T>::~Array3DWrapper()
{ delete &info_; }


template <class T>
void Array3DWrapper<T>::init()
{
    for ( int idx=0; idx<dimmap_.size(); idx++ )
	info_.setSize( dimmap_[idx], srcarr_.info().getSize(idx) );
}


template <class T>
bool Array3DWrapper<T>::isOK() const
{ return srcarr_.info().getNDim() <  3; }


template <class T>
void Array3DWrapper<T>::set( int i0, int i1, int i2, T val )
{
    int pos3d[] = { i0, i1, i2 };
    TypeSet<int> posnd;
    for ( int idx=0; idx<dimmap_.size(); idx++ )
	posnd += pos3d[ dimmap_[idx] ];

    srcarr_.setND( posnd.arr(), val );
}


template <class T>
T Array3DWrapper<T>::get( int i0, int i1, int i2 ) const
{
    int pos3d[] = { i0, i1, i2 };
    TypeSet<int> posnd;
    for ( int idx=0; idx<dimmap_.size(); idx++ )
	posnd += pos3d[ dimmap_[idx] ];

    return srcarr_.getND( posnd.arr() );
}

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef ascstream_h
#define ascstream_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		2-5-1995
 RCS:		$Id: ascstream.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstring.h"
#include "plftypes.h"
#include <limits.h>
#include <iosfwd>

#define mAscStrmParagraphMarker		"!"
#define mAscStrmKeyValSep		':'


/*!
\brief OpendTect standard ascii format file writing.
  
  An ascostream puts data in an OpendTect standard ascii format file. That means
  it has a OpendTect standard header and often keyword/value pairs separated by
  a colon.
*/

mExpClass(Basic) ascostream
{

public:
		ascostream( std::ostream& strm )
			: mystrm(false), streamptr(&strm) {}
		ascostream( std::ostream* strm )
			: mystrm(true), streamptr(strm)   {}
					//!<\note strm becomes mine
		~ascostream();

    bool	putHeader(const char* filetype);
    bool	put(const char*,const char* val=0);

#define mAscStreamDefFns(fn,typ) \
    bool	fn(const char*,typ); \
    bool	fn(const char*,typ,typ); \
    bool	fn(const char*,typ,typ,typ); \
    bool	fn(const char*,typ,typ,typ,typ)
    		mAscStreamDefFns(put,int);
		mAscStreamDefFns(put,od_uint32);
		mAscStreamDefFns(put,od_int64);
		mAscStreamDefFns(put,od_uint64);
		mAscStreamDefFns(put,float);
		mAscStreamDefFns(put,double);
		mAscStreamDefFns(putYN,bool);
#undef mAscStreamDefFns

    void	newParagraph();

    std::ostream& stream()			{ return *streamptr; }
    const std::ostream& stream() const		{ return *streamptr; }
    operator	std::ostream&()			{ return *streamptr; }
    operator	const std::ostream&() const	{ return *streamptr; }

protected:

    std::ostream* streamptr;
    bool	mystrm;

    void	putKeyword(const char*,bool wsep=true);

};


/*!
\brief OpendTect standard ascii format file reading.
  
  An ascistream gets data from a OpendTect standard ascii format file. This
  format consists of the OpendTect header (version, file type, date), and then
  a number of 'paragraphs', each separated by a single '!' on a line.
*/

mExpClass(Basic) ascistream
{
public:
			ascistream( std::istream& strm, bool rdhead=true )
				: mystrm(false)	{ init(&strm,rdhead); }
			ascistream( std::istream* strm, bool rdhead=true )
				: mystrm(true)	{ init(strm,rdhead); }
			~ascistream();

    ascistream&		next();

    const char*		headerStartLine() const	{ return header.buf(); }
    const char*		fileType() const	{ return filetype.buf(); }
    bool		isOfFileType(const char*) const;
    const char*		version() const;
    const char*		timeStamp() const	{ return timestamp.buf(); }
    int			majorVersion() const;
    int			minorVersion() const;

    enum EntryType	{ Empty, Keyword, KeyVal, ParagraphMark, EndOfFile };
    EntryType		type() const;
    bool		atEOS() const		{ return type() > KeyVal; }
			//!< returns true if at end of segment (='paragraph')

    const char*		keyWord() const		{ return keybuf.buf(); }
    const char*		value() const		{ return valbuf.buf(); }
    bool		hasKeyword(const char*) const;
    bool		hasValue(const char*) const;
    int			getIValue(int i=0) const;
    od_uint32		getUIValue(int i=0) const;
    od_int64		getI64Value(int i=0) const;
    od_uint64		getUI64Value(int i=0) const;
    float		getFValue(int i=0) const;
    double		getDValue(int i=0) const;
    bool		getYN(int i=0) const;

    inline std::istream& stream() const		{ return *streamptr; }

			// This is for overriding what's in the file
    void		setKeyWord( const char* s ) { keybuf = s; }
    void		setValue( const char* s ) { valbuf = s; }

protected:

    std::istream*	streamptr;
    bool		mystrm;
    BufferString	keybuf;
    BufferString	valbuf;

    BufferString	header;
    BufferString	filetype;
    BufferString	timestamp;

private:

    void		init(std::istream*,bool);

};


inline bool atEndOfSection( const ascistream& strm )
{ return strm.atEOS(); }


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef atomic_h
#define atomic_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		9-3-1999
 RCS:		$Id: atomic.h 34001 2014-04-03 10:33:48Z aneesh.tiwari@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "commondefs.h"
#include "plftypes.h"

#ifdef __cpp11__
# define __STDATOMICS__
# include <atomic>
#else
# ifdef __win__
#  define __WINATOMICS__
#  include <Windows.h>
# else
#  define __GCCATOMICS__
# endif
#endif

namespace Threads {

class Mutex;

template <class T>
mClass(Basic) Atomic
{
public:
    		Atomic(T val=0);
			~Atomic();

			operator T() const { return get(); }
    T		get() const;
    
    T		operator=(T v);

    inline T	operator+=(T);
    inline T	operator-=(T);
    inline T	operator++();
    inline T	operator--();
    inline T	operator++(int);
    inline T	operator--(int);

    inline T	exchange(T newval);
    		/*!<Returns old value. */

    inline bool	strongSetIfEqual(T newval,T expected);
    /*!<Sets the val_ only if value is previously set
     to expected. */
    inline bool	weakSetIfEqual(T newval, T& expected);
    /*!<Sets the val_ only if value is previously set
     to expected. If it fails, current val is set in expected argument.
     This function is more effective than strongSetIfEqual, but may
     return false spuriously, hence it should be used in a loop. */
      
private:
    			Atomic( const Atomic<T>& )	{}
    
#ifdef __STDATOMICS__
    std::atomic<T>	val_;
#elif (defined __WINATOMICS__)
    volatile T		values_[8];
    volatile T*		valptr_;

    Mutex*		lock_;

#else
    volatile T		val_;
#endif
};


/*!>
 Atomically sets the 'val' only if its value is currently the value of 'curval'.
 If the value in 'val' is identical to the value of 'curval', function will
 change 'val' and return true. Otherwise, it will not change 'val', it
 will return false, and update 'curval' to the current value of 'val'.
 */


inline bool atomicSetIfValueIs( volatile int& val, int& curval, int newval )
{
# ifdef __win__
    const int oldval =InterlockedCompareExchange( (volatile long*) &val,
						  newval, curval );
    if ( oldval!=curval )
    {
        curval = oldval;
        return false;
    }

    return true;
# else
    const int old = __sync_val_compare_and_swap( &val, curval, newval );
    if ( old!=curval )
    {
        curval = old;
        return false;
    }

    return true;
#endif
}

#ifdef __win__
#define mAtomicPointerType long long
#else
#define mAtomicPointerType T*
#endif


/*!
 \brief Atomic instantiated with a pointer. The class really only handles the
 casting from a void* to a T*.
 */

template <class T>
mClass(Basic) AtomicPointer
{
public:
    inline	AtomicPointer(T* newptr = 0);
    
    inline bool	setIfEqual(T* newptr,const T* oldptr);
    
    inline void	unRef();
    /*!<Don't be confused, class works for non-ref-counted objects
     as well. Just don't call ref/unRef(); */
    inline void	ref();
    
    inline T*	setToNull();
    /*!<Returns the last value of the ptr. */
    
    T*		exchange(T* newptr);
    //*!<\returns old value
    
    inline	operator T*() const;
    inline T*	operator->();
    inline const T* operator->() const;
    
    inline T*	operator+=(int);
    inline T*	operator-=(int);
    inline T*	operator++();
    inline T*	operator--();
    inline T*	operator++(int);
    inline T*	operator--(int);
    
protected:
    
    
    Atomic<mAtomicPointerType>	ptr_;
};


//Implementations

#ifdef __STDATOMICS__
template <class T> inline
Atomic<T>::Atomic( T val )
    : val_( val )
{}


template <class T> inline
Atomic<T>::Atomic( const Atomic<T>& val )
    : val_( val.get() )
{}


template <class T> inline
T Atomic<T>::operator += (T b)
{
    return val_ += b;
}


template <class T> inline
T Atomic<T>::operator -= (T b)
{
    return val_ -= b;
}


template <class T> inline
T Atomic<T>::operator ++()
{
    return ++val_;
}


template <class T> inline
T Atomic<T>::operator -- ()
{
    return --val_;
}


template <class T> inline
T Atomic<T>::operator ++(int)
{
    return val_++;
}


template <class T> inline
T Atomic<T>::operator -- (int)
{
    return val_--;
}


template <class T> inline
bool Atomic<T>::strongSetIfEqual( T newval, T expected )
{
    return val_.compare_exchange_strong( expected, newval );
}


template <class T> inline
bool Atomic<T>::weakSetIfEqual( T newval, T& expected )
{
    return val_.compare_exchange_weak( expected, newval );
}


template <class T> inline
T Atomic<T>::exchange( T newval )
{
    return val_.exchange( newval );
}


#endif  //STDATOMICS

#ifdef __GCCATOMICS__
template <class T> inline
Atomic<T>::Atomic( T val )
    : val_( val )
{}
    
    
template <class T> inline
Atomic<T>::~Atomic<T>()
{}
    

template <class T> inline
T Atomic<T>::get() const
{
    return val_;
}

  
template <class T> inline
T Atomic<T>::operator=( T val )
{
    val_ = val;
    return val_;
}


template <class T> inline
T Atomic<T>::operator += (T b)
{
    return __sync_add_and_fetch(&val_, b);
}


template <class T> inline
T Atomic<T>::operator -= (T b)
{
    return __sync_sub_and_fetch(&val_, b);
}


template <class T> inline
T Atomic<T>::operator ++()
{
    return __sync_add_and_fetch(&val_, 1);
}


template <class T> inline
T Atomic<T>::operator -- ()
{
    return __sync_sub_and_fetch(&val_, 1);
}


template <class T> inline
T Atomic<T>::operator ++(int)
{
    return __sync_fetch_and_add(&val_, 1);
}


template <class T> inline
T Atomic<T>::operator -- (int)
{
    return __sync_fetch_and_sub(&val_, 1);
}


template <class T> inline
bool Atomic<T>::strongSetIfEqual( T newval, T expected )
{
    return __sync_val_compare_and_swap( &val_, expected, newval )==expected;
}


template <class T> inline
bool Atomic<T>::weakSetIfEqual( T newval, T& expected )
{
    const T prevval = __sync_val_compare_and_swap( &val_, expected, newval );
    if ( prevval==expected )
	return true;
    
    expected = prevval;
    return false;
}


template <class T> inline
T Atomic<T>::exchange( T newval )
{
    return  __sync_lock_test_and_set( &val_, newval );
}
#endif //__GCCATOMICS__



#ifdef __WINATOMICS__


template <class T> inline
Atomic<T>::Atomic( T val )
    : lock_( new Mutex )
    , valptr_( values_ )
{
	*valptr_ = val;
}


template <class T> inline
Atomic<T>::~Atomic()
{
    delete lock_;
}


template <class T> inline
T Atomic<T>::get() const
{
    return *valptr_;
}

template <class T> inline
T Atomic<T>::exchange( T newval )
{
    T expected = *valptr_;
    while ( !weakSetIfEqual( newval, expected ) )
    {}

    return expected;
}


template <class T> inline
T Atomic<T>::operator=(T val)
{
    *valptr_ = val;
    return *valptr_;
}



template <class T> inline
T Atomic<T>::operator += (T b)
{
    MutexLocker lock( *lock_ );
    return (*valptr_) += b;
}


template <class T> inline
T Atomic<T>::operator -= (T b)
{
    MutexLocker lock( *lock_ );
    return (*valptr_) -= b;
}


template <class T> inline
T Atomic<T>::operator ++()
{
    MutexLocker lock( *lock_ );
    return ++(*valptr_);
}


template <class T> inline
T Atomic<T>::operator -- ()
{
    MutexLocker lock( *lock_ );
    return --(*valptr_);
}


template <class T> inline
T Atomic<T>::operator ++(int)
{
    MutexLocker lock( *lock_ );
    return (*valptr_)++;
}


template <class T> inline
T Atomic<T>::operator -- (int)
{
    MutexLocker lock( *lock_ );
    return (*valptr_)--;
}


template <class T> inline
bool Atomic<T>::strongSetIfEqual(T newval, T expected )
{
    MutexLocker lock( *lock_ );
    const bool res = (*valptr_)==expected;
    if ( res )
		(*valptr_) = newval;
    
    return res;
}


template <class T> inline
bool Atomic<T>::weakSetIfEqual(T newval, T& expected )
{
    MutexLocker lock( *lock_ );
    const bool res = (*valptr_)==expected;
    if ( res )
		(*valptr_) = newval;
    else
		expected = (*valptr_);
    
    return res;
}


#ifdef __win64__

template <> inline
Atomic<long long>::Atomic( long long val )
	: lock_( 0 )
{
    valptr_ = &values_[0];
    while ( ((long long) valptr_) % 64  )
		valptr_++;
    
    *valptr_ = val;
}
	 
	 
template <> inline
bool Atomic<long long>::strongSetIfEqual(long long newval, long long expected )
{
    return InterlockedCompareExchange64( valptr_,newval,expected)==expected;
}
	 
	 
template <> inline
bool Atomic<long long>::weakSetIfEqual(long long newval, long long& expected )
{
    const long long prevval =
    	InterlockedCompareExchange64(valptr_,newval,expected);
    if ( prevval==expected )
		return true;
    expected = prevval;
    return false; 
}
	 
	 
template <> inline
long long Atomic<long long>::operator += (long long b)
{
    return InterlockedAdd64( valptr_, b );
}
	 
	 
template <> inline
long long Atomic<long long>::operator -= (long long b)
{
    return InterlockedAdd64( valptr_, -b );
}
	 
	 
template <> inline
long long Atomic<long long>::operator ++()
{
    return InterlockedIncrement64( valptr_ );
}
	 
	 
template <> inline
long long Atomic<long long>::operator -- ()
{
    return InterlockedDecrement64( valptr_ );
}
	 
	 
template <> inline
long long Atomic<long long>::operator ++(int)
{
    return InterlockedIncrement64( valptr_ )-1;
}
	 
	 
template <> inline
long long Atomic<long long>::exchange(long long newval)
{
    return InterlockedExchange64( valptr_, newval );
}
	 
	 
template <> inline
long long Atomic<long long>::operator -- (int)
{
    return InterlockedDecrement64( valptr_ )+1;
}


# endif //not win32

template <> inline
Atomic<int>::Atomic( int val )
	: lock_( 0 )
{
    valptr_ = &values_[0];
    while ( ((int) valptr_) % 32  )
		valptr_++;
    
    *valptr_ = val;
}
	 
	 
template <> inline
bool Atomic<int>::strongSetIfEqual(int newval, int expected )
{
    return InterlockedCompareExchange( (volatile long*) valptr_,newval,expected)==expected;
}
	 
	 
template <> inline
bool Atomic<int>::weakSetIfEqual(int newval, int& expected )
{
    const int prevval =
    	InterlockedCompareExchange((volatile long*) valptr_,newval,expected);
    if ( prevval==expected )
		return true;
    expected = prevval;
    return false; 
}
	 
	 
template <> inline
int Atomic<int>::operator += (int b)
{
    return InterlockedExchangeAdd( (volatile long*) valptr_, b ) + b;
}
	 
	 
template <> inline
int Atomic<int>::operator -= (int b)
{
    return InterlockedExchangeAdd( (volatile long*) valptr_, -b ) -b;
}
	 
	 
template <> inline
int Atomic<int>::operator ++()
{
    return InterlockedIncrement( (volatile long*) valptr_ );
}
	 
	 
template <> inline
int Atomic<int>::operator -- ()
{
    return InterlockedDecrement( (volatile long*) valptr_ );
}
	 
	 
template <> inline
int Atomic<int>::operator ++(int)
{
    return InterlockedIncrement( (volatile long*) valptr_ )-1;
}
	 
	 
template <> inline
int Atomic<int>::exchange(int newval)
{
    return InterlockedExchange( (volatile long*) valptr_, newval );
}
	 
	 
template <> inline
int Atomic<int>::operator -- (int)
{
    return InterlockedDecrement( (volatile long*) valptr_ )+1;
}


template <> inline
Atomic<long>::Atomic( long val )
	: lock_( 0 )
{
    valptr_ = &values_[0];
    while ( ((long long) valptr_) % 32  )
		valptr_++;
    
    *valptr_ = val;
}


template <> inline
bool Atomic<long>::strongSetIfEqual(long newval, long expected )
{
    return InterlockedCompareExchange( (volatile long*) valptr_, newval, expected)==expected;
}


template <> inline
bool Atomic<long>::weakSetIfEqual(long newval, long& expected )
{
    const long prevval =
		InterlockedCompareExchange( valptr_,  newval,  expected);
    if ( prevval==expected )
		return true;
    expected = prevval;
    return false;
}


template <> inline
long Atomic<long>::operator += (long b)
{
    return  InterlockedExchangeAdd( valptr_, (long) b ) + b;
}


template <> inline
long Atomic<long>::operator -= (long b)
{
    return  InterlockedExchangeAdd( valptr_, -b ) - b;
}


template <> inline
long Atomic<long>::operator ++()
{
    return InterlockedIncrement( valptr_ );
}


template <> inline
long Atomic<long>::operator -- ()
{
    return InterlockedDecrement( valptr_ );
}


template <> inline
long Atomic<long>::operator ++(int)
{
    return InterlockedIncrement( valptr_ )-1;
}


template <> inline
long Atomic<long>::exchange(long newval)
{
    return InterlockedExchange( valptr_, newval );
}


template <> inline
long Atomic<long>::operator -- (int)
{
    return InterlockedDecrement( valptr_ )+1;
}


#endif //__WINATOMICS__

/* AtomicPointer implementations. */
template <class T> inline
AtomicPointer<T>::AtomicPointer(T* newptr )
: ptr_( (mAtomicPointerType) newptr )
{}


template <class T> inline
bool AtomicPointer<T>::setIfEqual( T* newptr, const T* oldptr )
{
    return ptr_.strongSetIfEqual( (mAtomicPointerType) newptr,
				 (mAtomicPointerType) oldptr );
}


template <class T> inline
T* AtomicPointer<T>::exchange( T* newptr )
{
    return (T*) ptr_.exchange( (mAtomicPointerType) newptr );
}


template <class T> inline
T* AtomicPointer<T>::setToNull()
{
    mAtomicPointerType oldptr = (mAtomicPointerType) ptr_.get();
    while ( oldptr && !ptr_.weakSetIfEqual( 0, oldptr ) )
    {}
    
    return (T*) oldptr;
}


template <class T> inline
void AtomicPointer<T>::unRef()
{
    T* oldptr = setToNull();
    if ( oldptr )
	oldptr->unRef();
}


template <class T> inline
void AtomicPointer<T>::ref() { ((T*) ptr_ )->ref(); }


template <class T> inline
AtomicPointer<T>::operator T*() const { return (T*) ptr_.get(); }


template <class T> inline
T* AtomicPointer<T>::operator->() { return (T*) ptr_.get(); }


template <class T> inline
const T* AtomicPointer<T>::operator->() const { return (T*) ptr_.get(); }


template <class T> inline
T* AtomicPointer<T>::operator+=( int b )
{ return ptr_ += b*sizeof(T); }


template <class T> inline
T* AtomicPointer<T>::operator-=(int b)
{ return ptr_ -= b*sizeof(T); }



#define mImplAtomicPointerOperator( func, op, ret ) \
template <class T> inline \
T* AtomicPointer<T>::func \
{ \
    T* old = (T*) ptr_.get(); \
 \
    while ( !ptr_.strongSetIfEqual( (mAtomicPointerType) (op), \
			      	    (mAtomicPointerType) old ) ) \
	old = (T*) ptr_.get(); \
 \
    return ret; \
}


mImplAtomicPointerOperator( operator++(), old+1, old+1 );
mImplAtomicPointerOperator( operator--(), old-1, old-1 );
mImplAtomicPointerOperator( operator++(int), old+1, old );
mImplAtomicPointerOperator( operator--(int), old-1, old );


} //namespace

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef basicmod_h
#define basicmod_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2006
 RCS:		$Id: initheader.h.in 28999 2013-03-26 13:38:47Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#if defined( __win64__ ) || defined ( __win32__ )
# define do_import_export
#else
# ifdef do_import_export
#  undef do_import_export
# endif
#endif

#ifndef dll_export
# if defined( do_import_export )
#  define dll_export	__declspec( dllexport )
#  define dll_import	__declspec( dllimport )
#  define dll_extern	extern
# else
#  define dll_export
#  define dll_import
# endif
#endif

#if defined(Basic_EXPORTS) || defined(BASIC_EXPORTS)
# define do_export_Basic
#else
# if defined ( do_export_Basic )
#  undef do_export_Basic
# endif
#endif


#if defined( do_export_Basic )
# define Export_Basic	dll_export
# define Extern_Basic
#else
# define Export_Basic	dll_import
# define Extern_Basic	dll_extern
#endif

#if defined ( do_import_export )
//Temporary allow extern declaration of extern template instantiation
#pragma warning( push )
#pragma warning( disable : 4231 )

#pragma warning( pop )


#endif

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef bindatadesc_h
#define bindatadesc_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Feb 2001
 Contents:	Binary data interpretation
 RCS:		$Id: bindatadesc.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "gendefs.h"

#define mDeclBinDataDescConstr(T,ii,is) \
	BinDataDesc( const T* ) { set( ii, is, sizeof(T) ); } \
	BinDataDesc( const T& ) { set( ii, is, sizeof(T) ); }

/*!
\brief Description of binary data.
  
  Binary data in 'blobs' can usually be described by only a few pieces of info.
  These are:
  
  * Is the data of floating point type or integer?
  * Is the data signed or unsigned? Usually, floating point data cannot be
    unsigned.
  * How big is each number in terms of bytes? This can be 1, 2, 4 or 8
    bytes.
    
  The info from this class can be stringified (user readable string) or dumped
  binary into two unsigned chars.
  
  In normal work one will use the DataCharacteristics subclass, which can also
  provide a 'run-time' data interpreter class for fast conversion to internal
  data types.
*/

mExpClass(Basic) BinDataDesc
{
public:

    enum ByteCount	{ N1=1, N2=2, N4=4, N8=8 };

			BinDataDesc( bool ii=false, bool is=true,
				     ByteCount b=N4 )
			: isint_(ii), issigned_(is), nrbytes_(b)	{}
			BinDataDesc( bool ii, bool is, int b )
			: isint_(ii), issigned_(is),
			  nrbytes_(nearestByteCount(ii,b))	{}
			BinDataDesc( unsigned char c1, unsigned char c2 )
			    					{ set(c1,c2); }
			BinDataDesc( const char* s )		{ set(s); }
    virtual		~BinDataDesc()				{}

    inline bool		isInteger() const		{ return isint_; }
    inline bool		isSigned() const		{ return issigned_; }
    inline ByteCount	nrBytes() const			{ return nrbytes_; }
    inline void		set( bool ii, bool is, ByteCount b )
			{ isint_ = ii; issigned_ = is; nrbytes_ = b; }
    inline void		set( bool ii, bool is, int b )
			{ isint_ = ii; issigned_ = is;
			  nrbytes_ = nearestByteCount(ii,b); }
    void		setInteger( bool yn )		{ isint_ = yn; }
    void		setSigned( bool yn )		{ issigned_ = yn; }
    void		setNrBytes( ByteCount n )	{ nrbytes_ = n; }
    void		setNrBytes( int n )
			{ nrbytes_ = nearestByteCount(isint_,n); }

			// dump/restore
    virtual int		maxStringifiedSize() const	{ return 18; }
    virtual void	toString(char*) const;
			//!< Into a buffer allocated by client!
    virtual void	set(const char*);
    virtual void	dump(unsigned char&,unsigned char&) const;
    virtual void	set(unsigned char,unsigned char);

			mDeclBinDataDescConstr(signed char,true,true)
			mDeclBinDataDescConstr(short,true,true)
			mDeclBinDataDescConstr(int,true,true)
			mDeclBinDataDescConstr(unsigned char,true,false)
			mDeclBinDataDescConstr(unsigned short,true,false)
			mDeclBinDataDescConstr(unsigned int,true,false)
			mDeclBinDataDescConstr(float,false,true)
			mDeclBinDataDescConstr(double,false,true)

    inline bool		operator ==( const BinDataDesc& dc ) const
			{ return isEqual(dc); }
    inline bool		operator !=( const BinDataDesc& dc ) const
			{ return !isEqual(dc); }
    inline bool		isEqual( const BinDataDesc& dc ) const
			{
			    unsigned char c11=0, c12=0, c21=0, c22=0;
			    dump(c11,c12); dc.dump(c21,c22);
			    return c11 == c21 && c12 == c22;
			}

    int			sizeFor( int n ) const		{ return nrbytes_ * n; }
    virtual bool	convertsWellTo(const BinDataDesc&) const;

    static ByteCount	nearestByteCount( bool is_int, int s )
			{
			    if ( !is_int ) return s > 6 ? N8 : N4;
			    if ( s > 6 ) s = 8;
			    else if ( s > 2 ) s = 4;
			    else if ( s < 2 ) s = 1;
			    return (ByteCount)s;
			}

    static int		nextSize( bool is_int, int s )
			{
			    if ( s < 0 || s > 8 ) return -1;
			    if ( s == 0 )	  return is_int ? 1 : 4;
			    if ( !is_int )	  return s == 4 ? 8 : -1;
			    return s == 1 ? 2 : ( s == 2 ? 4 : 8 );
			}

protected:

    bool		isint_;
    bool		issigned_;
    ByteCount		nrbytes_;

    void		setFrom(unsigned char,bool);

};

#undef mDeclBinDataDescConstr


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef bufstring_h
#define bufstring_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		12-4-2000
 Contents:	Variable buffer length strings with minimum size.
 RCS:		$Id: bufstring.h 31616 2013-09-19 23:48:31Z bert.bril@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "convert.h"
#include <iosfwd>

class FixedString;

/*!
\brief String with variable length but guaranteed minimum buffer size.

The minimum buffer size makes life easier in worlds where strcpy etc. rule.
Overhead is 4 extra bytes for variable length and 4 bytes for minimum length.

Passing a (char*) null pointer is no problem.

Don't try to add constructors with a single basic type - this leads to nasty
hidden bugs because the compiler will try to convert all kinds of things into
BufferStrings. If you just need a string from an int, float, ..., just
use str = toString( var ). If you need the BufferString later, use:
\code
BufferString istr( "", intvar );
\endcode

*/

mExpClass(Basic) BufferString
{
public:

    inline		BufferString();
    inline		BufferString(const char*);
			BufferString(const FixedString&);
			BufferString(int minlen,bool setnull);
			BufferString(const BufferString& bs);
    template <class T>
    inline		BufferString(const char*,const T&,const char* s=0);
    virtual		~BufferString();
    inline BufferString& operator=( const BufferString& b )
						{ return assignTo(b.buf_); }

    inline BufferString& operator=( const char* s ) { return assignTo(s); }
    inline BufferString& operator=( char* s ) { return assignTo(s); }
    template <class T>
    inline BufferString& operator=(const T&);

    inline bool		operator==(const BufferString&) const;
    inline bool		operator!=(const BufferString&) const;
    bool		operator==(const char*) const;
    inline bool		operator!=(const char*) const;
    template <class T>
    inline bool		operator==(const T&) const;
    template <class T>
    inline bool		operator!=( const T& t ) const	{ return !(*this==t); }

    char*		buf();		//!< Allocation of min length guaranteed
    inline const char*	buf() const	{ return buf_ ? buf_ : empty().buf_; }
    inline const char*	str() const;	//!<\returns null pointer if empty
    char*		bufEnd()	{ return buf()+size(); }
    			/*!<Use with care, allocation beyond min length is not
			    guaranteed. */
    inline		operator const char*() const	{ return buf(); }
    inline char&	operator []( int idx )		{ return buf()[idx]; }
    inline const char&	operator []( int idx ) const	{ return buf()[idx]; }
    bool		isEmpty() const;
    void		setEmpty();
    bool		isEqual(const char*,bool caseinsens=false) const;
    bool		isStartOf(const char*,bool caseinsens=false) const;
    bool		matches(const char*,bool caseinsens=false) const;
    void                fill(char*) const; //<!Caller should ensure enough space

    BufferString&	add(const char*);
    BufferString&	add( const BufferString& b )	{ return add(b.buf()); }
    inline BufferString& operator+=( const char* s )	{ return add( s ); }
    template <class T>
    BufferString&	add(const T&);
    template <class T>
    inline BufferString& operator+=( const T& t )	{ return add( t ); }
    template <class T>
    BufferString&	set(const T&);

    unsigned int	size() const;
    inline unsigned int	bufSize() const		{ return len_; }
    void		setBufSize(unsigned int);
    inline unsigned int	minBufSize() const	{ return minlen_; }
    void		setMinBufSize(unsigned int);

    void		insertAt(int idx, const char*);
			//< If idx >= size(), pads spaces
    void		replaceAt(int idx, const char*,bool cutoff=true);
			//< If idx >= size(), pads spaces

    bool		operator >(const char*) const;
    bool		operator <(const char*) const;
    template <class T>
    inline bool		operator >(const T&) const;
    template <class T>
    inline bool		operator <(const T&) const;

    static const BufferString& empty();

protected:

    char*		buf_;
    unsigned int	len_;
    const unsigned int	minlen_;

    BufferString&	assignTo(const char*);

private:

    void		init();
    inline void		destroy()	{ delete [] buf_; buf_ = 0; }

};

/*!Not implemented. Only here to cause link-errors if used. The reason
   of not implementing is that we want to avoid promotions to 
   BufferStrings if not needed. */
mGlobal(Basic) bool operator==(const char*,const BufferString&);

/*!Not implemented. Only here to cause link-errors if used. The reason
   of not implementing is that we want to avoid promotions to 
   BufferStrings if not needed. */
mGlobal(Basic) bool operator!=(const char*,const BufferString&);


mGlobal(Basic) std::ostream& operator <<(std::ostream&,const BufferString&);
mGlobal(Basic) std::istream& operator >>(std::istream&,BufferString&);


#define mBufferStringSimpConstrInitList \
    minlen_(mMaxFilePathLength+1), buf_(0), len_(0)

inline BufferString::BufferString()
    : mBufferStringSimpConstrInitList	{}
inline BufferString::BufferString( const char* s )
    : mBufferStringSimpConstrInitList	{ assignTo(s); }

template <class T> inline
BufferString::BufferString( const char* s1, const T& t, const char* s2 )
    : mBufferStringSimpConstrInitList
{ *this += s1; *this += t; *this += s2; }


inline
const char* BufferString::str() const	
{ return isEmpty() ? 0 : buf_; }	


inline bool BufferString::operator==( const BufferString& s ) const
{ return operator ==( s.buf() ); }

template <class T> inline bool BufferString::operator==( const T& t ) const
{ return *this == Conv::to<const char*>( t ); }

inline bool BufferString::operator!=( const BufferString& s ) const
{ return operator !=( s.buf() ); }

inline  bool BufferString::operator!=( const char* s ) const
{ return ! (*this == s); }

template <class T> inline BufferString& BufferString::operator=( const T& t )
{ set( t ); return *this; }

template <class T> inline BufferString& BufferString::add( const T& t )
{ return add( toString( t ) ); }

template <class T> inline BufferString& BufferString::set( const T& t )
{ setEmpty(); return add( t ); }

template <class T> inline bool BufferString::operator >( const T& t ) const
{ return *this > ( Conv::to<const char*>( t ) ); }

template <class T> inline bool BufferString::operator <( const T& t ) const
{ return *this < ( Conv::to<const char*>( t ) ); }


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef bufstringset_h
#define bufstringset_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Oct 2003
 Contents:	Set of BufferStrings
 RCS:		$Id: bufstringset.h 29029 2013-03-28 16:06:55Z bert.bril@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstring.h"
#include "manobjectset.h"
class IOPar;
class GlobExpr;

/*!
\brief Set of BufferString objects.
*/

mExpClass(Basic) BufferStringSet : public ManagedObjectSet<BufferString>
{
public:

    			BufferStringSet(int n=0,const char* s=0);
			BufferStringSet(const char* arr[],int len=-1);
    bool		operator ==(const BufferStringSet&) const;

    BufferString&	get( int idx )		{ return *((*this)[idx]); }
    const BufferString&	get( int idx ) const	{ return *((*this)[idx]); }
    int			indexOf(const char*) const;	//!< first match
    int			indexOf(const GlobExpr&) const;	//!< first match
    int			indexOf( const BufferString* b ) const
				{ return ObjectSet<BufferString>::indexOf(b); }
    inline bool		isPresent( const BufferString* b ) const
				{ return ObjectSet<BufferString>::isPresent(b); }
    inline bool		isPresent( const char* s ) const
				{ return indexOf(s) >= 0; }
    int			nearestMatch(const char*,bool caseinsens=true) const;
			    //!< algo may not be very good, but anyway
			    //!< returns -1 if size is 0
    bool		isSubsetOf(const BufferStringSet&) const;

    BufferStringSet&	add(const char*);
    BufferStringSet&	add(const FixedString&);
    BufferStringSet&	add(const BufferString&);
    BufferStringSet&	add(const BufferStringSet&,bool allowduplicates);
    bool		addIfNew(const char*);	//!< returns whether added
    bool		addIfNew(const BufferString&);

    int			maxLength() const;
    void		sort(bool caseinsens=true,bool asc=true);
    int*		getSortIndexes(bool caseinsns=true,bool asc=true) const;
    			//!< returns new int [size()] for you to 'delete []'
    			//!< does NOT sort!! you should do useIndexes afterwards
    void		useIndexes(const int*);

    virtual void	fillPar(IOPar&) const;
    virtual void	usePar(const IOPar&);

    BufferString	cat(char sepchar='\n') const;
    void		unCat(const char*,char sepchar='\n');

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef callback_h
#define callback_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		8-11-1995
 Contents:	Notification and Callbacks
 RCS:		$Id: callback.h 30765 2013-07-17 05:50:00Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "plfdefs.h"
#include "sets.h"
#include "thread.h"
#include <string>

/*!
  In any OO system callbacks to an unknown client must be possible. To be able
  to do this in for class instances, in C++ the called functions need to be:
  1) member of a certain pre-defined base class
  2) pre-specified in terms of arguments
  The following stuff makes sure that there is a nice empty base class with that
  role. And, the Capsule mechanism ensures that any class can be passed as
  argument.
  
  There are some analogies with QT's signal/slot mechanism. We think our
  mechanism is more flexible in some ways, less in other ways (those we're not
  interested in).
*/

class CallBacker;


typedef void (CallBacker::*CallBackFunction)(CallBacker*);
#define mCBFn(clss,fn) ((CallBackFunction)(&clss::fn))

//!> To make your CallBack. Used in many places, especially the UI.
#define mCB(obj,clss,fn) CallBack( static_cast<clss*>(obj), mCBFn(clss,fn))

typedef void (*StaticCallBackFunction)(CallBacker*);
#define mSCB(fn) CallBack( ((StaticCallBackFunction)(&fn)) )


/*!
\brief CallBacks object-oriented (object + method).
  
  CallBack is nothing more than a function pointer + optionally an object to
  call it on. It may be null, in which case doCall() will simply do nothing.
  If you want to be able to send a CallBack, you must provide a 'sender'
  CallBacker* (usually 'this').
*/

mExpClass(Basic) CallBack
{
public:
			CallBack( CallBacker* o=0, CallBackFunction f=0 )
			    : obj_( o ), fn_( f ), sfn_( 0 )	{}
			CallBack( StaticCallBackFunction f )
			    : obj_( 0 ), fn_( 0 ), sfn_( f )	{}
    inline int		operator==( const CallBack& c ) const
			{ return obj_==c.obj_ && fn_==c.fn_ && sfn_==c.sfn_; }
    inline int		operator!=( const CallBack& cb ) const
			{ return !(*this==cb); }

    inline bool		willCall() const
			{ return obj_ && (fn_ || sfn_); }
    void		doCall(CallBacker*);

    inline CallBacker*			cbObj()			{ return obj_; }
    inline const CallBacker*		cbObj() const		{ return obj_; }
    inline CallBackFunction		cbFn() const		{ return fn_; }
    inline StaticCallBackFunction	scbFn() const		{ return sfn_; }

protected:

    CallBacker*				obj_;
    CallBackFunction			fn_;
    StaticCallBackFunction		sfn_;

};


/*!
\brief TypeSet of CallBacks with a few extras.
*/

mExpClass(Basic) CallBackSet : public TypeSet<CallBack>
{
public:
		CallBackSet() {}
		CallBackSet( const CallBackSet& cbs )
		    : TypeSet<CallBack>( cbs )
		{}

    void	doCall(CallBacker*,const bool* enabledflag=0,
	    		CallBacker* exclude=0);
    		/*!<\param enabledflag: if non-null, content will be checked
		  between each call, caling will stop if false.
		     \note Will lock in the apropriate moment. */

    void	removeWith(CallBacker*);
		//!<\note Should be locked before calling
    void	removeWith(CallBackFunction);
		//!<\note Should be locked before calling
    void	removeWith(StaticCallBackFunction);
		//!<\note Should be locked before calling
    
    mutable Threads::SpinLock   lock_;
};


/*!
\brief Interface class for Notifier. See comments there.
*/

mExpClass(Basic) NotifierAccess
{

    friend class	NotifyStopper;
    friend class	CallBacker;

public:

			NotifierAccess(const NotifierAccess&);
			NotifierAccess();
    virtual 		~NotifierAccess();
    
    void		notify(const CallBack&,bool first=false);
    void		notifyIfNotNotified(const CallBack&);
    void		remove(const CallBack&);
    bool		removeWith(CallBacker*,bool wait=true);
			//!<\returns false if wait was false, and trylock failed

    bool		isEnabled() const	{ return enabled_; }
    bool		enable( bool yn=true )	{ return doEnable(yn); }
    bool		disable()		{ return doEnable(false); }
    
    bool        	willCall(CallBacker*) const;
    			/*!<\returns true if the callback list contains
			     CallBacker. */

    
    CallBackSet		cbs_;
    CallBacker*		cber_;

    bool		isShutdownSubscribed(CallBacker*) const;
    			//!<Only for debugging purposes, don't use
protected:
    void		addShutdownSubscription(CallBacker*);
    bool		removeShutdownSubscription(CallBacker*, bool wait);
    			//!<\returns false if wait was false, and trylock failed
    
			/*!\returns previous status */
    inline bool		doEnable( bool yn=true )
			{
			    bool ret = enabled_;
			    enabled_ = yn;
			    return ret;
			}
    
    ObjectSet<CallBacker>	shutdownsubscribers_;
    mutable Threads::SpinLock	shutdownsubscriberlock_;

    bool			enabled_;
};


/*!
  Class to help setup a callback handling.
  
  What we have discovered is that the two things:
  - providing a notification of an event to the outside world
  - asking a notification of a certain object
  are strongly coupled. Qt has its Signal/Slot pair, but we found that too
  inflexible. Enter Notifier. You declare a Notifier to announce to the
  world that they can be notified of something. The 'receiving' object can
  then call the notify() method to 'register' the event notification. The
  sending object just calls trigger(). Note that it is most used in the
  UI, but it is equally usable in batch stuff. In general, it provides a
  rigorous uncoupling.
  
  Simply declare a Notifier<T> in the interface, like:
  \code
  Notifier<MyClass>	buttonClicked;
  \endcode
  
  Then users of the class can issue:
  
  \code
  mAttachCB( myclass.buttonClicked, TheClassOfThis,theMethodToBeCalle );
  \endcode
  
  The notifier is then attached, the connection will be remove when either the 
  notifier or the called object is deleted.
 
  The callback is issued when you call the trigger() method, like:
  \code
  buttonClicked.trigger();
  \endcode
  
  The notification can be temporary stopped using disable()/enable() pair,
  or by use of a NotifyStopper, which automatically restores the callback
  when going out of scope.  
 
  The best practice is to remove the callbacks in the destructor, as otherwise,
  you may get random crashes. Either, remove them one by one in the destructor,
  or call detachAllNotifiers(), which will remove notifiers that are attached
  using the mAttachCB macro.
*/


template <class T>
mClass(Basic) Notifier : public NotifierAccess
{
public:

    void		trigger( T& t )	{ trigger(&t); }

			// Following functions are usually used by T class only:
			Notifier( T* c ) 			{ cber_ = c; }

    inline void		trigger( CallBacker* c=0, CallBacker* exclude=0 )
			{ cbs_.doCall(c ? c : cber_, &enabled_, exclude); }
};


/*!
\brief To be able to send and/or receive CallBacks, inherit from this class.
*/

mExpClass(Basic) CallBacker
{
    friend class	NotifierAccess;
public:
			CallBacker();
			CallBacker(const CallBacker&);
    virtual 		~CallBacker();
    
    void		attachCB(NotifierAccess&,const CallBack&);
    			/*!<Adds cb to notifier, and makes sure
			    it is removed later when object is
			    deleted. */
    void		detachCB(NotifierAccess&,const CallBack&);
    			/*!<\note Normally not needed if you don't
			          want this explicitly. */
    
    bool		isNotifierAttached(NotifierAccess*) const;
    			//!<Only for debugging purposes, don't use
    
protected:
    void		detachAllNotifiers();
			//!<Call from the destructor of your inherited object
private:
    
    bool		notifyShutdown(NotifierAccess*,bool wait);
			//!<\returns false if wait was false, and trylock failed

    ObjectSet<NotifierAccess>	attachednotifiers_;
    mutable Threads::SpinLock	attachednotifierslock_;
};


#define mAttachCB( notifier, clss, func ) \
attachCB( notifier, mCB(this,clss,func) )

#define mDetachCB( notifier, clss, func ) \
detachCB( notifier, mCB(this,clss, func) )


/*!
\brief Capsule class to wrap any class into a CallBacker.
  
  Callback functions are defined as:
  void clss::func( CallBacker* )
  Sometimes you want to pass other info. For this purpose, you can use the
  CBCapsule class, which isA CallBacker, but contains T data. For convenience,
  the originating CallBacker* is included, so the 'caller' will still be
  available. 
*/

template <class T>
mClass(Basic) CBCapsule : public CallBacker
{
public:
    CBCapsule( T d, CallBacker* c )
    : data(d), caller(c)	{}
    
    T			data;
    CallBacker*		caller;
};


/*!
\ingroup Basic
\brief Unpacking data from capsule.
  
  If you have a pointer to a capsule cb, this:
  \code
  mCBCapsuleUnpack(const uiMouseEvent&,ev,cb)
  \endcode
  would result in the availability of:
  \code
  const uiMouseEvent& ev
  \endcode
  
  If you're interested in the caller, you'll need to get the capsule itself:
  \code
  mCBCapsuleGet(const uiMouseEvent&,caps,cb)
  \endcode
  would result in the availability of:
  \code
  CBCapsule<const uiMouseEvent&>* caps
  \endcode  
*/

#define mCBCapsuleGet(T,var,cb) \
CBCapsule<T>* var = dynamic_cast< CBCapsule<T>* >( cb );

#define mCBCapsuleUnpack(T,var,cb) \
mCBCapsuleGet(T,cb##caps,cb) \
T var = cb##caps->data

#define mCBCapsuleUnpackWithCaller(T,var,cber,cb) \
mCBCapsuleGet(T,cb##caps,cb) \
T var = cb##caps->data; \
CallBacker* cber = cb##caps->caller

# ifdef __msvc__
#  pragma warning ( push )
#  pragma warning( disable : 4700 )
# endif	

/*!
\brief Notifier with automatic capsule creation.
  
  When non-callbacker data needs to be passed, you can put it in a capsule.
  
  You'll need to define:
  
  \code
  CNotifier<MyClass,const uiMouseEvent&>	mousepress;
  \endcode  
*/
	

template <class T,class C>
mClass(Basic) CNotifier : public NotifierAccess
{
public:

    void		trigger( C c, T& t )		{ trigger(c,&t); }

// Following functions are usually used by T class only:

			CNotifier( T* cb )	{ cber_ = cb; }
	

    inline void		trigger( CallBacker* cb=0 )
			    { if( !enabled_ ) return; C c; trigger(c,cb); }


    inline void		trigger( C c, CallBacker* cb=0 )
			{
			    if ( enabled_ )
			    {
				CBCapsule<C> caps( c, cb ? cb : cber_ );
				cbs_.doCall( &caps, &enabled_ );
			    }
			}
};

# ifdef __msvc__
#  pragma warning ( pop )
# endif
/*!
\brief Temporarily disables a Notifier.
  
  Notifiers can be disabled. To do that temporarily, use NotifyStopper.
  If the Stopper goes out of scope, the callback is re-enabled. like:
  
  void xxx:doSomething()
  {
      NotifyStopper stopper( a_notifier );
      // Doing things that would otherwise trigger Notifier.
      // On exit, Notifier gets re-enabled automatically.
  }
*/

mExpClass(Basic) NotifyStopper 
{
public:
			NotifyStopper( NotifierAccess& na ) 
			    : oldst_(na.doEnable(false))
			    , thenotif_(na)	{}

    inline		~NotifyStopper()	{ restore(); }

    inline void		enable()		{ thenotif_.doEnable(false); }
    inline void		disable()		{ thenotif_.doEnable(true); }
    inline void		restore()		{ thenotif_.doEnable(oldst_);}

protected:

    NotifierAccess& 	thenotif_;
    bool		oldst_;

};


// Set of macros to add an instanceCreated() notifier
// This can provide a notification of any instance of a class being produced

#define mDeclInstanceCreatedNotifierAccess(clss) \
    static Notifier<clss>&	instanceCreated()

#define mDefineInstanceCreatedNotifierAccess(clss) \
Notifier<clss>& clss::instanceCreated() \
{ \
    static Notifier<clss> theNotif(0); \
    return theNotif; \
}

#define mTriggerInstanceCreatedNotifier() \
    instanceCreated().trigger( this )


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef changetracker_h
#define changetracker_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        A.H. Bril
 Date:          26/09/2000
 RCS:           $Id: changetracker.h 30807 2013-07-18 07:00:34Z ranojay.sen@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "gendefs.h"
#include "fixedstring.h"
#include <string.h>

/*!
\brief Updates a variable when changes occur.
  
  Use if you need to keep track of whether a variable changes when it is
  assigned to another variable. Example: a 'not saved' flag in a UI. Also 
  facilitates giving unique change stamps.
*/

mClass(Basic) ChangeTracker
{
public:
			ChangeTracker( bool* c=0 )
			: chgd(c), chgid(0)		{}
			ChangeTracker( bool& c )
			: chgd(&c), chgid(0)		{}
			ChangeTracker( unsigned int& c )
			: chgid(&c), chgd(0)		{}
			ChangeTracker( unsigned int* c )
			: chgid(c), chgd(0)		{}
			ChangeTracker( bool& c, unsigned int& ci )
			: chgd(&c), chgid(&ci)		{}

			//! returns wether this value is changed
    template <class T,class U>
    inline bool		set(const T& oldval,const U& newval);
			//! Changes and returns wether this value is changed
    template <class T,class U>
    inline bool		update(T& val,const U& newval);

			//! specialisation for C-strings
    inline bool		set(const char*&,const char*&);
			//! specialisation for C-strings
    inline bool		update(char*&,const char*&);

    bool		isChanged() const
    			{ return chgd ? *chgd : (bool)(chgid ? *chgid : 0); }
    unsigned int	changeId() const
    			{ return chgid ? *chgid : (chgd ? (*chgd?1:0) : 0); }
    inline void		setChanged(bool yn=true);
    void		setChangeId( unsigned int c )
    			{ if ( chgid ) *chgid = c; }

    bool		hasBoolVar() const		{ return chgd; }
    bool		hasIntVar() const		{ return chgid; }
    const bool&		boolVar() const			{ return *chgd; }
			//!< Don't call if !hasBoolVar()
    const unsigned int&	intVar() const			{ return *chgid; }
			//!< Don't call if !hasIntVar()

    void		setVar( bool* m )		{ chgd = m; }
    void		setVar( bool& m )		{ chgd = &m; }
    void		setVar( unsigned int* m )	{ chgid = m; }
    void		setVar( unsigned int& m )	{ chgid = &m; }

protected:

    bool*		chgd;
    unsigned int*	chgid;

};


/*!
\ingroup Basic
\brief Macro to use when there is no direct access to data members.
  
  chtr = the change tracker
  obj = object instance
  getfn = get function
  setfn - set function
  newval = new value
*/

#define mChgTrackGetSet(chtr,obj,getfn,setfn,newval) { \
    if ( chtr.set( obj->getfn(), newval ) ) \
	obj->setfn( newval ); }


inline void ChangeTracker::setChanged( bool ischgd )
{
    if ( chgd )
	{ if ( !*chgd ) *chgd = ischgd; }
    else if ( chgid )
	{ if ( ischgd ) (*chgid)++; }
}


template <class T,class U>
inline bool ChangeTracker::set( const T& val, const U& newval )
{
    bool ret = !(val ==  mCast(T,newval));
    setChanged( ret );
    return ret;
}


inline bool ChangeTracker::set( const char*& val, const char*& newval )
{
    bool ret = (val && newval) || (!val && !newval);
    if ( !ret ) { setChanged(true); return true; }
    if ( !val ) return false;

    ret = FixedString(val)!=newval;
    setChanged( ret );
    return ret;
}


template <class T,class U>
inline bool ChangeTracker::update( T& val, const U& newval )
{
    bool ret = set( val, newval );
    val = newval;
    return ret;
}


inline bool ChangeTracker::update( char*& val, const char*& newval )
{
    bool ret = set( *((const char**)(&val)), newval );
    if ( val ) strcpy( val, newval ? newval : "" );
    return ret;
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef color_h
#define color_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		22-3-2000
 RCS:		$Id: color.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/


#include "basicmod.h"
#include "gendefs.h"
class BufferStringSet;
template <class T> class TypeSet;


/*!
\brief Color is an RGB color object, with a transparancy. The storage is in
a 4-byte integer, similar to Qt.
*/

mExpClass(Basic) Color
{
public:

			Color( unsigned char r_=255, unsigned char g_=255,
				unsigned char b_=255, unsigned char t_=0 );
			Color( unsigned int rgbval );

    bool		operator ==( const Color& c ) const;
    bool		operator !=( const Color& c ) const;

    unsigned char	r() const;
    unsigned char	g() const;
    unsigned char	b() const;
    unsigned char	t() const;

    bool		isVisible() const;

    unsigned int	rgb() const;
    unsigned int&	rgb();

    void         	set( unsigned char r_, unsigned char g_,
			     unsigned char b_, unsigned char t_=0 );

    Color		complementaryColor() const;
    Color		operator*(float) const;
    void		lighter( float f=1.1 );
    void        	setRgb( unsigned int rgb_  );
    void		setTransparency( unsigned char t_ );
    void		setHSV(unsigned char h,unsigned char s,unsigned char v);
    void		getHSV(unsigned char&,unsigned char&,
	    		       unsigned char&) const;
    void		setStdStr(const char*); //!< e.g. "#00ff32"
    const char*		getStdStr(bool withhash=true,
	    			  int transpopt=0) const;
    			//!< without hash Google KML standard -> order reversed
    			//!< transpopt -1=opacity 0=not 1=transparency

    void		fill(char*) const;
    bool		use(const char*);

    static Color	NoColor()	{ return  Color(0,0,0,255); }

    static Color	Black()		{ return  Color(0,0,0,0); }
    static Color	White()		{ return  Color(255,255,255,0); }
    static Color	DgbColor()	{ return  Color(2,240,4,0); }
    static Color	LightGrey()	{ return  Color(211,211,211,0); }
    static Color	Peach()		{ return  Color(255,218,185,0); }
    static Color	Red()		{ return  Color(255,0,0,0); }

    static unsigned char getUChar( float v );

    static int		nrStdDrawColors();
    static Color	stdDrawColor(int);

    const char*				largeUserInfoString() const;
    const char*				getDescription() const;
    bool				fromDescription(const char*);
    static const BufferStringSet&	descriptions();
    static const TypeSet<Color>&	descriptionCenters();

protected:

    unsigned int	col_;
};


namespace Values {

/*!
\brief Undefined Color.
*/

template<>
mClass(Basic) Undef<Color>
{
public:
    static Color	val()			{ return Color::NoColor(); }
    static bool		hasUdf()		{ return false; }
    static bool		isUfd(Color& col)	{ return false; }
    static void		setUdf(Color& col)	{}
};

}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef argvparser_h
#define argvparser_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		March 2013
 RCS:		$Id: commandlineparser.h 29023 2013-03-28 11:34:09Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________



-*/

#include "bufstringset.h"

/*!Parser that takes the argc and argv and makes them parsable. An argument
   starting with -- is considered a key, as well as arguments starting with "-",
   if not imedialtely followed by a number. Hence -create is a key, -9 or -.3
   are not.

   "bin/my_prog --nriter 4 parfile1.par --fast parfile2.par"
   can be parsed as follows:

\code
    CommandLineParser parser;
    parser.setKeyHasValue("nriter"); //Makes it handle "4" as a value
 
    const BufferString exec = parser.getExecutable(); //returns "bin/my_prog"

    int nriter;
    if ( !parser.getVal( "nriter", nriter ) )
        return false;
    
    const bool fast = parser.hasKey("fast");

    BufferStringSet parfiles;
    getNormalArguments( parfiles );
    if ( parfiles.isEmpty() ) //Will have "parfile1.par" and "parfile2.par"
        return false;

\endcode
 */


mExpClass(Basic) CommandLineParser
{
public:
				CommandLineParser(int argc,char** argv);
				CommandLineParser();
				/*!<Actual command line is used, i.e. the one
				    set by SetProgramArgs */
    
    void			setKeyHasValue(const char* key);
				/*!<Tell the parser that the argument after key
				    is a value. This is only neeed if you
				    will use getNormalArguments. */
    void			getNormalArguments(BufferStringSet&) const;
				/*!<Gets all arguments that are not keys or
				    key-values. */
    
    bool			hasKey(const char*) const;
    template <class T> bool	getVal(const char* key,T&,
	    			       bool acceptnone=false) const;
				/*!<Will parse the argument following key
				    If acceptnone is true, it will only give
				    error if key is found, but no value can be
				    parsed. */
    
    bool			isPresent(const char*) const;
				//!<Is string present as an argument.
    
    int				nrArgs() const		{ return argv_.size(); }
				/*!<\returns the lump sum (keys, values, and
				    everything else, but program nam	e */
    
    bool			isKey(int) const;
				//!<Does the arg start with - or  --
    bool			isKeyValue(int idx) const;
				/*!<True if not a key, and previous is a key
				    that has been set using setKeyHasValue. */
    
    const BufferString&		getArg(int idx) const	{ return *argv_[idx]; }
    const BufferString&		lastArg() const;
    
    const BufferString&		getExecutable() const;
    const BufferString&		getExecutableName() const;
    
    static void			createKey(const char* key,BufferString& res)
				{ res = "--"; res += key; }

private:
    
    int				indexOf(const char*) const;
    void			init(int,char**);

    BufferString		progname_;
    BufferString		executable_;
    BufferStringSet		argv_;
    
    BufferStringSet		keyswithvalue_;
};

//Implementation

template <class T> inline
bool CommandLineParser::getVal( const char* key, T& val, bool acceptnone ) const
{
    const int keyidx = indexOf( key );
    if ( keyidx<0 )
	return acceptnone;

    const int validx = keyidx+1;
    if ( !argv_.validIdx( validx ) )
	return false;
    
    if ( isKey(validx) )
	return false;

    return getFromString( val, argv_[validx]->buf() );
}

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef commondefs_h
#define commondefs_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2006
 RCS:		$Id: commondefs.h 32200 2013-10-31 09:07:11Z aneesh.tiwari@dgbes.com $
________________________________________________________________________

 Some very commonly used macros.

-*/

#include "basicmod.h"
#include "plfdefs.h"
#include "rounding.h"

#define mRounded(typ,x)		roundOff<typ>( x )
#define mNINT32(x)		mRounded( od_int32, x )
#define mNINT64(x)		mRounded( od_int64, x )
#define mCast(tp,v)		((tp)(v))

#define mSWAP(x,y,tmp)		{ tmp = x; x = y; y = tmp; }
#define mMAX(x,y)		( (x)>(y) ? (x) : (y) )
#define mMIN(x,y)		( (x)<(y) ? (x) : (y) )

#define mIsZero(x,eps)		( (x) < (eps) && (x) > (-eps) )
#define mIsEqual(x,y,eps)	( (x-y) < (eps) && (x-y) > (-eps) )
#define mIsEqualRel(x,y,e)	( (y) ? ((x)/(y))-1<(e) && ((x)/(y)-1)>(-e) \
				      : mIsZero(x,e) )
#define mIsEqualWithUdf(x,y,e)	((mIsUdf(x) && mIsUdf(y)) || mIsEqual(x,y,e) )
#define mDefEpsF		(1e-10f)
#define mDefEpsD		(1e-10)
#define mDefEps			mDefEpsD

# define mC_True	1
# define mC_False	0

#ifndef M_PI
# define M_PI		3.14159265358979323846
#endif

#ifndef M_PI_2
# define M_PI_2		1.57079632679489661923
#endif

#ifndef M_PI_4
# define M_PI_4		0.78539816339744830962
#endif

#ifndef M_SQRT2
#  define M_SQRT2       1.41421356237309504880168872421
#endif

#ifndef M_SQRT1_2
# define M_SQRT1_2	0.70710678118654752440
#endif

//Float versions
#ifndef M_PIf
# define M_PIf		3.14159265358979323846f
#endif

#ifndef M_PI_2f
# define M_PI_2f	1.57079632679489661923f
#endif

#ifndef M_PI_4f
# define M_PI_4f	0.78539816339744830962f
#endif

#ifndef M_SQRT2f
#  define M_SQRT2f      1.41421356237309504880168872421f
#endif

#ifndef M_SQRT1_2f
# define M_SQRT1_2f	0.70710678118654752440f
#endif


#ifndef MAXFLOAT
# define MAXFLOAT	3.4028234663852886e+38F
#endif

#ifndef MAXDOUBLE
# define MAXDOUBLE	1.7976931348623157e+308
#endif

#ifndef MAXSIZE
# define MAXSIZE	((size_t)-1)
#endif

#ifdef __win__
# include <stdio.h>
# undef small
#endif


#define mFromFeetFactorF	0.3048f
#define mFromFeetFactorD	0.3048
#define mToFeetFactorF		3.2808399f
#define mToFeetFactorD		3.28083989501312336
#define mToSqMileFactor		0.3861 			//km^2 to mile^2
#define mMileToFeetFactor	5280
#define mToPercent(f)		(mIsUdf(f) ? f : f*100)
#define mFromPercent(p)		(mIsUdf(p) ? p : p*0.01)


#ifdef __msvc__
# include "msvcdefs.h"
#else
# define dll_export
# define dll_import


# define mMaxFilePathLength	255

# define mPolyRet(base,clss)	clss
# define mTFriend(T,clss)	template <class T> friend class clss
# define mTTFriend(T,C,clss)	template <class T, class C> friend class clss
# define mProtected		protected
# define mPolyRetDownCast(clss,var)	var
# define mPolyRetDownCastRef(clss,var)	var
# define mDynamicCast(typ,out,in)	out = dynamic_cast< typ >( in );
# define mDynamicCastGet(typ,out,in)	typ mDynamicCast(typ,out,in)

#endif

#define mTODOHelpID	"0.0.0"
#define mNoHelpID	"-"

//Comment out mDoWindowsImport to turn off import/export on windows.
// herman
//#define mDoWindowsImport

#ifndef mDoWindowsImport
#define mExp( module )			dll_export
#define mExportInst( mod, tp, inst )
#else
#define mExp( module )			Export_##module
#define mExportInst( mod, tp, inst )	Extern_##mod tp mExp(mod) inst
#endif

#define mExpClass( module )		class mExp( module )
#define mExpStruct( module )		struct mExp( module )

#define mGlobal( module )		mExp( module )
#define mClass( module )		class
#define mStruct( module )		mExpStruct( module )
#define mExtern( module )		extern mExp( module )
#define mExternC( module)		extern "C" mExp( module )

#define mExportTemplClassInst(mod,clss)	mExportInst(mod,template class,clss)

#ifdef __win__
#ifdef __cpp__
namespace Threads
{
    mGlobal(Basic) bool lockSimpleSpinWaitLock(volatile int& lock);
    mGlobal(Basic) void unlockSimpleSpinLock(volatile int& lock);
}
#endif

#define mLockStaticInitLock( nm ) \
static volatile int nm = 0; \
Threads::lockSimpleSpinWaitLock( nm )

#define mUnlockStaticInitLock( nm ) \
Threads::unlockSimpleSpinLock( nm )

#else

#define mLockStaticInitLock( nm ) 
#define mUnlockStaticInitLock( nm )

#endif

#define mDefineStaticLocalObject( type, var, init ) \
mLockStaticInitLock( static##var##lck__ ); \
static type var init; \
mUnlockStaticInitLock( static##var##lck__ )


//for Qt
#ifndef QT_NAMESPACE
# define mFDQtclass(cls) class cls;
# define mQtclass(cls) cls
# define mUseQtnamespace
#else
# define mFDQtclass(cls) namespace QT_NAMESPACE { class cls; }
# define mQtclass(cls) ::QT_NAMESPACE::cls
# define mUseQtnamespace using namespace ::QT_NAMESPACE;
#endif

#define mIfNotFirstTime(act) \
    static bool _already_visited_ = false; \
    if ( _already_visited_ ) act; \
    _already_visited_ = true

// Helps keep 4.4 compatibility
#define mDefClass( module )	mExpClass( module )


#endif



/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef compoundkey_h
#define compoundkey_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		15-1-2000
 RCS:		$Id: compoundkey.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/


#ifndef general_h
#include "basicmod.h"
#include "general.h"
#endif
#include <stdlib.h>
#include <iostream>

/*!
\brief Concatenated short keys separated by dots.
  
  Usage is for Object identifiers in the Object Manager, or UnitIDs.
  
  A Compound Key Glob Expression is a string used for matching.
  It is similar to a UNIX-type glob expression.
*/

mExpClass(Basic) CompoundKey
{
public:

    inline		CompoundKey( const char* s=0 )	{ if ( s ) id_ = s; }
    inline		CompoundKey( const CompoundKey& ck ) 
			: id_(ck.id_)			{}
    inline CompoundKey&	operator=(const char* s)	{id_ = s; return *this;}
    inline CompoundKey&	operator+=(const char*);
    inline bool		operator==(const char* s) const	{ return id_ == s; }
    inline bool		operator==(const CompoundKey& u) const
							{ return id_ == u.id_; }
    inline bool		operator!=(const char* s) const	{ return id_ != s; }
    inline bool		operator!=(const CompoundKey& u) const
							{ return id_ != u.id_; }
    inline void		setEmpty()			{ id_.setEmpty(); }
    inline bool		isEmpty() const			{ return id_.isEmpty();}
    inline char*	buf()				{ return id_.buf(); }
    inline const char*	buf() const			{ return id_.buf(); }
    inline		operator const char*() const	{ return buf(); }

    int			nrKeys() const;
    BufferString	key(int) const;
    void		setKey(int,const char*);
    CompoundKey		upLevel() const;
    bool		isUpLevelOf(const CompoundKey&) const;

protected:

    BufferString	id_;
    char*		fromKey(int,bool cptobuf=false) const;
    friend std::istream& operator >>(std::istream&,CompoundKey&);

};


inline CompoundKey& CompoundKey::operator +=( const char* s )
{
    if ( !id_.isEmpty() ) id_ += ".";
    id_ += s;
    return *this;
}

mGlobal(Basic) std::ostream& operator<<(std::ostream&,const CompoundKey&);


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef conn_h
#define conn_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		21-10-1995
 Contents:	Connections with data providers (Streams, databases)
 RCS:		$Id: conn.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/


#include "basicmod.h"
#include "enums.h"
class IOObj;

/*!
\brief Data connection.
  
  Data can be found in files and data stores. To access these data sources,
  some kind of connection must be set up. This class defines a simple
  interface common to these connections.
*/

mExpClass(Basic) Conn
{
public:

    enum State		{ Bad, Read, Write, RW };

			Conn()	: ioobj(0)	{}
    virtual		~Conn()			{}

    virtual State	state() const		= 0;
    virtual const char*	connType() const	= 0;
    virtual bool	bad() const		{ return state() == Bad; }
    virtual bool	forRead() const		{ return (int)state() % 2; }
    virtual bool	forWrite() const	{ return (int)state() >= Write;}
    virtual void	close()			{}
    virtual bool	isStream() const	{ return false; }

    inline Conn*	conn()			{ return gtConn(); }
    inline const Conn*	conn() const		{ return gtConn(); }
			//!< Returns the actual connection doing the work

    IOObj*		ioobj;
			//!< Some objects require this IOObj
			//!< It is normally the IOObj that created the Conn

protected:

    virtual Conn*	gtConn() const	{ return const_cast<Conn*>(this); }

};


/*!
\brief Connection implemented in terms of another Conn object.
*/

mExpClass(Basic) XConn  : public Conn
{

    friend class	IOX;

public:
			XConn()
			: conn_(0), mine_(true)		{}
			~XConn()
			{ if ( mine_ ) delete conn_; }

    virtual State	state() const
			{ return conn_ ? conn_->state() : Conn::Bad; }

    void		setConn( Conn* c, bool becomesmine=true )
			{ if ( mine_ ) delete conn_;
			  conn_ = c; mine_ = becomesmine; }
    void		close()
			{ if ( conn_ ) conn_->close(); }

    const char*		connType() const	{ return sType(); }
    static const char*	sType()			{ return "X-Group"; }

protected:

    Conn*		conn_;
    bool		mine_;

    Conn*		gtConn() const	{ return const_cast<Conn*>(conn_); }

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef convert_h
#define convert_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        A.H. Lammertink
 Date:          13/01/2005
 RCS:           $Id: convert.h 29656 2013-05-06 06:28:27Z bert.bril@dgbes.com $
________________________________________________________________________

-*/

#include "undefval.h"
#include "fixedstring.h"
#include "string2.h"

#ifdef __msvc__
# include "msvcdefs.h"
#endif

/*!\brief Template based type conversion. */

namespace Conv{

//! template based type conversion
template <class T, class F>
inline void set( T& _to, const F& fr )
    { _to = (T)fr; }

template <class T, class F>
inline T to( const F& fr )
{ 
    T ret;
    Values::setUdf(ret);
    set<T,F>(ret,fr);

    return ret;
}


//! template based type converstion, with check for undef
template <class T, class F>
inline void udfset(T& _to, const F& fr, const T& und= Values::Undef<T>::val())
{
    if ( Values::hasUdf<F>() && Values::isUdf(fr) )
	_to = und;
    else 
    {
	set(_to,fr);
	if ( Values::isUdf(_to) ) _to = und;
    }
}

template <class T, class F>
inline T udfto( const F& fr, const T& und = Values::Undef<T>::val() )
{ 
    T ret;
    Values::setUdf(ret);
    udfset<T,F>(ret,fr,und);

    return ret;
}


//----- specialisations

template <>
inline void set( const char*& _to, const od_int32& i )
    { _to = toString(i); }

template <>
inline void set( const char*& _to, const od_uint32& i )
    { _to = toString(i); }

template <>
inline void set( const char*& _to, const od_int64& i )
    { _to = toString(i); }

template <>
inline void set( const char*& _to, const od_uint64& i )
    { _to = toString(i); }

template <>
inline void set( const char*& _to, const bool& b )
    { _to = toString(b); }

template <>
inline void set( const char*& _to, const float& f )
    { _to = toString(f); }

template <>
inline void set( const char*& _to, const double& d )
    { _to = toString(d); }

template <>
inline void set( const char*& _to, const short& i )
    { _to = toString(i); }

template <>
inline void set( const char*& _to, const unsigned short& i )
    { _to = toString(i); }


#define mConvDefFromStrToFn(type,function) \
template <> \
inline void set( type& _to, const char* const& s ) \
{ \
    if ( !s || !*s ) { return; } \
\
    char* endptr; \
    type tmpval = (type) function; \
    if ( s != endptr ) \
	_to = (type) tmpval; \
    else if ( Values::Undef<type>::hasUdf() ) \
	    Values::setUdf( _to ); \
} \
template <> \
inline void set( type& _to, const FixedString& s ) \
{ \
    if ( !s ) { return; } \
\
    char* endptr; \
    type tmpval = (type) function; \
    if ( s.str() != endptr ) \
	_to = (type) tmpval; \
    else if ( Values::Undef<type>::hasUdf() ) \
	    Values::setUdf( _to ); \
} 

mConvDefFromStrToFn( int, (int)strtol(s,&endptr,0) )
mConvDefFromStrToFn( od_uint32, (od_uint32)strtoul(s,&endptr,0) )
mConvDefFromStrToFn( od_int64, strtoll(s,&endptr,0) )
mConvDefFromStrToFn( od_uint64, strtoull(s,&endptr,0) )
mConvDefFromStrToFn( double, strtod(s,&endptr) )
mConvDefFromStrToFn( float, strtof(s,&endptr) )

#undef mConvDefFromStrToFn

template <>
inline void set( bool& _to, const FixedString& s )
    { _to = yesNoFromString(s.str()); }


#define mConvDefFromStrToFn(type,fn) \
template <> \
inline void set( type& _to, const char* const& s ) \
    { _to = (type)fn(s); }


mConvDefFromStrToFn( short, atoi )
mConvDefFromStrToFn( unsigned short, atoi )

#undef mConvDefFromStrToFn

    
template <>
inline void set( bool& _to, const char* const& s )
    { _to = yesNoFromString(s); }

template <>
inline void set( od_int32& _to, const float& f )
    { _to = mRounded(od_int32,f); }

template <>
inline void set( od_int64& _to, const float& f )
    { _to = mRounded(od_int64,f); }

template <>
inline void set( short& _to, const float& f )
    { _to = mRounded(short,f); }

template <>
inline void set( unsigned short& _to, const float& f )
    { _to = mRounded(od_uint16,f); }

template <>
inline void set( od_uint32& _to, const float& f )
    { _to = mRounded(od_uint32,f); }

template <>
inline void set( od_uint64& _to, const float& f )
    { _to = mRounded(od_uint64,f); }

template <>
inline void set( od_int32& _to, const double& f )
    { _to = mRounded(od_int32,f); }

template <>
inline void set( od_int64& _to, const double& f )
    { _to = mRounded(od_int64,f); }

template <>
inline void set( short& _to, const double& f )
    { _to = mRounded(short,f); }

template <>
inline void set( unsigned short& _to, const double& f )
    { _to = mRounded(od_uint16,f); }

template <>
inline void set( od_uint32& _to, const double& f )
    { _to = mRounded(od_uint32,f); }

template <>
inline void set( od_uint64& _to, const double& f )
    { _to = mRounded(od_uint64,f); }

template <>
inline void set( bool& _to, const int& i )
    { _to = i!=0; }

template <>
inline void set( bool& _to, const float& f )
    { _to = !mIsZero(f,mDefEpsF); }

template <>
inline void set( bool& _to, const double& d )
    { _to = !mIsZero(d,mDefEpsD); }


}
#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef cubesampling_h
#define cubesampling_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bert
 Date:          Feb 2002
 RCS:           $Id: cubesampling.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "horsampling.h"


/*!
\brief Hor+Vert sampling in 3D surveys.

  When slices are to be taken from a CubeSampling, they should be ordered
  as follows:
 
  Dir |   Dim1    Dim2
  ----|---------------
  Inl |   Crl     Z
  Crl |   Inl     Z
  Z   |   Inl     Crl

  See also the direction() and dimension() free functions.
*/

mExpClass(Basic) CubeSampling
{
public:

    			CubeSampling( bool settoSI=true )
			: hrg(settoSI)		{ init(settoSI); }

    enum Dir		{ Z, Inl, Crl };
    Dir			defaultDir() const;
    			//!< 'flattest' direction, i.e. direction with
    			//!< smallest size. If equal, prefer Inl then Crl then Z
    Coord3		defaultNormal() const;
    bool		isFlat() const; //!< is one of directions size 1?

    void		init(bool settoSI=true);
    			//!< Sets hrg.init and zrg to survey values or zeros
    inline void		setEmpty()		{ init(false); }
    void		set2DDef();
    			//!< Sets to survey zrange and hrg.set2DDef
    void		normalise();
    			//!< Makes sure start<stop and steps are non-zero

    HorSampling		hrg;
    StepInterval<float>	zrg;

    inline int		inlIdx( int inl ) const	{ return hrg.inlIdx(inl); }
    inline int		crlIdx( int crl ) const	{ return hrg.crlIdx(crl); }
    inline int		zIdx( float z ) const	{ return zrg.getIndex(z); }
    inline int		nrInl() const		{ return hrg.nrInl(); }
    inline int		nrCrl() const		{ return hrg.nrCrl(); }
    inline int		nrZ() const		{ return zrg.nrSteps() + 1; }
    od_int64		totalNr() const;
    inline int		size( Dir d ) const	{ return d == Inl ? nrInl()
    						      : (d == Crl ? nrCrl()
							          : nrZ()); }
    inline float	zAtIndex( int idx ) const
						{ return zrg.atIndex(idx); }
    inline bool		isEmpty() const		{ return hrg.isEmpty(); }
    bool		isDefined() const;
    bool		includes(const CubeSampling&) const;
    bool		getIntersection(const CubeSampling&,
	    				CubeSampling&) const;
    			//!< Returns false if intersection is empty
    void		include(const BinID&,float z);
    void		include(const CubeSampling&);
    void		limitTo(const CubeSampling&);
    void		limitToWithUdf(const CubeSampling&);
    			/*!< handles undef values + returns reference cube 
			     nearest limit if the 2 cubes do not intersect */

    void		snapToSurvey();
    			/*!< Checks if it is on valid bids and sample positions.
			     If not, it will expand until it is */

    bool		operator==( const CubeSampling& cs ) const;
    bool		operator!=( const CubeSampling& cs ) const
			{ return !(cs==*this); }

    bool		usePar(const IOPar&);
    void		fillPar(IOPar&) const;
    static void		removeInfo(IOPar&);
};


inline CubeSampling::Dir direction( CubeSampling::Dir slctype, int dimnr )
{
    if ( dimnr == 0 )
	return slctype;
    else if ( dimnr == 1 )
	return slctype == CubeSampling::Inl ? CubeSampling::Crl
	    				    : CubeSampling::Inl;
    else
	return slctype == CubeSampling::Z ? CubeSampling::Crl : CubeSampling::Z;
}


inline int dimension( CubeSampling::Dir slctype, CubeSampling::Dir direction )
{
    if ( slctype == direction )
	return 0;

    else if ( direction == CubeSampling::Z )
	return 2;
    else if ( direction == CubeSampling::Inl )
	return 1;

    return slctype == CubeSampling::Z ? 2 : 1;
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef datapack_h
#define datapack_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Jan 2007
 RCS:		$Id: datapack.h 30713 2013-07-12 10:31:48Z bert.bril@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "namedobj.h"
#include "manobjectset.h"
#include "multiid.h"
#include "threadlock.h"
#include <iosfwd>

class DataPackMgr;
class IOPar;


/*!
\brief A data packet: data+positioning and more that needs to be shared.

  The 'category' is meant like:
  'Pre-Stack gather'
  'Wavelet'
  'Fault surface'
*/

mExpClass(Basic) DataPack : public NamedObject
{
public:

    typedef int		ID;
    typedef MultiID	FullID;
    inline static ID	getID( const FullID& fid )	{ return fid.ID(1); }

    			DataPack( const char* categry )
			    : NamedObject("<?>")
			    , category_(categry)
			    , nrusers_( 0 )
			    , id_(getNewID())	{}
			DataPack( const DataPack& dp )
			    : NamedObject( dp.name().buf() )
			    , category_( dp.category_ )
			    , nrusers_( 0 )
			    , id_(getNewID())	{}
    virtual		~DataPack()		{}

    ID			id() const		{ return id_; }
    FullID		fullID( int mgrid ) const { return FullID(mgrid,id()); }
    virtual const char*	category() const	{ return category_.buf(); }

    virtual float	nrKBytes() const	= 0;
    virtual void	dumpInfo(IOPar&) const;

    static const char*	sKeyCategory();
    static ID		cNoID()			{ return 0; }

    virtual bool	isOK() const 		{ return true; }

    Threads::Lock&	updateLock() const	{ return updatelock_; }

protected:

    const ID			id_;
    const BufferString		category_;
    mutable int			nrusers_;
    mutable Threads::Lock	nruserslock_;
    mutable Threads::Lock	updatelock_;

    static ID		getNewID(); 	//!< ensures a global data pack ID
    static float	sKb2MbFac();	//!< 1 / 1024

    void		setCategory( const char* c )
    			{ *const_cast<BufferString*>(&category_) = c; }

    friend class	DataPackMgr;
};


/*!
\brief Simple DataPack based on an unstructured char array buffer.
*/

mExpClass(Basic) BufferDataPack : public DataPack
{
public:

    			BufferDataPack( char* b=0, od_int64 s=0,
					const char* catgry="Buffer" )
			    : DataPack(catgry)
			    , buf_(b)
			    , sz_(s)		{}
			~BufferDataPack()	{ delete [] buf_; }

    char*		buf()			{ return buf_; }
    char const*		buf() const		{ return buf_; }
    od_int64		size() const		{ return sz_; }
    void		setBuf( char* b, od_int64 s )
			{ delete [] buf_; sz_ = s; buf_ = b; }

    virtual float	nrKBytes() const	{ return sz_*sKb2MbFac(); }

protected:

    char*		buf_;
    od_int64		sz_;

};


/*!
\brief Manages DataPacks.
  
  DataPacks will be managed with everything in it. If you add a Pack, you
  will get the ID of the pack.
  
  When you obtain the data for looking at it, you can choose to 'only observe'.
  In that case, you'd better use the packToBeRemoved notifier, as the data may
  be deleted at any time. Normally, you want to obtain a reference whilst
  making sure the data is not thrown away.
  
  This means you *must* release the data pack once you no longer use it, but
 *NEVER* release a pack when you used the 'observing_only' option.
 
 You can get an appropriate DataPackMgr from the DPM() function.
*/

mExpClass(Basic) DataPackMgr : public CallBacker
{
public:
			// You can, but normally should not, construct
			// a manager. In general, leave it to DPM() - see below.

    typedef int		ID;		//!< Each Mgr has its own ID
    inline static ID	getID( const DataPack::FullID& fid )
    						{ return fid.ID(0); }

    bool		haveID(DataPack::ID) const;
    inline bool		haveID( const DataPack::FullID& fid ) const
			{ return id() == fid.ID(0) && haveID( fid.ID(1) ); }

    void		add(DataPack*);
    			//!< The pack becomes mine
    DataPack*		addAndObtain(DataPack*);
    			/*!< The pack becomes mines. Pack is obtained
			     during the lock, i.e. threadsafe. */

    inline DataPack*	obtain( DataPack::ID dpid, bool observing_only=false )
			{ return doObtain(dpid,observing_only); }
    inline const DataPack* obtain( DataPack::ID dpid, bool obsrv=false ) const
			{ return doObtain(dpid,obsrv); }

    void		release(DataPack::ID);
    void		release( const DataPack* dp )
    			{ if ( dp ) release( dp->id() ); }
    void		releaseAll(bool donotify);

    Notifier<DataPackMgr> newPack;		//!< Passed CallBacker* = Pack
    Notifier<DataPackMgr> packToBeRemoved;	//!< Passed CallBacker* = Pack

			// Standard mgr IDs take the low integer numbers
    static ID		BufID();	//!< Simple data buffer: 1
    static ID		PointID();	//!< Sets of 'unconnected' points: 2
    static ID		CubeID();	//!< Cube/Block (N1xN2xN3) data: 3
    static ID		FlatID();	//!< Flat (N1xN2) data: 4
    static ID		SurfID();	//!< Surface (triangulated) data: 5

    			// Convenience to get info without any obtain()
    const char*		nameOf(DataPack::ID) const;
    static const char*	nameOf(const DataPack::FullID&);
    const char*		categoryOf(DataPack::ID) const;
    static const char*	categoryOf(const DataPack::FullID&);
    virtual float	nrKBytesOf(DataPack::ID) const;
    virtual void	dumpInfoFor(DataPack::ID,IOPar&) const;

    ID			id() const		{ return id_; }
    void		dumpInfo(std::ostream&) const;
    float		nrKBytes() const;

    const ObjectSet<const DataPack>&	packs() const	{ return packs_; }

protected:

    ID				id_;
    ObjectSet<const DataPack>	packs_;

    DataPack*			doObtain(ID,bool) const;
    int				indexOf(ID) const;
    					//!<Object should be readlocked
    mutable Threads::Lock	rwlock_;

    static Threads::Lock	mgrlistlock_;
    static ManagedObjectSet<DataPackMgr> mgrs_;

public:

    			DataPackMgr(ID);
			//!< You can, but normally should not, construct
			//!< a manager. In general, leave it to DPM().
    			~DataPackMgr();
			//!< Delete a DataPackMgr only when you have
			//!< created it with the constructor.

    static DataPackMgr&	DPM(ID);
    static DataPackMgr*	gtDPM(ID,bool);
    static void		dumpDPMs(std::ostream&);

};


mGlobal(Basic) DataPackMgr& DPM(DataPackMgr::ID);
		//!< will create a new mgr if needed
mGlobal(Basic) DataPackMgr& DPM(const DataPack::FullID&);
		//!< will return empty dummy mgr if mgr ID not found


#define mObtainDataPack( var, type, mgrid, newid ) \
{ \
    if ( var ) \
    { \
	DPM( mgrid ).release( var->id() ); \
	var = 0; \
    } \
 \
    DataPack* __dp = DPM( mgrid ).obtain( newid ); \
    mDynamicCastGet( type, __dummy, __dp ); \
    if ( !__dummy && __dp ) \
	 DPM( mgrid ).release( __dp->id() ); \
    else \
	var = __dummy; \
} 


#define mObtainDataPackToLocalVar( var, type, mgrid, newid ) \
type var = 0; \
mObtainDataPack( var, type, mgrid, newid ); \

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef dateinfo_h
#define dateinfo_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		12-3-1996
 RCS:		$Id: dateinfo.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "enums.h"
#include "undefval.h"
class BufferString;

/*!
\brief A date info class.
  
  Class does not work before 1900. Non-default constructors are for dates
  other than today. Constructors accept numbers as in normal usage.
  
  Parsing: toString/fromString format is [n]n-xxx-nnnn, like 14-nov-2008.
  fromStdDateString() reads the 'file' standard,like 'Wed Nov 14 12:50:15 2008'.  fromNumString() reads '2008-11-14' or '14-11-2008' or the same with slashes,
  dots or colons.
  
  The class has some kewl 'relative' printouts.
*/

mExpClass(Basic) DateInfo
{
public:
    enum DayOfWeek	{ Su=0, Mo, Tu, We, Th, Fr, Sa };
			DeclareEnumUtils(DayOfWeek)
    enum Month		{ Jan=0, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep,
			  Oct, Nov, Dec };
			DeclareEnumUtils(Month)	//!< Uses "jan", "feb" etc.
    static const char**	sFullMonths();		//!< str = sFullMonths()[Month]
    static const char**	sAllDaysInMonth();	//!< 0 to 31

			DateInfo();		//!< Today
			DateInfo(int usryr,int usrmnth,int usrdy);
			DateInfo(int usryr,Month,int usrdy);
			DateInfo(int usryr,const char* mnth,int usrdy);
			DateInfo(const char*);

    bool		isUdf() const		{ return mIsUdf(days1900_); }
    void		setUdf(bool yn=true);

    int			day() const		{ return days_  + 1; }
    Month		month() const		{ return (Month)months_; }
    int			year() const		{ return 1900 + years_; }
    int			usrMonth() const	{ return (int)months_ + 1; }
    void		setDay(int);
    void		setMonth(int);
    void		setMonth(Month);
    void		setYear(int);

    bool		operator ==(const DateInfo&) const;
    bool		operator !=(const DateInfo&) const;
    bool		operator <(const DateInfo&) const;
    bool		operator <=(const DateInfo&) const;
    bool		operator >(const DateInfo&) const;
    bool		operator >=(const DateInfo&) const;
    DateInfo&		operator +=(int);
    DateInfo&		operator -=( int dys )	{ *this += -dys; return *this; }
    friend int		operator -(const DateInfo&,const DateInfo&);
    void		addMonths(int);

    int		 	weekDay() const;	//!< Sunday => 1
    const char*		weekDayName() const;
    const char*		monthName() const      {return getMonthString(month());}
    const char*		whenRelative(const DateInfo* di=0) const;
    static const char*	fullMonthName(int);
    static const char*	fullMonthName(Month);
    const char*		fullMonthName() const  { return fullMonthName(month());}

    void		toString(BufferString&) const;
    bool		fromString(const char*);
    bool		fromStdDateString(const char*);
    bool		fromNumString(const char*,bool yearfirst);
    void		getUsrDisp(BufferString&,bool withcurtime) const;

    static int		daysInMonth(int yr,Month);
    static int		daysInYear( int yr )	{ return yr%4 ? 365 : 366; }
    static Month	usrMonth2Month(int);

private:

    int			days1900_;
    int			years_;
    int			months_;
    int			days_;

    void		getDaysMonths(int,int,int&,int&);
    void		calcDMY();
    void		calcDays1900();
    void		getRel(const DateInfo&,BufferString&) const;
    void		getRelToday(BufferString&) const;
    void		addDay(BufferString&) const;

public:

    int			key() const		{ return days1900_; }
			DateInfo(int the_key);

};


inline bool DateInfo::operator ==( const DateInfo& di ) const
{ return days1900_ == di.days1900_; }

inline bool DateInfo::operator !=( const DateInfo& di ) const
{ return days1900_ != di.days1900_; }

inline bool DateInfo::operator <( const DateInfo& di ) const
{ return days1900_ < di.days1900_; }

inline bool DateInfo::operator <=( const DateInfo& di ) const
{ return days1900_ <= di.days1900_; }

inline bool DateInfo::operator >( const DateInfo& di ) const
{ return days1900_ > di.days1900_; }

inline bool DateInfo::operator >=( const DateInfo& di ) const
{ return days1900_ >= di.days1900_; }

inline int operator -( const DateInfo& di1, const DateInfo& di2 )
{ return di1.days1900_ - di2.days1900_; }


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef debug_h
#define debug_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Lammertink
 Date:		Jun 2003
 RCS:		$Id: debug.h 30429 2013-06-24 11:33:15Z bert.bril@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "gendefs.h"  
 
/*!\brief Defines a generic interface for supplying debug/runtime info.

    The isOn() is controlled by the environment variable DTECT_DEBUG.
    If DTECT_DEBUG starts with a "Y" or "y" then the mask is set to 0xffff.
    isOn returns the bitwise "and" of the passed flag and the internal
    environment mask, converted to a boolean.

    The reserved/defined masks are defined in "debugmasks.h".
    If you want, you can include it in a .cc you want to spit out debug
    messages, with the risk of regular big recompiles if someone adds a
    new debugmask.
    You can also make sure the debugmask you're using is defined in one
    of your header files and equals the one in "debugmasks.h", so you 
    don't have to include "debugmasks.h".

    if you want the output in a file, set the full path in DTECT_DEBUG_LOGFILE.

*/

# ifdef __cpp__
namespace DBG
{
    mGlobal(Basic) bool isOn( int flag=0xffff ); 

    mGlobal(Basic) void message( const char* ); 		    // default: to stderr
    mGlobal(Basic) void message( int flag, const char* msg ); 
// { if ( isOn(flag) ) message(msg); }
    mGlobal(Basic) void putProgInfo(int,char**); 		    //!< one line; more if isOn()
    mGlobal(Basic) void forceCrash(bool withdump); 
    mGlobal(Basic) bool crashOnNaN(); 
};

extern "C" {
# endif

    mGlobal(Basic) int od_debug_isOn( int flag );
    mGlobal(Basic) void od_debug_message( const char* msg );
    mGlobal(Basic) void od_debug_messagef( int flag, const char* msg );
    mGlobal(Basic) void od_debug_putProgInfo(int,char**);
    mGlobal(Basic) void od_putProgInfo(int,char**);
    mGlobal(Basic) void od_init_test_program(int,char**);
    /*!<Calls SetProgramArgs, sets crash on programmer error, and installs
        signal handling for crashes. */


# ifdef __cpp__
}
# endif
#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef debugmasks_h
#define debugmasks_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Lammertink
 Date:		Jun 2003
 RCS:		$Id: debugmasks.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "debug.h"

/* 

    This is a list of reserved debug masks, on order to avoid conflicts.

    DON'T JUST THROW ANY OF THESE AWAY OR CHANGE A VALUE!!!

    Adding new masks should be OK.

*/

#define	DBG_DBG		0x0001	// general, low frequency stuff
#define	DBG_MT		0x0002	// multi-threaded stuff
#define	DBG_UI		0x0004	// ui-related stuff
#define	DBG_IO		0x0008	// general I/O stuff
#define	DBG_SOCKIO	0x0010	// socket I/O
#define	DBG_MM		0x0020	// Multi-machine batch processing
#define	DBG_SETTINGS	0x0040	// User settings
#define	DBG_PROGSTART	0x0080	// Program start and stop
#define	DBG_FILEPATH	0x0100	// File name handling, conversion, etc.

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef dirlist_h
#define dirlist_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		18-4-1996
 RCS:		$Id: dirlist.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstringset.h"


/*!
\brief Provides file and directory names in a certain directory.
*/

mExpClass(Basic) DirList : public BufferStringSet
{
public:

    enum Type		{ AllEntries, FilesOnly, DirsOnly };

			DirList(const char*,Type t=AllEntries,
				const char* msk=0);
				/*!< msk can be a glob expression */

    void		update();

    Type		type() const		{ return type_; }
    const char*		dirName() const		{ return dir_; }
    const char*		dirMask() const		{ return mask_; }
    const char*		fullPath(int) const;

private:

    Type		type_;
    BufferString	dir_;
    BufferString	mask_;

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef enums_h
#define enums_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		4-2-1994
 Contents:	Enum <--> string conversion
 RCS:		$Id: enums.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "iopar.h"

#include "namedobj.h"

/*!
\brief Holds data pertinent to a certain enum.
*/

mExpClass(Basic) EnumDef : public NamedObject
{
public:
		EnumDef( const char* nm, const char* s[], short nrs=0 );
    bool	isValidName( const char* s ) const;
    int		convert( const char* s ) const;
    const char*	convert( int i ) const;

    int		size() const;

protected:

    const char**	names_;
    short		nrsign_;
};


/*!
\ingroup Basic
\brief Some utilities surrounding the often needed enum <-> string table.

  The function EnumDef::convert returns the enum (integer) value from a text
  string. The first arg is string you wish to convert to the enum, the second
  is the array with enum names. Then, the integer value of the first enum value
  (also returned when no match is found) and the number of characters to be
  matched (0=all). Make absolutely sure the char** definition has a closing
  ' ... ,0 };'.

  Normally, you'll have a class with an enum member. In that case, you'll want
  to use the EnumDef classes. These are normally almost hidden by a few
  simple macros:
  * DeclareEnumUtils(enm) will make sure the enum will have a string conversion.
  * DefineEnumNames(clss,enm,deflen,prettynm) defines the names.
  * For namespaces, you can use DeclareNameSpaceEnumUtils only

  The 'Declare' macros should be placed in the public section of the class.
  Example of usage:

  in myclass.h:
  \code
  #include <enums.h>

  class MyClass
  {
  public:
      enum State  { Good, Bad, Ugly };
		  DeclareEnumUtils(State)
      enum Type   { Yes, No, Maybe };
       	          DeclareEnumUtils(Type)

		  // rest of class
  };
  \endcode

  in myclass.cc:

  \code
  #include <myclass.h>
  
  DefineEnumNames(MyClass,State,1,"My class state")
	  { "Good", "Bad", "Not very handsome", 0 };
  DefineEnumNames(MyClass,Type,0,"My class type")
          { "Yes", "No", "Not sure", 0 };
  \endcode

  Note the '1' in the first one telling the EnumDef that only one character
  needs	to be matched when converting string -> enum. The '0' in the second
  indicates that the entire string must match.

  This will expand to (added newlines, removed some superfluous stuff:

  \code
  
  class MyClass
  {
  public: 

      enum 			  State { Good, Bad, Ugly };
      static const EnumDef&       StateDef();
      static const char**         StateNames();
      static bool                 parseEnum(const char*, State& );
      static bool                 parseEnum(const IOPar&,const char*key,State&);
      static int                  parseEnumState(const char*);
      static const char*          toString(State);

  protected:

      static const char*          StateNames_[];
      static const EnumDef        StateDefinition_;

  // similar for Type

  };

  \endcode

  and, in myclass.cc:

  \code

  const EnumDef& MyClass::StateDef()    { return StateDefinition_; }

  const EnumDef MyClass::StateDefinition_("My class state",
	  					MyClass::Statenames,1);

  bool MyClass::parseEnum(const char* txt, State& res ) \
  { \
      const int idx = StateDef().isValidName( txt ) \
          ?  StateDef().convert( txt ) \
          : -1; \
      if ( idx<0 ) \
          return false; \
    \
      res = (State) idx; \
      return true; \
  } \
  bool MyClass::parseEnum( const IOPar& par, const char* key, State& res ) \
  { return parseEnum( par.find( key ), res ); } \
  MyClass::State MyClass::parseEnumState(const char* txt) \
  { \
      return (MyClass::State) StateDef().convert( txt ); \
  } \

  const char* MyClass::Statenames_[] =
          { "Good", "Bad", "Not very handsome", 0 };


  const EnumDef& MyClass::TypeDef()   { return TypeDefinition_; }
  const EnumDef MyClass::TypeDefinition_("My class type",MyClass::Typenames, 0);
  bool MyClass::parseEnum(const char* txt, Type& res ) \
  { \
      const int idx = TypeDef().isValidName( txt ) \
          ?  TypeDef().convert( txt ) \
          : -1; \
      if ( idx<0 ) \
          return false; \
    \
      res = (Type) idx; \
      return true; \
  } \
  bool MyClass::parseEnum( const IOPar& par, const char* key, Type& res ) \
  { return parseEnum( par.find( key ), res ); } \
  MyClass::Type MyClass::parseEnumType(const char* txt) \
  { \
      return (MyClass::Type) TypeDef().convert( txt ); \
  } \

  const char* MyClass::Typenames_[] =
          { "Yes", "No", "Not sure", 0 };

  \endcode

-*/

#define DeclareEnumUtils(enm) \
public: \
    static const EnumDef& enm##Def(); \
    static const char** enm##Names();\
    static bool parseEnum##enm(const char*,enm&);  /*legacy */ \
    static bool parseEnum(const char*,enm&); \
    static bool parseEnum(const IOPar&,const char*,enm&); \
    static enm parseEnum##enm(const char*);  \
    static const char* toString(enm); \
    static const char* get##enm##String(enm); /*legacy */ \
protected: \
    static const char* enm##Names_[];\
    static const EnumDef enm##Definition_; \
public:

#define DeclareNameSpaceEnumUtils(mod,enm) \
    mExtern(mod) const EnumDef& enm##Def(); \
    mExtern(mod) const char** enm##Names();\
    extern const char* enm##Names_[];\
    extern const EnumDef enm##Definition_; \
    mExtern(mod) bool parseEnum(const IOPar&,const char*,enm&); \
    mExtern(mod) bool parseEnum(const char*,enm&); \
    mExtern(mod) bool parseEnum##enm(const char*,enm&); /*legacy */  \
    mExtern(mod) enm parseEnum##enm(const char*); \
    mExtern(mod) const char* toString(enm); \
    mExtern(mod) const char* get##enm##String(enm); /*legacy */ 

#define DefineEnumNames(clss,enm,deflen,prettynm) \
const EnumDef clss::enm##Definition_ \
	( prettynm, clss::enm##Names_, deflen ); \
const EnumDef& clss::enm##Def() \
    { return enm##Definition_; } \
const char** clss::enm##Names() \
    { return enm##Names_; }  \
bool clss::parseEnum##enm(const char* txt, enm& res ) \
{ \
    const bool isok = clss::parseEnum( txt, res ); \
    if ( !isok ) res = (enm) 0; \
    return isok; \
} \
bool clss::parseEnum(const char* txt, enm& res ) \
{ \
    const int idx = enm##Def().isValidName( txt ) \
        ?  enm##Def().convert( txt ) \
	: -1; \
    if ( idx<0 ) \
	return false; \
 \
    res = (enm) idx; \
    return true; \
} \
bool clss::parseEnum( const IOPar& par, const char* key, enm& res ) \
{ return parseEnum( par.find( key ), res ); } \
clss::enm clss::parseEnum##enm(const char* txt) \
{ \
    return (clss::enm) enm##Def().convert( txt ); \
} \
const char* clss::get##enm##String( enm theenum ) \
{ return clss::toString( theenum ); } \
const char* clss::toString( enm theenum ) \
{ \
    const int idx = (int) theenum; \
    if ( idx<0 || idx>=enm##Def().size() ) \
        return 0; \
 \
    return enm##Names_[idx]; \
} \
const char* clss::enm##Names_[] =

#define DefineNameSpaceEnumNames(nmspc,enm,deflen,prettynm) \
const EnumDef nmspc::enm##Definition_ \
	( prettynm, nmspc::enm##Names_, deflen ); \
const EnumDef& nmspc::enm##Def() \
    { return nmspc::enm##Definition_; } \
const char** nmspc::enm##Names() \
    { return nmspc::enm##Names_; }  \
bool nmspc::parseEnum##enm(const char* txt, enm& res ) \
{ \
    const bool isok = nmspc::parseEnum( txt, res ); \
    if ( !isok ) res = (nmspc::enm) 0; \
    return isok; \
} \
bool nmspc::parseEnum(const char* txt, enm& res ) \
{ \
    const int idx = enm##Def().isValidName( txt ) \
        ?  enm##Def().convert( txt ) \
	: -1; \
    if ( idx<0 ) \
	return false; \
 \
    res = (enm) idx; \
    return true; \
} \
bool nmspc::parseEnum( const IOPar& par, const char* key, enm& res ) \
{ \
    const char* val = par.find( key ); \
    return nmspc::parseEnum( val, res ); \
} \
nmspc::enm nmspc::parseEnum##enm(const char* txt) \
{ \
    return (nmspc::enm) enm##Def().convert( txt ); \
} \
const char* nmspc::get##enm##String( enm theenum ) \
{ return nmspc::toString( theenum ); } \
const char* nmspc::toString( enm theenum ) \
{ \
    const int idx = (int) theenum; \
    if ( idx<0 || idx>=enm##Def().size() ) \
        return 0; \
 \
    return enm##Names_[idx]; \
} \
const char* nmspc::enm##Names_[] =

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef envvars_h
#define envvars_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		Aug 2005
 RCS:		$Id: envvars.h 30255 2013-06-07 15:03:35Z ding.zheng@dgbes.com $
________________________________________________________________________

-*/

#ifndef gendefs_h
#include "basicmod.h"
#include "gendefs.h"
#endif

#ifdef __cpp__
extern "C" {
#endif

mGlobal(Basic) const char* GetEnvVar(const char*);
		/*!< getenv or other source. Cannot be called before
		     SetProgramArgs is called. Use GetOSEnvVar if you wish
		     to use before SetProgramArgs */
mGlobal(Basic) int GetEnvVarYN(const char*, int defltval=0);
/*!< Returns defltval if not set, 0 if set to 0 or "no", otherwise 1 */
mGlobal(Basic) int GetEnvVarIVal(const char*,int defltval);
mGlobal(Basic) double GetEnvVarDVal(const char*,double defltval);

mGlobal(Basic) char* GetOSEnvVar(const char*);
		/*!< Raw 'getenv' call */
mGlobal(Basic) int SetEnvVar(const char* env,const char* val);
		/*!< sets environment variable to a value. */
mGlobal(Basic) int WriteEnvVar(const char* env,const char* val);
		/*!< Writes environment variable to .od/envvars for user
		     or data/Envvars for SysAdm */

mGlobal(Basic) char GetEnvSeparChar(void);
		/*!< The character separating entries in an env variable */

#ifdef __cpp__
}
#endif


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef errh_h
#define errh_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		19-10-1995
 Contents:	Error handler
 RCS:		$Id: errh.h 30429 2013-06-24 11:33:15Z bert.bril@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "msgh.h"
#include "bufstring.h"
#include "fixedstring.h"


namespace google_breakpad { class ExceptionHandler; }

/*!
\brief MsgClass holding an error message.
  
  Programmer errors are only outputed when printProgrammerErrs is true. This
  is set to true by default only if __debug__ is defined.
*/

mExpClass(Basic) ErrMsgClass : public MsgClass
{
public:

			ErrMsgClass( const char* s, bool p )
			: MsgClass(s,p?ProgrammerError:Error)	{}

    static bool		printProgrammerErrs;

};


mGlobal(Basic) void ErrMsg(const char*,bool progr=false);
mGlobal(Basic) void SetCrashOnProgrammerError(int yn);
//!<Default is off. Normally only turned on in test-programs.


inline void programmerErrMsg( const char* msg, const char* cname,
				const char* fname, int linenr )
{
    BufferString str( cname );
    str += " | "; str += fname;
    str += ":"; str += linenr;
    str += " | "; str += msg;
    ErrMsg( str.buf(), true );
}



#ifdef __debug__
# define pErrMsg(msg) programmerErrMsg(msg,::className(*this),__FILE__,__LINE__)
//!< Usual access point for programmer error messages
# define pFreeFnErrMsg(msg,fn) programmerErrMsg( msg, fn, __FILE__, __LINE__ )
//!< Usual access point for programmer error messages in free functions
#else
# define pErrMsg(msg)			EmptyFunction()
# define pFreeFnErrMsg(msg,fn)		EmptyFunction()
#endif

#if defined ( __msvc__ )  && defined ( HAS_BREAKPAD )
# define mUseCrashDumper

namespace System
{

/*!Segmentation fault core dumper that sends dump to dGB. */

mExpClass(Basic) CrashDumper
{
public:
    static CrashDumper&	getInstance();
			//!Creates and installs at first run.
    			
    void		sendDump(const char* filename);
    
    void		setSendAppl(const char* a)    { sendappl_ = a; }
    
    static FixedString	sSenderAppl();		//od_ReportIssue
    static FixedString	sUiSenderAppl();	//od_uiReportIssue
    
private:
					CrashDumper();

    void				init();
    
    static CrashDumper*			theinst_;
    
    BufferString			sendappl_;
    google_breakpad::ExceptionHandler*	handler_;
};

}; //Namespace System

#endif

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef executor_h
#define executor_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		11-7-1996
 RCS:		$Id: executor.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "task.h"
#include "namedobj.h"
#include "progressmeter.h"

#include <iosfwd>

template <class T> class ObjectSet;

/*!
\brief Specification to enable chunkwise execution of a process.
  
  Interface enabling separation of the control of execution of any process from
  what actually is going on. The work is done by calling the doStep() method
  until either ErrorOccurred or Finished is returned. To enable logging and/or
  communication with the user, two types of info can be made available (the
  methods will be called before the step is executed). Firstly, a message.
  Secondly, info on the progress.
  It is common that Executors are combined to a new Executor object. This is
  the most common reason why totalNr() can change.
  
  If doStep returns -1 (Failure) the error message should be in message().
  
  The execute() utility executes the process while logging message() etc. to
  a stream. Useful in batch situations.  
*/

mExpClass(Basic) Executor : public SequentialTask
{
public:
			Executor( const char* nm )
			: SequentialTask(nm)
			, prestep(this), poststep(this)	{}
    virtual		~Executor()			{}

    virtual int		doStep();

    virtual bool	execute(std::ostream*,bool isfirst=true,
	    			bool islast=true,int delaybetwnstepsinms=0);
    virtual bool	execute()	{ return execute(0); }

    Notifier<Executor>	prestep;
    Notifier<Executor>	poststep; //!< Only when MoreToDo will be returned.

};


/*!
\brief Executor consisting of other executors.
  
  Executors may be added on the fly while processing. Depending on the
  parallel flag, the executors are executed in the order in which they were
  added or in parallel (but still single-threaded).
*/

mExpClass(Basic) ExecutorGroup : public Executor
{
public:
    			ExecutorGroup( const char* nm, bool parallel=false,
				       bool ownsexecs=true );
    virtual		~ExecutorGroup();
    virtual void	add( Executor* );
    			/*!< You will become mine if ownsexecs_ is true!! */

    virtual const char*	message() const;
    virtual od_int64	totalNr() const;
    virtual od_int64	nrDone() const;
    virtual const char*	nrDoneText() const;
    
    int			nrExecutors() { return executors_.size(); }
    Executor*		getExecutor(int idx) { return executors_[idx]; }

    void		setNrDoneText(const char* txt) { nrdonetext_ = txt; }
    			//!< If set, will use this and the counted nrdone

protected:

    virtual int		nextStep();
    virtual bool	goToNextExecutor();
    void		findNextSumStop();

    int			sumstart_;
    int			sumstop_;
    const bool		parallel_;
    int			currentexec_;
    BufferString	nrdonetext_;
    ObjectSet<Executor>& executors_;
    TypeSet<int>	executorres_;
    bool		ownsexecs_;

};


/*!
\brief TaskRunner to show progress of a Task in text format.
*/

mExpClass(Basic) TextTaskRunner : public TaskRunner
{
public:
			TextTaskRunner( std::ostream& strm )
			    : TaskRunner()
			    , strm_(strm)	{}

    bool		execute( Task& t )
			{
			    mDynamicCastGet(Executor*,exec,&t)
			    if ( exec )
				execres_ = exec->execute( &strm_ );
			    else
			    {
				TextStreamProgressMeter progressmeter(strm_);
				t.setProgressMeter( &progressmeter );
				execres_ = t.execute();
			    }
			    
			    return execres_;
			}

protected:
    std::ostream&	strm_;
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef factory_h
#define factory_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Sep 1994, Aug 2006
 RCS:		$Id: factory.h 33220 2014-02-04 03:52:35Z aneesh.tiwari@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstringset.h"
#include "staticstring.h"
#include "ptrman.h"
#include "errh.h"

/*!
\brief Base class for Factories ( Factory, Factory1Param, Factory2Param
and Factory3Param. )
*/

mExpClass(Basic) FactoryBase
{
public:
    virtual			~FactoryBase();
    bool			hasName(const char* n) {return indexOf(n)>=0;}
    const BufferStringSet&	getNames(bool username=false) const;
    void			setDefaultName(int idx);
    				//!<idx refers to names in names_,
				//!<or -1 for none
    const char*			getDefaultName() const;
    static char			cSeparator()	{ return ','; }
    
    BufferString&		errMsg() const { return errmsgs_.getString(); }
    				//!<Threadsafe, as each thread will have
    				//!<a different string returned.
    
protected:
    int				indexOf(const char*) const;
    void			addNames(const char*,const char*);
    void			setNames(int,const char*,const char*);

private:
    mutable StaticStringManager	errmsgs_;
    
    BufferStringSet		names_;
    BufferStringSet		usernames_;
    BufferStringSet		aliases_;
    BufferString		defaultname_;

};


/*!
\brief Generalized static factory that can deliver instances of T, when no
variable is needed in the creation.
  
  Usage. Each implementation of the base class T must add themselves
  to the factory when application starts up, e.g. in an initClass() function:
  \code
  class A
  {
  public:
  virtual int		myFunc() 	= 0;
  };
  
  class B : public A
  {
  public:
  static A*		createFunc() { return new B; }
  static void		initClass()
  { thefactory.addCreator(createFunc,"MyKeyword",
  "My Name"); }
  
  int			myFunc();
  };
  
  \endcode
  
  Two macros are available to make a static accessfuncion for the factory:
  \code
  mDefineFactory( Module, ClassName, FunctionName );
  \endcode
  
  that will create a static function that returns an instance to
  Factory<ClassName>.
  If the function is a static member of a class, it has to be defined with
  the mDefineFactoryInClass macro.
  
  The static function must be implemented in a src-file with the macro
  
  \code
  mImplFactory( ClassName, FunctionName );
  \endcode  
*/

template <class T>
mClass(Basic) Factory : public FactoryBase
{
public:
    typedef			T* (*Creator)();
    inline void			addCreator(Creator,const char* nm,
	    				   const char* username = 0);
    				/*!<Name may be not be null
				   If nm is found, old creator is replaced.
				   nm can be a SeparString, separated by
				   cSeparator(), allowing multiple names,
				   where the first name will be the main
				   name that is returned in getNames. */

    inline T*			create(const char* nm) const;
    				//!<Name may be not be null
protected:

    TypeSet<Creator>		creators_;
};


/*!
\brief Generalized static factory that can deliver instances of T, when a
variable is needed in the creation.
  
  Usage. Each implementation of the base class T must add themselves
  to the factory when application starts up, e.g. in an initClass() function:
  \code
  class A
  {
  public:
  virtual int		myFunc() 	= 0;
  };
  
  class B : public A
  {
  public:
  static A*		createFunc(C* param)
  {
  A* res = new B;
  if ( res->setParam( param ) );
  return res;
  
  thefactory.errMsg() = "Could not set param";
  delete res;
  return 0;
  }
  static void		initClass()
  { thefactory.addCreator(createFunc,"MyKeyword","My Name"); }
  
  int			myFunc();
  };
  
  \endcode
  
  Two macros are available to make a static accessfuncion for the factory:
  \code
  mDefineFactory1Param( Module, ClassName, ParamExpClass, FunctionName );
  \endcode
  
  that will create a static function that returns an instance to
  Factory1Param<ClassName,ParamExpClass>. The static function must be implemented
  in a src-file with the macro.
  
  \code
  mImplFactory1Param( ClassName, ParamExpClass, FunctionName );
  \endcode
*/

template <class T, class P>
mClass(Basic) Factory1Param : public FactoryBase
{
public:
    typedef			T* (*Creator)(P);
    inline void			addCreator(Creator,const char* nm=0,
	    				   const char* usernm = 0);
    				/*!<Name may be be null
				   If nm is found, old creator is replaced.
				   nm can be a SeparString, separated by
				   cSeparator(), allowing multiple names,
				   where the first name will be the main
				   name that is returned in getNames. */
    inline T*			create(const char* nm, P, bool chknm=true)const;
    				//!<Name may be be null, if null name is given
				//!<chknm will be forced to false
protected:

    TypeSet<Creator>		creators_;
};


/*!
\brief Subclass of FactoryBase.
*/

template <class T, class P0, class P1>
mClass(Basic) Factory2Param : public FactoryBase
{
public:
    typedef			T* (*Creator)(P0,P1);
    inline void			addCreator(Creator,const char* nm=0,
	    				   const char* usernm = 0);
    				/*!<Name may be be null
				   If nm is found, old creator is replaced.
				   nm can be a SeparString, separated by
				   cSeparator(), allowing multiple names,
				   where the first name will be the main
				   name that is returned in getNames. */
    inline T*			create(const char* nm, P0, P1,
	    			       bool chknm=true)const;
    				//!<Name may be be null, if null name is given
				//!<chknm will be forced to false
protected:

    TypeSet<Creator>		creators_;
};


/*!
\brief Subclass of FactoryBase.
*/

template <class T, class P0, class P1, class P2>
mClass(Basic) Factory3Param : public FactoryBase
{
public:
    typedef			T* (*Creator)(P0,P1,P2);
    inline void			addCreator(Creator,const char* nm=0,
	    				   const char* usernm = 0);
    				/*!<Name may be be null
				   If nm is found, old creator is replaced.
				   nm can be a SeparString, separated by
				   cSeparator(), allowing multiple names,
				   where the first name will be the main
				   name that is returned in getNames. */
    inline T*			create(const char* nm, P0, P1, P2,
	    			       bool chknm=true)const;
    				//!<Name may be be null, if null name is given
				//!<chknm will be forced to false
protected:

    TypeSet<Creator>		creators_;
};


#define mDefaultFactoryStringImpl \
    const char*		factoryKeyword() const { return sFactoryKeyword(); } \
    const char*		factoryDisplayName() const \
					{ return sFactoryDisplayName(); }

#define mDefaultStaticFactoryStringDeclaration \
    static const char*	sFactoryKeyword(); \
    static const char*  sFactoryDisplayName() 

#define mDefaultFactoryInitClassImpl( baseclss, createfunc ) \
{ \
    baseclss::factory().addCreator(createfunc,sFactoryKeyword(), \
				   sFactoryDisplayName()); \
}

#define mDefaultFactoryInstanciationBase( keywrd, usernm ) \
    mDefaultFactoryStringImpl \
    static const char*	sFactoryKeyword() { return keywrd; } \
    static const char*  sFactoryDisplayName() { return usernm; } \
    static void		initClass()

#define mDefaultFactoryCreatorImpl( baseclss, clss ) \
static baseclss*	createInstance() { return new clss; } \

#define mDefaultFactoryInstantiation( baseclss, clss, keywrd, usernm ) \
    mDefaultFactoryCreatorImpl( baseclss, clss ); \
    mDefaultFactoryInstanciationBase( keywrd, usernm ) \
    mDefaultFactoryInitClassImpl( baseclss, createInstance )

#define mCreateImpl( donames, createfunc ) \
    if ( donames ) \
    { \
	const int idx = indexOf( name ); \
	if ( idx==-1 ) \
	{ \
	    errMsg() = "Name "; \
	    errMsg().add( name ).add(" not found.\n" ) \
		    .add( "Perhaps all plugins are not loaded\n" ); \
	    return 0; \
	} \
	return createfunc; \
    } \
 \
    for ( int idx=0; idx<creators_.size(); idx++ ) \
    { \
	T* res = createfunc; \
	if ( res ) return res; \
    } \
 \
    return 0


#define mAddCreator \
    const int idx = indexOf( name );\
\
    if ( idx==-1 )\
    { \
	addNames( name, username ); \
	creators_ += cr; \
    } \
    else\
    {\
	setNames( idx, name, username ); \
	creators_[idx] = cr;\
    }

template <class T> inline
void Factory<T>::addCreator( Creator cr, const char* name,
			     const char* username )
{
    if ( !name ) return;\
    mAddCreator;
}


template <class T> inline
T* Factory<T>::create( const char* name ) const
{
    mCreateImpl( true, creators_[idx]() );
}


template <class T, class P> inline
void Factory1Param<T,P>::addCreator( Creator cr, const char* name,
				     const char* username )
{
    mAddCreator;
}


template <class T, class P> inline
T* Factory1Param<T,P>::create( const char* name, P data, bool chk ) const
{
    mCreateImpl( chk, creators_[idx]( data ) );
}


template <class T, class P0, class P1> inline
void Factory2Param<T,P0,P1>::addCreator( Creator cr, const char* name,
					 const char* username )
{
    mAddCreator;
}


template <class T, class P0, class P1> inline
T* Factory2Param<T,P0,P1>::create( const char* name, P0 p0, P1 p1,
				   bool chk ) const
{
    mCreateImpl( chk, creators_[idx]( p0, p1 ) );
}


template <class T, class P0, class P1, class P2> inline
void Factory3Param<T,P0,P1,P2>::addCreator( Creator cr, const char* name,
					 const char* username )
{
    mAddCreator;
}


template <class T, class P0, class P1, class P2> inline
T* Factory3Param<T,P0,P1,P2>::create( const char* name, P0 p0, P1 p1, P2 p2,
				   bool chk ) const
{
    mCreateImpl( chk, creators_[idx]( p0, p1, p2 ) );
}


#define mDefineFactory( mod, T, funcname ) \
mGlobal(mod) ::Factory<T>& funcname()


#define mDefineFactoryInClass( T, funcname ) \
static ::Factory<T>& funcname(); \
virtual const char* factoryDisplayName() const { return factoryKeyword(); } \
virtual const char* factoryKeyword() const { return 0; }


#define mImplFactory( T, funcname ) \
::Factory<T>& funcname() \
{ \
    mDefineStaticLocalObject(PtrMan< ::Factory<T> >,inst,(new ::Factory<T>)); \
    return *inst; \
} 


#define mDefineFactory1Param( mod, T, P, funcname ) \
mGlobal(mod) ::Factory1Param<T,P>& funcname()


#define mDefineFactory1ParamInClass( T, P, funcname ) \
static ::Factory1Param<T,P>& funcname(); \
virtual const char* factoryDisplayName() const { return factoryKeyword(); } \
virtual const char* factoryKeyword() const { return 0; }



#define mImplFactory1Param( T, P, funcname ) \
::Factory1Param<T,P>& funcname() \
{ \
    mLockStaticInitLock( static_inst_lck__ ); \
    static PtrMan< ::Factory1Param<T,P> > \
	inst(new ::Factory1Param<T,P>); \
    mUnlockStaticInitLock( static_inst_lck__ ); \
     \
    return *inst; \
} 


#define mDefineFactory2Param( mod, T, P0, P1, funcname ) \
mGlobal(mod) ::Factory2Param<T,P0,P1>& funcname()


#define mDefineFactory2ParamInClass( T, P0, P1, funcname ) \
static ::Factory2Param<T,P0,P1>& funcname(); \
virtual const char* factoryDisplayName() const { return factoryKeyword(); } \
virtual const char* factoryKeyword() const { return 0; }


#define mImplFactory2Param( T, P0, P1, funcname ) \
::Factory2Param<T,P0,P1>& funcname() \
{ \
    mLockStaticInitLock( static_inst_lck__ ); \
    static PtrMan< ::Factory2Param<T,P0,P1> > \
	inst(new ::Factory2Param<T,P0,P1>); \
    mUnlockStaticInitLock( static_inst_lck__ ); \
    \
    return *inst; \
} 


#define mDefineFactory3Param( mod, T, P0, P1, P2, funcname ) \
mGlobal(mod) ::Factory3Param<T,P0,P1,P2>& funcname()


#define mDefineFactory3ParamInClass( T, P0, P1, P2, funcname ) \
static ::Factory3Param<T,P0,P1,P2>& funcname(); \
virtual const char* factoryDisplayName() const { return factoryKeyword(); } \
virtual const char* factoryKeyword() const { return 0; }


#define mImplFactory3Param( T, P0, P1, P2,funcname ) \
::Factory3Param<T,P0,P1,P2>& funcname() \
{ \
    mLockStaticInitLock( static_inst_lck__ ); \
    static PtrMan< ::Factory3Param<T,P0,P1,P2> > \
	inst(new ::Factory3Param<T,P0,P1,P2>); \
    mUnlockStaticInitLock( static_inst_lck__ ); \
\
    return *inst; \
} 

#undef mCreateImpl
#undef mAddCreator

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef file_h
#define file_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Nanne Hemstra
 Date:		January 2010
 Contents:	File utitlities
 RCS:		$Id: file.h 30870 2013-07-23 11:17:34Z raman.singh@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "gendefs.h"
#include "timefun.h"
class BufferString;
class Executor;


/*!\brief Interface for several file and directory related services */

namespace File
{
    mGlobal(Basic) bool		exists(const char*);
    mGlobal(Basic) bool		isEmpty(const char*);
    mGlobal(Basic) bool		isFile(const char*);
    mGlobal(Basic) bool		isDirectory(const char*);

    mGlobal(Basic) const char*	getCanonicalPath(const char*);
    mGlobal(Basic) const char*	getRelativePath(const char* reltodir,
						const char* fnm);

    mGlobal(Basic) bool		createLink(const char* from,const char* to);
    mGlobal(Basic) bool		isLink(const char*);
    mGlobal(Basic) const char*	linkTarget(const char* linkname);
    mGlobal(Basic) const char*	linkValue(const char* linkname);

    mGlobal(Basic) bool		isHidden(const char*);
    mGlobal(Basic) bool		isWritable(const char*);
    mGlobal(Basic) bool		makeWritable(const char*,bool yesno,
					     bool recursive);
    mGlobal(Basic) bool		isExecutable(const char*);
    mGlobal(Basic) bool		makeExecutable(const char*,bool yesno);
    mGlobal(Basic) bool		setPermissions(const char*,const char* perms,
					       bool recursive);
    mGlobal(Basic) bool		isFileInUse(const char* fnm); 

    mGlobal(Basic) bool		createDir(const char*); 
    mGlobal(Basic) bool		rename(const char* oldname,const char* newname);
    mGlobal(Basic) bool		copy(const char* from,const char* to);
    mGlobal(Basic) Executor*	getRecursiveCopier(const char* from,
	    					   const char* to);
    mGlobal(Basic) bool		remove(const char*);
    mGlobal(Basic) bool		saveCopy(const char* from,const char* to);
    mGlobal(Basic) bool		copyDir(const char* from,const char* to);
    mGlobal(Basic) bool		removeDir(const char*);
    mGlobal(Basic) bool		changeDir(const char* path);

    mGlobal(Basic) bool		getContent(const char*,BufferString&);
    mGlobal(Basic) od_int64	getFileSize(const char*);
    				//!<returns size in bytes
				//!<Returns 0 on error
    mGlobal(Basic) int		getKbSize(const char*);
				//!<Returns 0 on error

    mGlobal(Basic) const char*	timeCreated(const char* filenm,
	    			    const char* fmt/*=Time::defDateTimeFmt()*/);	// herman
    mGlobal(Basic) const char*	timeLastModified(const char* filenm,
	    			    const char* fmt/*=Time::defDateTimeFmt()*/);	// herman
    mGlobal(Basic) od_int64	getTimeInSeconds(const char*);
				//! Last modified time

    mGlobal(Basic) const char*	getCurrentPath();
    mGlobal(Basic) const char*	getHomePath();
    mGlobal(Basic) const char*	getTempPath();
    mGlobal(Basic) const char*	getRootPath(const char* path);

} // namespace File

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef filegen_h
#define filegen_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		3-5-1994
 Contents:	File utitlities
 RCS:		$Id: filegen.h 30292 2013-06-12 07:08:46Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "gendefs.h"


#ifdef __cpp__
extern "C" {
#endif

/*!
These functions deliver services related to files. In principle, they shield
from knowledge of the OS, and could so also be used on non-UNIX platforms.
Only UNIX is currently fully implemented, most notably recursive copy/remove
and links are lacking on windows.
*/

/*! Queries returning mC_True or mC_False */
mGlobal( Basic ) int File_exists(const char*);
mGlobal( Basic ) int File_isEmpty(const char*);
mGlobal( Basic ) int File_isDirectory(const char*);
mGlobal( Basic ) int File_isLink(const char*);
mGlobal( Basic ) int File_isRemote(const char*);
mGlobal( Basic ) int File_isWritable(const char*);

/*! Functions returning mC_True on success */
mGlobal( Basic ) int File_createDir(const char*,int mode /* 0755 when 0 passed */); 
mGlobal( Basic ) int File_rename(const char* oldname,const char* newname);
mGlobal( Basic ) int File_createLink(const char* from,const char* to);
mGlobal( Basic ) int File_copy(const char* from,const char* to,int recursive_downward);
mGlobal( Basic ) int File_remove(const char*,int recursive_downward);
mGlobal( Basic ) int File_makeWritable(const char*,int recursive,int yesno);
mGlobal( Basic ) int File_setPermissions(const char*,const char* perms,int recursive);
						// Not for Windows
#define mFile_NotRecursive 0
#define mFile_Recursive 1

/*! Size/disk space. Returns 0 on any error */
mGlobal( Basic ) int File_getKbSize(const char*);
mGlobal( Basic ) int File_getFreeMBytes(const char*);

/*! Modification time. The seconds are for compare, getTime for user display. */
mGlobal( Basic ) const char*	File_getTime(const char*);
mGlobal( Basic ) od_int64 	File_getTimeInSeconds(const char*);

/*! Functions returning path */
mGlobal( Basic ) const char* File_linkTarget(const char* linkname);
		/* returns what a symbolic link points to */
mGlobal( Basic ) const char* File_getCurrentDir(void);


#ifdef __cpp__
}
#endif


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef filepath_h
#define filepath_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2004
 RCS:		$Id: filepath.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstringset.h"


/*!
\brief File pathname tools.

  This class splits a full filename (with path) into the separate parts:
  directories and possibly a filename (the last part does not have to be a
  file name). That makes it easy to change the file name, or the path only,
  or the extension, add directories, etc.
  
  To get the result after manipulation, use the fullPath().

  fileName() returns the last part, pathOnly() returns all but the last part.
  setFileName() replaces the last part, setPath() replaces all but the last
  part.
*/

mExpClass(Basic) FilePath
{
public:
    enum Style		{ Local, Unix, Windows };

    			FilePath(const char* fullinp=0);
    			FilePath(const char* p1,const char* p2,const char* p3=0,
				 const char* p4=0,const char* p5=0);
			FilePath( const FilePath& fp )	{ *this = fp; }
			FilePath(const FilePath&,const char* p2,
				 const char* p3=0,const char* p4=0,
				 const char* p5=0);

    FilePath&		operator =(const FilePath&);
    FilePath&		operator =(const char* fullinp);
    bool		operator ==(const FilePath&) const;
    bool		operator ==(const char* fnm) const;
    bool		operator !=(const FilePath&) const;
    bool		operator !=(const char* fnm) const;
    bool		isEmpty() const		{ return lvls_.isEmpty(); }

    FilePath&		set(const char* fullinp);
    FilePath&		add(const char*);	//!< at end
    FilePath&		insert(const char*);	//!< after prefix at start
    void		setFileName(const char*); //!< pass null to remove level
    void		setPath(const char*);	//!< including prefix
    void		setExtension(const char*,bool replace=true);
    						//!< !replace => add

    bool		isAbsolute() const;
    bool		isSubDirOf(const FilePath&,FilePath* reldir = 0) const;
			/*!<If reldir is set, it will be filled with the
			    relative path. */
    bool		makeRelativeTo(const FilePath&);
    bool		makeCanonical();

    BufferString	fullPath(Style s=Local,bool cleanup=true) const;
    const char*		prefix() const;
    int			nrLevels() const;
    const char*		extension() const;	//!< may return null

    const BufferString& fileName() const;
    BufferString	baseName() const; //!<return name of file w/o path & ext
    BufferString	pathOnly() const;
    BufferString	winDrive() const;

    const BufferString&	dir(int nr=-1) const;
    			//!< nr < 0 returns last dir name
    BufferString	dirUpTo(int) const;
    			//!< nr < 0 returns last dir, including prefix

    static BufferString	getTempDir();
    static BufferString	getTempName(const char* ext=0);
    static BufferString	mkCleanPath(const char* path, Style fmt);

    static const char*	dirSep(Style);
    static const char*	sPrefSep;

protected:

    bool		isabs_;
    BufferString	prefix_;
    BufferStringSet	lvls_;

    void		addPart(const char*);
    void		compress(int sl=0);
    void		trueDirIfLink();
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef filesystemwatcher_h
#define filesystemwatcher_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Nanne Hemstra
 Date:          March 2009
 RCS:           $Id: filesystemwatcher.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "callback.h"
#include "bufstring.h"
#include "commondefs.h"

class BufferStringSet;
mFDQtclass(QFileSystemWatcher)
mFDQtclass(QFileSystemWComm)

/*!
\brief Class for monitoring a file system.
*/

mExpClass(Basic) FileSystemWatcher : public CallBacker 
{
public:
    friend class mQtclass(QFileSystemWComm);

				FileSystemWatcher();
				~FileSystemWatcher();

    void			addFile(const BufferString&);
    void			addFiles(const BufferStringSet&);
    void			removeFile(const BufferString&);
    void			removeFiles(const BufferStringSet&);

    const BufferString&		changedDir() const  { return chgddir_; }
    const BufferString&		changedFile() const { return chgdfile_; }

    Notifier<FileSystemWatcher>	directoryChanged;
    Notifier<FileSystemWatcher>	fileChanged;

protected:

    BufferString		chgddir_;
    BufferString		chgdfile_;

    mQtclass(QFileSystemWatcher*)	qfswatcher_;
    mQtclass(QFileSystemWComm*)		qfswatchercomm_;

};

mGlobal(Basic) FileSystemWatcher& FSW();

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef fixedstreambuf_h
#define fixedstreambuf_h
/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Feb 2009
 RCS:		$Id: fixedstreambuf.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include <streambuf>


namespace std
{

/*!
\brief Adapter to use a fixed buffer as a stream.

  Usage like:

  std::fixedstreambuf fsb( mybuf, mybufsize );
  std::istream strm( &fsb );

  Tested for istream with char* only.
*/

mClass(Basic) fixedstreambuf : public streambuf
{
public:

fixedstreambuf( char_type* b, off_type sz, bool manbuf=false )
    : mine_(manbuf)
    , newpos_(0)
{
    setbuf( b, sz );
}

~fixedstreambuf()
{
    if ( mine_ )
	delete [] buf_;
}

virtual fixedstreambuf* setbuf( char_type* b, streamsize n )
{
    buf_ = b; sz_ = n;
    setg( buf_, buf_, buf_ + sz_ );
    setp( buf_, buf_ + sz_ );

    return this;
}

virtual pos_type seekoff( off_type offs, ios_base::seekdir sd,
			  ios_base::openmode which )
{
    newpos_ = offs;
    if ( sd == ios_base::cur )
	newpos_ += which == ios_base::in ? gptr() - buf_ : pptr() - buf_;
    else if ( sd == ios_base::end )
	newpos_ = sz_ + newpos_;

    return seekpos( newpos_, which );
}

virtual pos_type seekpos( pos_type newpos, ios_base::openmode which )
{
    if ( newpos_ < 0 || newpos_ >= sz_ )
	newpos_ = -1;
    else if ( which == ios_base::in )
	setg( buf_, buf_+newpos_, buf_ + sz_ );
    else
	setp( buf_+newpos_, buf_ + sz_ );

    return newpos_;
}

virtual streamsize xsgetn( char_type* s, streamsize n )
{
    streamsize toget = n;
    const od_int64 memsz = epptr() - pptr();
    if ( toget > memsz && memsz >= 0  )
	toget = memsz;

    memcpy( s, gptr(), (size_t)toget );
    gbump( (int) toget );

    return toget;
}

virtual streamsize xsputn( const char_type* s, streamsize n )
{
    streamsize toput = n;
    const od_int64 memsz = epptr() - pptr();
    if ( toput > memsz && memsz >= 0  )
	toput = memsz;

    memcpy( pptr(), s, (size_t)toput );
    pbump( (int)toput );

    return toput;
}

    char_type*	buf_;
    off_type	sz_;
    bool	mine_;
    off_type	newpos_;
};

} // namespace std


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef fixedstring_h
#define fixedstring_h
/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Kristofer
 Date:		April 2009
 RCS:		$Id: fixedstring.h 29457 2013-04-24 10:50:26Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "commondefs.h"
#include "undefval.h"

#include <iosfwd>

class BufferString;


/*!
\brief Class that holds a text string, and provides basic services around it.
The string is assumed to be owned by someone else or be static. In any case, it
is assumed be be alive and well for the lifetime of the FixedString.
*/

mExpClass(Basic) FixedString
{
public:
		FixedString(const char* p = 0 ) : ptr_(p) {}
    FixedString& operator=(const FixedString& f) { return *this = f.ptr_; }
    FixedString& operator=(const char* p)	{ ptr_ = p; return *this; }
    FixedString& operator=(const BufferString& b);

    bool	operator==(const char*) const;
    bool	operator==(const BufferString&) const;
    bool 	operator!=(const BufferString&) const;
    bool	operator!=(const char* s) const		{ return !(*this==s); }
    bool	operator==(const FixedString& f) const	{ return *this==f.ptr_;}
    bool	operator!=(const FixedString& f) const	{ return *this!=f.ptr_;}
    bool	operator!() const			{ return isEmpty(); }

    bool	isNull() const			{ return !ptr_; }
    bool	isEmpty() const			{ return !ptr_ || !*ptr_; }
    int		size() const;

		operator const char*() const   	{ return str(); }

    const char*	str() const 			{ return isEmpty() ? 0 : ptr_; }

protected:

    const char*	ptr_;
};

namespace Values
{
    template<>
    mClass(Basic) Undef<FixedString>
    {
    public:
	static FixedString	val()			{ return FixedString();}
	static bool		hasUdf()		{ return true; }
	static bool		isUdf(const FixedString& s){return s.isEmpty();}
	static void		setUdf(FixedString& s)	{ s = FixedString(); }
    };
}

inline bool operator==(const char* a, const FixedString& b)
{ return b==a; }
 
 
inline bool operator!=(const char* a, const FixedString& b)
{ return b!=a; }

mGlobal(Basic) std::ostream& operator <<(std::ostream&,const FixedString&);


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef fontdata_h
#define fontdata_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        A.H. Bril
 Date:          26/07/2000

 RCS:           $Id: fontdata.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $

______________________________________________________________________

-*/

#include "basicmod.h"
#include "enums.h"
#include "bufstring.h"

/*!
\brief Data needed to make an actual font.
*/

mExpClass(Basic) FontData
{			
public:    

    enum Weight		{ Light, Normal, DemiBold, Bold, Black };
			DeclareEnumUtils(Weight)
    static int		numWeight(Weight);
    static Weight	enumWeight(int);

			FontData( int ptsz=defaultPointSize(),
				  const char* fam=defaultFamily(),
				  Weight wght=defaultWeight(),
				  bool ital=defaultItalic() )
                        : family_(fam)
			, pointsize_(ptsz)
			, weight_(wght)
			, italic_(ital)		{}

			FontData( const char* s )
			: family_(defaultFamily())
			, pointsize_(defaultPointSize())
			, weight_(defaultWeight())
			, italic_(defaultItalic())
			{ getFrom(s); }

			//! Store/retrieve (in FileMultiString format).
    bool		getFrom(const char*);
    void		putTo(BufferString&) const;

    const char*		family() const		{ return family_; }
    int			pointSize() const	{ return pointsize_; }
    Weight		weight() const		{ return weight_; }
    bool		isItalic() const	{ return italic_; }

    void		setFamily( const char* f ) { family_ = f; }
    void		setPointSize( int ps )	{ pointsize_ = ps; }
    void		setWeight( Weight w )	{ weight_= w; }
    void		setItalic( bool yn )	{ italic_ = yn; }

    static const char*	defaultFamily();
    static int		defaultPointSize();
    static Weight	defaultWeight();
    static bool		defaultItalic();

    static void		setDefaultFamily( const char* f );
    static void		setDefaultPointSize( int ps );
    static void		setDefaultWeight( Weight w );
    static void		setDefaultItalic( bool yn );

    static const char* const* universalFamilies();
			//!< array of strings with null as last element

    static const char* const* defaultKeys();
			//!< array of strings with null as last element

    enum StdSz		{ Control=0, 
			  GraphicsMed, GraphicsSmall, GraphicsLarge,
			  ControlSmall, ControlLarge, Fixed };
    static const char* key( StdSz ss );
 
protected:
 
    BufferString	family_;
    int			pointsize_;
    Weight		weight_;
    bool		italic_;

 
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef genc_h
#define genc_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		23-10-1996
 RCS:		$Id: genc.h 33863 2014-03-27 11:28:52Z ranojay.sen@dgbes.com $
________________________________________________________________________

Some general utilities, that need to be accessible in many places:

-*/

#ifndef gendefs_h
#include "basicmod.h"
#include "gendefs.h"
#endif


#ifdef __cpp__
# include "string2.h"
extern "C" {
#else
# include "string2_c.h"
#endif

mGlobal(Basic) const char* GetProjectVersionName(void);
		/*!< "dTect Vx.x" */

mGlobal(Basic) int GetPID(void);
		/*!< returns process ID */

mGlobal(Basic) const char* GetLocalHostName(void);
		/*!< returns (as expected) local host name */

mGlobal(Basic) const char* GetIPFromHostName(const char* hostnm);
		/*!< return the IP address given a host name */

mGlobal(Basic) const char* GetLocalIP(void);
		/*!< returns local IP Address */

mGlobal(Basic) const char* GetFullExecutablePath(void);
		/*!< returns full path to executable. setProgramArgs
		     must be called for it to work. */
    
mGlobal(Basic) char** GetArgV(void);
    
mGlobal(Basic) int GetArgC(void);

mGlobal(Basic) int AreProgramArgsSet(void);
    
mGlobal(Basic) void SetProgramArgs(int argc, char** argv);
    
mGlobal(Basic) int isProcessAlive(int pid);
		/*!< returns 1 if the process is still running */

mGlobal(Basic) void ExitProgram( int ret );
		/*!< Win32: kills progam itself and ignores ret.
		     Unix: uses exit(ret).
		     Return value is convenience only, so you can use like:
		     return exitProgram( retval );
                */

typedef void (*PtrAllVoidFn)(void);
mGlobal(Basic) void NotifyExitProgram(PtrAllVoidFn);
		/*!< Function will be called on 'ExitProgram' */

mGlobal(Basic) void PutIsLittleEndian(unsigned char*);
		/*!< Puts into 1 byte: 0=SunSparc/SGI (big), 1=PC (little) */

mGlobal(Basic) void SwapBytes(void*,int nbytes);
		/*!< nbytes=2,4,... e.g. nbytes=4: abcd becomes cdab */

mGlobal(Basic) int InSysAdmMode(void);
		/*!< returns 0 unless in sysadm mode */
    
    
mGlobal(Basic) int GetSubversionRevision(void);
		/*!< Returns Subversion revision number */

mGlobal(Basic) const char* GetSubversionUrl(void);
		/*!< Returns Subversion url */
    
    
mGlobal( Basic ) void forkProcess(void);
    
    
mGlobal( Basic ) int InSysAdmMode(void);
    
    
mGlobal( Basic ) void SetInSysAdmMode(void);
    
    
inline void EmptyFunction() 			{}
/* Used in some macros and ifdefs */

#ifdef __cpp__
}
#else
/* C only */

typedef char	FileNameString[mMaxFilePathLength+1];

#endif


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef gendefs_h
#define gendefs_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Sep 1995
 RCS:		$Id: gendefs.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

 This file contains general defines that are so basic they can (read: MUST)
 be used in any source file. If you have no include anywhere in your header
 or source file, include this one.

 undefval.h includes plftypes.h which includes plfdefs.h. Thus, every single
 source file in OD is dep on:

 plfdefs.h
 plftypes.h
 undefval.h
 commondefs.h
 gendefs.h

 All the above are usable from C and C++.

-*/

#ifndef undefval_h
# include "undefval.h"
#endif
#ifndef commondefs_h
#include "commondefs.h"
#endif


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef general_h
#define general_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		23-10-1996
 Contents:	Extension of genc.h with C++ stuff.
 RCS:		$Id: general.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#ifndef genc_h
#include "genc.h"
#endif

#ifdef __cpp__

#include "bufstring.h"
#define FileNameString	BufferString

template <class T>
inline void Swap( T& a, T& b ) { T tmp = a; a = b; b = tmp; }

#include <typeinfo>

template <class T>
inline const char* className( const T& t )
{	//!< Also works for gcc that returns the size first e.g. 4Clss
    const char* nm = typeid(t).name();
    while ( *nm >= '0' && *nm <= '9' ) nm++;
    return nm;
}


//! Defines policy for 2D and 3D Data type
enum Pol2D3D	{ Only3D=-1, Both2DAnd3D=0, Only2D=1 };

//! Catches bad_alloc and sets ptr to null as normal.
#define mTryAlloc(var,stmt) \
{ try { var = new stmt; } catch ( std::bad_alloc ) { var = 0; } }

#define mTryAllocPtrMan(var,stmt) \
{ try { var = new stmt; } catch ( std::bad_alloc ) { var.set( 0 ); } }

//!Creates variable, try to alloc and catch bad_alloc.
#define mDeclareAndTryAlloc(tp,var,stmt)				\
    tp var;								\
    mTryAlloc(var,stmt)

//!Creates new array of an integer type filled with index
#define mGetIdxArr(tp,var,sz)				\
    tp* var;						\
    mTryAlloc(var,tp [sz])				\
    if ( var )						\
	for  ( tp idx=0; idx<sz; idx++ )		\
	    var[idx] = idx;

/*!
\ingroup Basic
\brief Define members in setup classes (see e.g. uidialog.h)

  Usage typically like:
  
  class SomeClass
  {
  public:
 
	  class Setup
	  {
		  Setup()
		  : withformat_(true)	//!< Can user select storage?
		  , withstep_(true)	//!< Can user specify steps?
		  , title_("")		//!< Title for plots
		 		 {}

		 mDefSetupMemb(bool,withformat)
		 mDefSetupMemb(bool,withstep)
		 mDefSetupMemb(BufferString,title)
	  }
	
	 SomeClass(const Setup&);
	 // etc.
  };

  The point of this is clear when SomeClass is constructed:
  SomeClass sc( SomeClass::Setup().withformat(false).title("MyTitle") );
*/

#define mDefSetupClssMemb(clss,typ,memb) \
	typ	 memb##_; \
	clss&	memb( typ val )		{ memb##_ = val; return *this; }

#define mDefSetupMemb(typ,memb) mDefSetupClssMemb(Setup,typ,memb)


#endif

/*!
\ingroup Basic
\brief Applies an operation to all members in an array. Quicker than for-loops.

  Instead of:
  \code
  for ( int idx=0; idx<sz; idx++ )
  ptr[idx] /= 5;
  \endcode
  
  You can do:
  \code
  
  mPointerOperation( float, ptr, /= 5, sz, ++ );
  \endcode
  
  This will expand to :
  \code
  {
    float* __incptr = ptr;
    const float* __stopptr = __incptr + sz;
    while( __incptr!=__stopptr )
    {
        *__incptr /= 5;
	__incptr ++;
    }
  }
  \endcode
*/

#define mPointerOperation( type, ptr, ops, totalnr, inc ) \
{ \
    type* __incptr = ptr; \
    const type* __stopptr = __incptr + totalnr; \
    while ( __incptr!=__stopptr ) \
    { \
	*__incptr ops; \
	__incptr inc; \
    } \
}


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef geometry_h
#define geometry_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        A.H. Lammertink
 Date:          01/02/2000
 RCS:           $Id: geometry.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "gendefs.h"
#include "ranges.h"
#include "math2.h"

namespace Geom
{

/*!
\brief %Basic point class.
*/

template <class T>
mClass(Basic) Point2D
{
public:
				Point2D(T xx=0,T yy=0);

    template <class TT>
    Point2D<T>&			setFrom(const Point2D<TT>&);

    template <class TT>
    inline void			setXY(TT xx,TT yy);
    inline void			setXY(T xx,T yy);
    inline Point2D<T>&		zero();
    inline Point2D<T>		operator-();

    inline T&			operator[](int idx);
    inline T			operator[](int idx) const;

    inline bool			operator==(const Point2D<T>&) const;
    inline bool			operator!=(const Point2D<T>&) const;
    inline Point2D<T>&		operator+=(T dist);
    inline Point2D<T>&		operator*=(T factor);
    inline Point2D<T>&		operator/=(T den);
    inline Point2D<T>&		operator+=(const Point2D<T>&);
    inline Point2D<T>&		operator-=(const Point2D<T>&);
    inline Point2D<T>		operator+(const Point2D<T>&) const;
    inline Point2D<T>		operator-(const Point2D<T>&) const;
    inline Point2D<T>		operator*(const T factor) const;
    inline Point2D<T>		operator/(const T den) const;
    
    inline void			swapXY();

    inline bool			isDefined() const;
    inline double		abs() const;
    inline T			sqAbs() const;
    inline double		distTo(const Point2D<T>&) const;
    inline T			sqDistTo(const Point2D<T>&) const;

    static Point2D<T>		udf() { return Point2D<T>(mUdf(T),mUdf(T)); }
    
    T 				x;
    T 				y;
};


/*!
\brief %Basic 2D sizes (width/height) class.
*/

template <class T>
mClass(Basic) Size2D
{
public:
			Size2D( T w = 0 , T h = 0 );

    inline bool		operator==(const Size2D<T>&) const;
    inline bool		operator!=(const Size2D<T>&) const;

    inline T		width() const;
    inline T		height() const;
    inline void		setWidth(T val);
    inline void		setHeight(T val);
    inline Size2D<T>	operator+(T val) const;
    inline Size2D<T>&	operator+=(T val);
    inline Size2D<T>&	operator-=(T val);
    inline Size2D<T>&	operator+=(const Size2D<T>&);
    inline Size2D<T>&	operator-=(const Size2D<T>&);

protected:

    T 	width_;
    T 	height_;

};


/*!
\brief %Basic 2D rectangle class.

  This class is a bit more complicated than would be expected at first sight.
  This is caused by the problem of coordinate system sign. For example, in
  user interfaces, top is a lower number than bottom. But for normal
  coordinates, this is (of course) not the case. Still, also for floating point
  types, reverse axes are common.
*/

template <class T>
mClass(Basic) Rectangle
{
public:
			Rectangle(T l=0,T t=0,T r=0,T b=0) ;
			Rectangle(const Point2D<T>& tl,const Point2D<T>& br);
			Rectangle(const Point2D<T>& tl,const Size2D<T>& sz);

    inline bool		operator==(const Rectangle<T>&) const;
    inline bool		operator!=(const Rectangle<T>&) const;

    inline Point2D<T>	topLeft() const;
    inline Point2D<T>	topRight() const;
    inline Point2D<T>	bottomLeft() const;
    inline Point2D<T>	bottomRight() const;
    inline Point2D<T>	centre() const;
    inline void		setTopLeft(Point2D<T>);
    inline void		setBottomRight(Point2D<T>);
    inline void		setTopRight(Point2D<T>);
    inline void		setBottomLeft(Point2D<T>);
    inline void		setTopBottom(const Interval<T>&);
    inline void		setLeftRight(const Interval<T>&);

    inline Point2D<T>	moveInside(const Point2D<T>&) const;

    inline void		include(const Rectangle<T>&);
    inline void		limitTo(const Rectangle<T>&);
    inline void		translate(const Point2D<T>&);

    inline bool		operator >(const Rectangle<T>&) const;

    inline T 		width() const;
    inline T 		height() const;

    inline T 		left() const;
    inline T 		top() const;
    inline T 		right() const;
    inline T 		bottom() const;
    inline void 	setLeft(T val);
    inline void 	setTop(T val);
    inline void 	setRight(T val);
    inline void 	setBottom(T val);

    void		checkCorners(bool leftislow=true,bool topislow=true);
    inline Size2D<T>	size() const;
    inline void 	zero();

    inline Rectangle<T>& operator+=(const Point2D<T>&); // shifts
    inline Rectangle<T>& operator-=(const Point2D<T>&);
    inline Rectangle<T>& operator+=(const Size2D<T>&); // keeps topleft in place
    inline Rectangle<T>& operator-=(const Size2D<T>&);

    inline void		swapHor();
    inline void		swapVer();

protected:

    inline bool		revX() const;
    inline bool		revY() const;

    Point2D<T>		topleft_;
    Point2D<T>		bottomright_;

};


/*!
\brief Integer rectangle class.

  The difference with the floating point type rectangle is in range handling.
  In the float world, everything must be epsiloned. Integer rectangles are
  more straightforward.
*/

template <class T>
mClass(Basic) PixRectangle : public Rectangle<T>
{
public:
			PixRectangle(T l=0 , T t=0, T r=0 , T b=0 ) ;
			PixRectangle(const Point2D<T>& tl,const Point2D<T>& br);
			PixRectangle(const Point2D<T>& tl,const Size2D<T>& sz);
			PixRectangle(const Rectangle<T>&);

    inline bool		isInside(const Point2D<T>&) const;
    inline bool		isOutside(const Point2D<T>&) const;
    inline bool		isOnSide(const Point2D<T>&) const;
    inline bool		contains(const Point2D<T>&) const;
    inline bool		contains(const PixRectangle<T>&) const;
    inline bool		isInside(const PixRectangle<T>&) const;

    inline PixRectangle<T> grownBy(double sidesincreasebyfactor=1) const;

protected:

    inline bool		xOutside(T) const;
    inline bool		yOutside(T) const;
};


/*!
\brief Floating-point rectangle class.

  The difference with the integer type rectangle is in range handling. In the
  float world, everything must be epsiloned.
  with inside and outside.
*/

template <class T>
mClass(Basic) PosRectangle : public Rectangle<T>
{
public:
			PosRectangle( T l = 0 , T t = 0, T r = 0 , T b = 0 ) 
			: Rectangle<T>(l,t,r,b)		{}
			PosRectangle( Point2D<T> tl, Point2D<T> br ) 
			: Rectangle<T>(tl,br)		{}

    inline bool		isOutside( const Point2D<T>& p, T eps ) const
			{ return xOutside(p.x,eps) || yOutside(p.y,eps); }
    inline bool		isInside(const Point2D<T>&,T eps) const;
    inline bool		isOnSide(const Point2D<T>& p,T eps) const;

    inline bool		contains( const Point2D<T>& p, T eps ) const
			{ return !isOutside(p,eps); }

    inline bool		contains( const PosRectangle<T>& other, T eps ) const
			{
			    return contains(other.topleft_,eps)
				&& contains(other.bottomright_,eps);
			}
    inline bool		isInside( const PosRectangle<T>& other, T eps ) const
			{
			    return other.isInside(this->topleft_,eps)
				&& other.isInside(this->bottomright_,eps);
			}

    inline PosRectangle<T> grownBy(T sidesincreasebyfactor=1) const;

protected:

    inline bool		xOutside(T,T) const;
    inline bool		yOutside(T,T) const;
};


template <class T> inline
Point2D<T>::Point2D ( T xx , T yy )
    : x(xx), y(yy)
{}

template <class T> template <class TT> inline
Point2D<T>& Point2D<T>::setFrom( const Point2D<TT>& a )
{ x=a.x; y=a.y; return *this;}

template <class T> inline
void Point2D<T>::setXY( T xx, T yy )
{ x = xx ; y = yy; }  

template <class T> template <class TT> inline
void Point2D<T>::setXY( TT xx, TT yy )
{ x = (T)xx; y = (T)yy; }

template <class T> inline
Point2D<T>& Point2D<T>::zero()
{ x = y = 0; return *this; }

template <class T> inline
Point2D<T> Point2D<T>::operator -()
{ return Point2D<T>( -x, -y ); }


template <class T> inline
T& Point2D<T>::operator[]( int idx )
{ return idx ? y : x; }


template <class T> inline
T Point2D<T>::operator[]( int idx ) const
{ return idx ? y : x; }


template <class T> inline
bool Point2D<T>::operator ==( const Point2D<T>& p ) const
{ return p.x == x && p.y == y; }


template <class T> inline
bool Point2D<T>::operator !=( const Point2D<T>& p ) const
{ return !(*this==p); }

template <class T> inline
Point2D<T>& Point2D<T>::operator+=( T dist )
{ x += dist; y += dist; return *this; }


template <class T> inline
Point2D<T>& Point2D<T>::operator*=( T factor )
{ x *= factor; y *= factor; return *this; }


template <class T> inline
Point2D<T>& Point2D<T>::operator/=( T den )
{ x /= den; y /= den; return *this; }


template <class T> inline
Point2D<T>& Point2D<T>::operator +=( const Point2D<T>& p )
{ x += p.x; y += p.y; return *this; }


template <class T> inline
Point2D<T>& Point2D<T>::operator -=( const Point2D<T>& p )
{ x -= p.x; y -= p.y; return *this; }


template <class T> inline
Point2D<T> Point2D<T>::operator +( const Point2D<T>& p ) const
{ return Point2D<T>(x+p.x,y+p.y); }


template <class T> inline
Point2D<T> Point2D<T>::operator -( const Point2D<T>& p ) const
{ return Point2D<T>(x-p.x,y-p.y); }


template <class T> inline
Point2D<T> Point2D<T>::operator *( const T factor ) const
{ return Point2D<T>(factor*x,factor*y); }


template <class T> inline
Point2D<T> Point2D<T>::operator /( const T den ) const
{ return Point2D<T>(x/den,y/den); }


template <class T> inline
bool Point2D<T>::isDefined() const
{ return !mIsUdf(x) && !mIsUdf(y); }
    
    
template <class T> inline
void Point2D<T>::swapXY()
{
    T tmp;
    mSWAP( x, y, tmp );
}


template <class T> inline
double Point2D<T>::abs() const
{ return ::Math::Sqrt( (double)sqAbs() ); }


template <class T> inline
T Point2D<T>::sqAbs() const
{ return x*x + y*y; }


template <class T> inline
double Point2D<T>::distTo( const Point2D<T>& pt ) const
{ return ::Math::Sqrt( (double)sqDistTo(pt) ); }


template <class T> inline
T Point2D<T>::sqDistTo( const Point2D<T>& pt ) const
{
    const T xdiff = x-pt.x;
    const T ydiff = y-pt.y;
    return xdiff*xdiff + ydiff*ydiff;
}


template <class T> inline
Size2D<T>::Size2D( T w , T h ) 
{ width_=w; height_=h; }


template <class T> inline
bool Size2D<T>::operator ==( const Size2D<T>& s ) const
{ return s.width_ == width_ && s.height_ == height_; }


template <class T> inline
bool Size2D<T>::operator !=( const Size2D<T>& s ) const
{ return s.width_ != width_ || s.height_ != height_; }


template <class T> inline
T Size2D<T>::width() const
{ return width_; }


template <class T> inline
T Size2D<T>::height() const
{ return height_; }


template <class T> inline
void Size2D<T>::setWidth( T val )
{ width_ = val; }


template <class T> inline
void Size2D<T>::setHeight( T val )
{ height_ = val; }


template <class T> inline
Size2D<T> Size2D<T>::operator+( T val ) const
{ return Size2D<T>( width_+val, height_+val); }


template <class T> inline
Size2D<T>& Size2D<T>::operator +=( T val )
{ width_ += val; height_ += val; return *this; }


template <class T> inline
Size2D<T>& Size2D<T>::operator -=( T val )
{ width_ -= val; height_ -= val; return *this; }


template <class T> inline
Size2D<T>& Size2D<T>::operator +=( const Size2D<T>& s )
{ width_+=s.width_; height_+=s.height_; return *this; }


template <class T> inline
Size2D<T>& Size2D<T>::operator -=( const Size2D<T>& s )
{
    width_ -= s.width_; height_ -= s.height_;
    if ( width_<0 ) width_ = -width_;
    if ( height_<0 ) height_ = -height_;
    return *this;
}


template <class T> inline
Rectangle<T>::Rectangle( T l, T t, T r, T b ) 
    : topleft_( Point2D<T>(l,t)) 
    , bottomright_( Point2D<T>(r,b) )
{}


template <class T> inline
Rectangle<T>::Rectangle( const Point2D<T>& tl, const Point2D<T>& br ) 
    : topleft_( tl ) , bottomright_( br )
{}


template <class T> inline
Rectangle<T>::Rectangle( const Point2D<T>& tl, const Size2D<T>& sz ) 
    : topleft_( tl ) , bottomright_( tl.x+sz.width(), tl.y+sz.height() )
{}


template <class T> inline
bool Rectangle<T>::operator ==( const Rectangle<T>& r ) const
{ return r.topleft_ == topleft_ && r.bottomright_ == bottomright_; }


template <class T> inline
bool Rectangle<T>::operator !=( const Rectangle<T>& r ) const
{ return r.topleft_ != topleft_ || r.bottomright_ != bottomright_; }


template <class T> inline
Point2D<T> Rectangle<T>::topLeft() const
{ return topleft_; }


template <class T> inline
Point2D<T> Rectangle<T>::topRight() const
{ return Point2D<T>(right(),top()); }


template <class T> inline
Point2D<T> Rectangle<T>::bottomLeft() const
{ return Point2D<T>(left(),bottom()); }


template <class T> inline
Point2D<T> Rectangle<T>::bottomRight() const
{ return bottomright_; }


template <class T> inline
Point2D<T> Rectangle<T>::centre() const 		
{
    return Point2D<T>( (topleft_.x+bottomright_.x)/2,
		       (topleft_.y+bottomright_.y)/2 ); 
}


template <class T> inline
void Rectangle<T>::setTopLeft( Point2D<T> tl )
{ topleft_ = tl; }


template <class T> inline
void Rectangle<T>::setBottomRight( Point2D<T> br )
{ bottomright_ = br; }


template <class T> inline
void Rectangle<T>::setTopRight( Point2D<T> tr )
{ topleft_.y = tr.y; bottomright_.x = tr.x; }


template <class T> inline
void Rectangle<T>::setBottomLeft( Point2D<T> tr )
{ topleft_.x = tr.x; bottomright_.y = tr.y; }


template <class T> inline
void Rectangle<T>::setTopBottom( const Interval<T>& rg )
{ topleft_.y = rg.start; bottomright_.y = rg.stop; }


template <class T> inline
void Rectangle<T>::setLeftRight( const Interval<T>& rg )
{ topleft_.x = rg.start; bottomright_.x = rg.stop; }


template <class T> inline
Point2D<T> Rectangle<T>::moveInside( const Point2D<T>& pt ) const
{
    Point2D<T> res = pt;

    res.x = mMAX( res.x, mMIN( left(), right() ) );
    res.x = mMIN( res.x, mMAX( left(), right() ) );
    res.y = mMAX( res.y, mMIN( bottom(), top() ) );
    res.y = mMIN( res.y, mMAX( bottom(), top() ) );

    return res;
}


template <class T> inline
T Rectangle<T>::width() const
{ return revX() ? left()-right() : right() - left(); }


template <class T> inline
T Rectangle<T>::height() const
{ return revY() ? bottom()-top() : top()-bottom(); }


template <class T> inline
T Rectangle<T>::left() const
{ return topleft_.x; }


template <class T> inline
T Rectangle<T>::top() const
{ return topleft_.y; }


template <class T> inline
T Rectangle<T>::right() const
{ return bottomright_.x; }


template <class T> inline
T Rectangle<T>::bottom() const
{ return bottomright_.y; }


template <class T> inline
void Rectangle<T>::setLeft( T val )
{ topleft_.x = val; }


template <class T> inline
void Rectangle<T>::setTop( T val )
{ topleft_.y = val; }


template <class T> inline
void Rectangle<T>::setRight( T val )
{ bottomright_.x = val; }


template <class T> inline
void Rectangle<T>::setBottom( T val )
{ bottomright_.y = val; }


template <class T> inline
void Rectangle<T>::checkCorners( bool leftislow, bool topislow )
{ 
    if ( leftislow == (left() > right()) ) swapHor(); 
    if ( topislow  == (top() > bottom()) ) swapVer(); 
}


template <class T> inline
Size2D<T> Rectangle<T>::size() const
{ return Size2D<T>( width(), height() ); }


template <class T> inline
void Rectangle<T>::zero()
{ topleft_.zero(); bottomright_.zero(); }


template <class T> inline
Rectangle<T>& Rectangle<T>::operator +=( const Point2D<T>& p )
{ topleft_ += p; bottomright_ += p; return *this; }


template <class T> inline
Rectangle<T>& Rectangle<T>::operator -=( const Point2D<T>& p )
{ topleft_ -= p; bottomright_ -= p; return *this; }


template <class T> inline
Rectangle<T>& Rectangle<T>::operator +=( const Size2D<T>& sz )
{ bottomright_.x += sz.width(); bottomright_.y += sz.height(); return *this; }


template <class T> inline
Rectangle<T>& Rectangle<T>::operator -=( const Size2D<T>& sz )
{ bottomright_.x -= sz.width(); bottomright_.y -= sz.height(); return *this; }


template <class T> inline
void Rectangle<T>::swapHor() 
{ 
    T t = topleft_.x; 
    topleft_.x = bottomright_.x;
    bottomright_.x =  t;
}


template <class T> inline
void Rectangle<T>::swapVer() 
{ 
    T t = topleft_.y; 
    topleft_.y = bottomright_.y;
    bottomright_.y =  t;
}


template <class T> inline
bool Rectangle<T>::revX() const
{ return left() > right(); }


template <class T> inline
bool Rectangle<T>::revY() const
{ return bottom() > top(); }


template <class T>
inline bool PixRectangle<T>::xOutside( T x ) const
{
    return this->revX() ? (x > this->left() || x < this->right())
			: (x < this->left() || x > this->right());
}


template <class T>
inline bool PixRectangle<T>::yOutside( T y ) const
{
    return this->revY() ? (y > this->bottom() || y < this->top())
			: (y < this->bottom() || y > this->top());
}


template <class T>
inline bool PixRectangle<T>::isOnSide( const Point2D<T>& pt ) const
{
    return (pt.x == this->left() || pt.x == this->right())
	&& (pt.y == this->top()  || pt.y == this->bottom());
}


template <class T>
inline bool PosRectangle<T>::xOutside( T x, T eps ) const
{
    return this->revX() ? (x-this->left() > eps || this->right()-x > eps)
			: (this->left()-x > eps || x-this->right() > eps);
}


template <class T>
inline bool PosRectangle<T>::yOutside( T y, T eps ) const
{
    return this->revY() ? (this->top()-y > eps || y-this->bottom() > eps)
			: (y-this->top() > eps || this->bottom()-y > eps);
}


template <class T>
inline bool PosRectangle<T>::isOnSide( const Point2D<T>& pt, T eps ) const
{
    if ( xOutside(pt.x) || yOutside(pt.y) ) return false;
    return fabs(pt.x - this->left()) < eps || fabs(pt.x - this->right()) < eps
        || fabs(pt.y - this->top()) < eps || fabs(pt.y - this->bottom()) < eps;
}


template <class T>
inline bool PosRectangle<T>::isInside( const Point2D<T>& pt, T eps ) const
{
    return (this->revX() ? (this->left()-pt.x>eps && pt.x-this->right()>eps)
			 : (pt.x-this->left()>eps && this->right()-pt.x>eps))
	&& (this->revY() ? (pt.y-this->bottom()<-eps && this->top()-pt.y<-eps)
			 : (this->bottom()-pt.y<-eps && pt.y-this->top()<-eps));
}


template <class T>
inline T iwiderPos( int x1, int x2, double f )
{ return (T)mNINT32(x1 + f * (x1 - x2)); }


template <class T>
inline T fwiderPos( T x1, T x2, T f )
{ return x1 + f * (x1 - x2); }


template <class T>
PixRectangle<T>::PixRectangle( T l , T t, T r, T b ) 
    : Rectangle<T>(l,t,r,b)		
{}


template <class T>
PixRectangle<T>::PixRectangle( const Point2D<T>& tl, const Point2D<T>& br ) 
    : Rectangle<T>(tl,br)
{}


template <class T>
PixRectangle<T>::PixRectangle( const Point2D<T>& tl, const Size2D<T>& sz ) 
    : Rectangle<T>(tl,sz)
{}


template <class T>
PixRectangle<T>::PixRectangle( const Rectangle<T>& r ) 
    : Rectangle<T>( r )
{}


template <class T> inline
bool PixRectangle<T>::isInside( const Point2D<T>& p ) const
{ return !xOutside( p.x ) && !yOutside( p.y ) && !isOnSide( p ); }


template <class T> inline
bool PixRectangle<T>::isOutside( const Point2D<T>& p ) const
{ return xOutside(p.x) || yOutside(p.y); }


template <class T> inline
bool PixRectangle<T>::contains( const Point2D<T>& p ) const
{ return !isOutside(p); }


template <class T> inline
bool PixRectangle<T>::contains( const PixRectangle<T>& other ) const
{
    return contains(other.topleft_) && contains(other.bottomright_);
}


template <class T> inline
bool PixRectangle<T>::isInside( const PixRectangle<T>& other ) const
{
    return other.isInside(this->topleft_) && other.isInside(this->bottomright_);
}


template <class T> inline
PixRectangle<T> PixRectangle<T>::grownBy( double f ) const
{
    f *= .5;
    return PixRectangle<T>( iwiderPos<T>(this->left(),this->right(),f),
			    iwiderPos<T>(this->top(),this->bottom(),f),
			    iwiderPos<T>(this->right(),this->left(),f),
			    iwiderPos<T>(this->bottom(),this->top(),f) );
}


template <class T>
inline PosRectangle<T> PosRectangle<T>::grownBy( T f ) const
{
    f *= .5;
    return PosRectangle<T>( fwiderPos(this->left(),this->right(),f),
			    fwiderPos(this->top(),this->bottom(),f),
			    fwiderPos(this->right(),this->left(),f),
			    fwiderPos(this->bottom(),this->top(),f) );
}


template <class T>
inline bool Rectangle<T>::operator >( const Rectangle<T>& r ) const
{
    Size2D<T> diff( width()-r.width(), height()-r.height() );

    if ( diff.width() > 0 && diff.height() > 0 )
	return true;
    if ( diff.width() < 0 && diff.height() < 0 )
	return false;

    return diff.width() < 0 ? diff.height() < -diff.width()
			    : diff.width() > -diff.height();
}


template <class T>
inline void Rectangle<T>::limitTo( const Rectangle<T>& r )
{
    if ( revX() )
    {
	if ( r.left() < left() ) topleft_.x = r.left();
	if ( r.right() > right() ) bottomright_.x = r.right();
    }
    else
    {
	if ( r.left() > left() ) topleft_.x = r.left();
	if ( r.right() < right() ) bottomright_.x = r.right();
    }
    if ( revY() )
    {
	if ( r.bottom() < bottom() ) bottomright_.y = r.bottom();
	if ( r.top() > top() ) topleft_.y = r.top();
    }
    else
    {
	if ( r.bottom() > bottom() ) bottomright_.y = r.bottom();
	if ( r.top() < top() ) topleft_.y = r.top();
    }
}

    
template <class T>
inline void Rectangle<T>::translate(const Point2D<T> & trans )
{
    topleft_ += trans;
    bottomright_ += trans;
}
    

template <class T>
inline void Rectangle<T>::include( const Rectangle<T>& r )
{
    if ( revX() )
    {
	if ( r.left() > left() ) topleft_.x = r.left();
	if ( r.right() < right() ) bottomright_.x = r.right();
    }
    else
    {
	if ( r.left() < left() ) topleft_.x = r.left();
	if ( r.right() > right() ) bottomright_.x = r.right();
    }
    if ( revY() )
    {
	if ( r.bottom() > bottom() ) bottomright_.y = r.bottom();
	if ( r.top() < top() ) topleft_.y = r.top();
    }
    else
    {
	if ( r.bottom() < bottom() ) bottomright_.y = r.bottom();
	if ( r.top() > top() ) topleft_.y = r.top();
    }
}

}; // namespace Geom

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef globexpr_h
#define globexpr_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		15-1-2001
 RCS:		$Id: globexpr.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "general.h"

/*!
\brief Glob-expression matching like UNIX shells

  Expressions may have '*', '?' and [] (e.g. [a-eA-E]) constructions. Also the
  inverted selection with '^' or '!' supported (e.g. [^x-z] or [!akPZ]). Escape
  the special chars with '\';
*/

mExpClass(Basic) GlobExpr
{
public:

			GlobExpr( const char* s = 0, bool casesens=true )
			: expr_(""), errmsg_(0), ci_(!casesens)	{ set(s); }
			GlobExpr( const GlobExpr& ge )
			: expr_(ge.expr_), errmsg_(0), ci_(ge.ci_) {}
    GlobExpr&		operator=( const GlobExpr& ge )
			{ expr_ = ge.expr_; errmsg_ = 0; ci_ = ge.ci_;
			  return *this; }
    bool		operator==( const GlobExpr& ge ) const
			{ return expr_ == ge.expr_ && ci_ == ge.ci_; }

    void		setCaseInSensitive( bool yn=true )	{ ci_ = yn; }

    void		set(const char*);
    inline		operator const char*() const
			{ return (const char*)expr_; }

    inline bool		matches( const char* t ) const
			{ return matches( expr_, t,
				 const_cast<const char*&>(errmsg_), ci_ ); }
    const char*		expressionFailMessage() const	{ return errmsg_; }
			//!< Normally null, only filled if invalid expression

    static bool		matches(const char* expression,const char* txt,
				const char*& errmsg_if_expression_is_incorrect,
				bool caseinsens);

protected:

    BufferString	expr_;
    const char*		errmsg_;
    bool		ci_;

    static bool		starMatches(const char*,const char*,const char*&,bool);
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef hiddenparam_h
#define hiddenparam_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		April 2011
 RCS:		$Id: hiddenparam.h 28945 2013-03-22 11:20:49Z nageswara.rao@dgbes.com $
________________________________________________________________________

-*/

#include "errh.h"
#include "thread.h"
#include "sets.h"


/*!
\brief Workaround manager when you cannot add class members to a class due to
binary compability issues.

  If you want to add the variable of type V to class O, do the following
  in the source-file:
  
  \code
  HiddenParam<O,V>	myparammanager( undef_val );
  \endcode
  
  You can then access the variable in the source-file by:
  
  \code
  myparammanager.setParam( this, new_value );
  \endcode
  
  and retrieve it by 
  
  \code
  V value = myparammanager.getParam( this );
  \endcode
  
  \note V cannot be boolean. Use char instead. V must be 'simple' enough to be
  stored in a type-set. Also note you may not be able to call the
  removeParam (if the class does not already have a destructor), so
  so don't use with objects that are created millions of times in those
  cases, as you will leak memory.
  Finally, note that you MUST set the parameter in the constructor. The
  undef value is not ment to be returned, it's merely to keep the compiler
  happy.
*/

template <class O, class V>
mClass(Basic) HiddenParam 
{
public:
    		HiddenParam( const V& undefval )
		    : undef_( undefval ) 	{}
    void	setParam( O* obj, const V& val );
    const V&	getParam( const O* obj ) const;

    bool	hasParam( const O* ) const;

    void	removeParam( O* );
protected:

    ObjectSet<O>		objects_;
    TypeSet<V>			params_;
    mutable Threads::Mutex	lock_;
    V				undef_;
};


template <class O, class V>
void HiddenParam<O,V>::setParam( O* obj, const V& val )
{
    Threads::MutexLocker lock( lock_ );
    const int idx = objects_.indexOf( obj );
    if ( idx==-1 )
    {
	objects_ += obj;
	params_ += val;
	return;
    }

    params_[idx] = val;
}


template <class O, class V>
const V& HiddenParam<O,V>::getParam( const O* obj ) const
{
    Threads::MutexLocker lock( lock_ );
    const int idx = objects_.indexOf( obj );
    if ( !objects_.validIdx(idx) )
    {
	pErrMsg("Object not found");
	return undef_;
    }

    return params_[idx];
}


template <class O, class V>
bool HiddenParam<O,V>::hasParam( const O* obj ) const
{
    Threads::MutexLocker lock( lock_ );
    return objects_.indexOf( obj ) !=-1;
}



template <class O, class V>
void HiddenParam<O,V>::removeParam( O* obj )
{
    Threads::MutexLocker lock( lock_ );
    const int idx = objects_.indexOf( obj );
    if ( idx==-1 )
	return;

    params_.removeSingle( idx );
    objects_.removeSingle( idx );
}


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef horsampling_h
#define horsampling_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bert
 Date:          Feb 2008
 RCS:           $Id: horsampling.h 32022 2013-10-18 11:52:28Z bert.bril@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "ranges.h"
#include "position.h"

class IOPar;


/*!
\brief Horizontal sampling (inline and crossline range and steps).
*/

mExpClass(Basic) HorSampling
{
public:
			HorSampling( bool settoSI=true ) { init(settoSI); }
    HorSampling&	set(const Interval<int>& inlrg,
	    		    const Interval<int>& crlrg);
    			//!< steps copied if available
    void		get(Interval<int>& inlrg,Interval<int>& crlrg) const;
    			//!< steps filled if available
			
    StepInterval<int>	inlRange() const;
    StepInterval<int>	crlRange() const;
    void		setInlRange(const Interval<int>&);
    void		setCrlRange(const Interval<int>&);

    bool		includes( const HorSampling& hs,
	    			  bool ignoresteps=false ) const;
    inline bool		includes( const BinID& bid ) const
			{ return inlOK(bid.inl) && crlOK(bid.crl); }
    inline bool		inlOK( int inl ) const
			{ return inl >= start.inl && inl <= stop.inl && 
			    (step.inl ? !( (inl-start.inl) % step.inl )
				      : inl==start.inl); }

    inline bool		crlOK( int crl ) const
			{ return crl >= start.crl && crl <= stop.crl && 
			    (step.crl ? !( (crl-start.crl) % step.crl )
			     	      : crl==start.crl); }

    inline void		include( const BinID& bid )
			{ includeInl(bid.inl); includeCrl(bid.crl); }
    void		includeInl( int inl );
    void		includeCrl( int crl );
    void		include( const HorSampling&, bool ignoresteps=false );
    bool		isDefined() const;
    void		limitTo(const HorSampling&);
    void		limitToWithUdf(const HorSampling&);
    			/*!< handles undef values +returns reference horsampling
			     nearest limit if horsamplings do not intersect */

    inline int		inlIdx( int inl ) const
			{ return step.inl ? (inl-start.inl) / step.inl 
					  : (inl==start.inl ? 0 : -1); }
    inline int		crlIdx( int crl ) const
			{ return step.crl ? (crl-start.crl) / step.crl
					  : (crl==start.crl ? 0 : -1); }
    inline od_int64	globalIdx( const BinID& bid ) const
			{ return inlIdx(bid.inl)*nrCrl() + crlIdx(bid.crl); }
    BinID		atIndex( int i0, int i1 ) const
			{ return BinID( start.inl + i0*step.inl,
					start.crl + i1*step.crl ); }
    BinID		atIndex( od_int64 globalidx ) const;
    int			nrInl() const;
    int			nrCrl() const;
    inline od_int64	totalNr() const	{ return ((od_int64)nrInl())*nrCrl(); }
    inline bool		isEmpty() const { return nrInl() < 1 || nrCrl() < 1; }

    void		init(bool settoSI=true);
    			//!< Sets to survey values or mUdf(int) (but step 1)
    void		set2DDef();
    			//!< Sets ranges to 0-maxint
    void		normalise();
    			//!< Makes sure start<stop and steps are non-zero
    void		getRandomSet(int nr,TypeSet<BinID>&) const;

    bool		getInterSection(const HorSampling&,HorSampling&) const;
    			//!< Returns false if intersection is empty

    BinID		getNearest(const BinID&) const;
			    /*!< step-snap and outside -> edge.
				Assumes inldist == crldist */
    void		snapToSurvey();
    			/*!< Checks if it is on valid bids. If not, it will
			     expand until it is */

    bool		operator==( const HorSampling& hs ) const
			{ return hs.start==start && hs.stop==stop 
			    			 && hs.step==step; }

    bool		usePar(const IOPar&);	//!< Keys as in keystrs.h
    void		fillPar(IOPar&) const;	//!< Keys as in keystrs.h
    static void		removeInfo(IOPar&);
    void		toString(BufferString&) const; //!< Nice text for info

    BinID		start;
    BinID		stop;
    BinID		step;
    TraceID::GeomID	geomid_;
};


/*!
\brief Finds next BinID in HorSampling; initializes to first position.
*/

mExpClass(Basic) HorSamplingIterator
{
public:
    		HorSamplingIterator() : hrg_( true ) { reset(); }
    		HorSamplingIterator( const HorSampling& hs )
		    : hrg_(hs)	{ reset(); }

    void	setSampling( const HorSampling& hs )
		{ hrg_ = hs; reset(); }

    void	reset(bool nextisfirstpos=true)	{ firstpos_ = nextisfirstpos; }
    		/*!<If nextisfirstpos, the next call to next will automatically
		    be hrg_.start. */
    bool	next(BinID&);

protected:

    HorSampling		hrg_;
    bool		firstpos_;

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef hostdata_h
#define hostdata_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bert Bril
 Date:          Apr 2002
 RCS:           $Id: hostdata.h 33863 2014-03-27 11:28:52Z ranojay.sen@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstringset.h"
#include "filepath.h"
#include "manobjectset.h"

class HostDataList;
class ShareData;

#define mRetNoneIfEmpty( bs ) \
    if ( bs.isEmpty() ) return "_none_"; \
    return bs;

/*!
\brief Host name and aliases.
*/

mExpClass(Basic) HostData
{
public:

    enum PathType	{ Appl, Data };

protected:
    			HostData( const char* nm, bool iswin=false )
			    : iswin_(iswin)
			    , localhd_(0)
			    , sharedata_(0)	{ init(nm); }
public:
    			HostData( const char* nm, const HostData& localhost,
				  bool iswin=false )
			    : iswin_(iswin)
			    , localhd_(&localhost)
			    , sharedata_(0)	{ init(nm); }


    			HostData( const HostData& oth )
			    : aliases_( oth.aliases_ )
			    , iswin_( oth.iswin_ )
			    , appl_pr_( oth.appl_pr_ )
			    , data_pr_( oth.data_pr_ )
			    , pass_( oth.pass_ )
			    , localhd_( oth.localhd_ )
			    , sharedata_( oth.sharedata_ ) { init(oth.name_); }

    virtual		~HostData()	{ deepErase(aliases_); }

    const char*		name() const	{ return (const char*)name_; }
    const char*		address() const {  return GetIPFromHostName( name() ); }
    const char*		pass() const	{ mRetNoneIfEmpty(pass_) }

    int			nrAliases() const
			{ return aliases_.size(); }
    const char*		alias( int idx ) const
			{ return (const char*)(*aliases_[idx]); }
    bool		isKnownAs(const char*) const;
    			//!< true if name or an alias matches
    void		addAlias(const char*);
    			//!< only adds if !isKnownAs

    bool		isWin() const 		{ return iswin_; }
    FilePath::Style	pathStyle() const
			    {
				return iswin_ ? FilePath::Windows
					      : FilePath::Unix;
			    }
			//! As is on remote host.
    const FilePath&	prefixFilePath( PathType pt ) const
			    { return pt == Appl ? appl_pr_ : data_pr_; }

    FilePath		convPath( PathType pt, const FilePath&,
				  const HostData* from = 0 ) const;
    FilePath		convPath( PathType pt, const char* fn,
				  const HostData* from = 0 ) const
			    { return convPath(pt, FilePath(fn), from ); }

    static const char*	localHostName();
    void		setLocalHost( const HostData& hd )
			{ localhd_ = &hd; }
    const HostData&	localHost() const
    			{ return localhd_ ? *localhd_ : *this; }

    const ShareData*	shareData() const	{ return sharedata_; }
    void		setShareData( const ShareData* sd ) { sharedata_ = sd; }

protected:

    BufferString	name_;
    BufferStringSet	aliases_;
    bool		iswin_;
    FilePath		appl_pr_;
    FilePath		data_pr_;
    BufferString	pass_;
    const HostData*	localhd_;
    const ShareData*	sharedata_;

    friend class	HostDataList;

    void		init( const char* nm );
};


/*!
\brief Describes shared drive and host. Mostly win32.
*/

mExpClass(Basic) ShareData
{
public:
			ShareData( const HostData* hst=0 ) : host_(hst) {}

    const HostData*	host() const	{ return host_; }
    const char*		hostName() const
			{
			    if ( host() ) return host()->name(); 
			    return "_none_";
			}

    // Windows only
    const char*		drive() const	{ mRetNoneIfEmpty(drive_) }
    const char*		share() const	{ mRetNoneIfEmpty(share_) }
    const char*		pass() const
			{
			    if ( pass_ != "" ) return pass_;
			    if ( host() ) return host()->pass(); 
			    return "_none_";
			}
protected:


    const HostData*	host_;
    BufferString	drive_;
    BufferString	share_;
    BufferString	pass_;

    friend class	HostDataList;
};



/*!
\brief List of host names in the system.
  The first entry will be the local host.
*/

mExpClass(Basic) HostDataList : public ManagedObjectSet<HostData>
{
public:
			HostDataList(bool readhostfile=true);

    int			defNiceLevel() const	{ return defnicelvl_; }
    int			firstPort() const	{ return portnr_; }
    const char*		rshComm() const		{ return rshcomm_; }

    HostData*		find( const char* nm )	{ return findHost(nm); }
    const HostData*	find( const char* nm ) const { return findHost(nm); }

protected:

    bool		realaliases_;
    BufferString	rshcomm_;
    int			defnicelvl_;
    int			portnr_;
    FilePath		win_appl_pr_;
    FilePath		unx_appl_pr_;
    FilePath		win_data_pr_;
    FilePath		unx_data_pr_;
    ShareData		sharedata_;

    void		handleLocal();
    bool		readHostFile(const char*);
    HostData*		findHost(const char*) const;

public:

    void		dump(std::ostream&) const;

};

#undef mRetNoneIfEmpty

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef indexinfo_h
#define indexinfo_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		Jan 2006
 RCS:		$Id: indexinfo.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "samplingdata.h"


/*!
\brief %Info on (floating-point) position in an array or StepInterval.
*/

mExpClass(Basic) IndexInfo
{
public:
			IndexInfo( int i, bool r=true, bool u=false )
			    : nearest_(i)
			    , roundedtolow_(r)
			    , inundef_(u)		{}
    template <class X,class Y>
			IndexInfo( const StepInterval<X>& s, Y y )
			    { set( s, y ); }
    template <class X,class Y>
			IndexInfo( const SamplingData<X>& s, Y y, int len )
			    { set( s, y, len ); }
    template <class T>
			IndexInfo(const T*,int sz,T val);

    template <class X,class Y>
    void		set(const StepInterval<X>&,Y);
    template <class X,class Y>
    void		set(const SamplingData<X>&,Y,int length);


    int			nearest_;
    bool		roundedtolow_;
    bool		inundef_;
};


template <class T> inline
IndexInfo::IndexInfo( const T* arr, int sz, T val )
    : nearest_(0)
    , roundedtolow_(true)
    , inundef_(true)
{
    if ( sz < 1 || !arr )
	return;
    if ( sz == 1 )
	{ inundef_ = val != arr[0]; return; }
    const bool isrev = arr[0] > arr[sz-1];
    if ( (isrev && val >= arr[0]) || (!isrev && val<=arr[0]) )
	{ inundef_ = val != arr[0]; roundedtolow_ = isrev; return; }
    if ( (!isrev && val >= arr[sz-1]) || (isrev && val<=arr[sz-1]) )
	{ nearest_ = sz-1; inundef_ = val != arr[sz-1]; roundedtolow_ = !isrev;
	  return; }

    inundef_ = false;
    for ( nearest_=1; nearest_<sz; nearest_++ )
    {
	if ( arr[nearest_] == val )
	    return;
	if ( (!isrev && val < arr[nearest_]) || (isrev && val > arr[nearest_]) )
	{
	    T halfway = (arr[nearest_] + arr[nearest_-1]) * .5f;
	    roundedtolow_ = isrev ? val > halfway : val < halfway;
	    if ( (!isrev && roundedtolow_) || (isrev && !roundedtolow_) )
		nearest_ -= 1;
	    return;
	}
    }
    // Can we get here? Better safe than sorry.
    nearest_ = sz - 1; inundef_ = true; roundedtolow_ = !isrev;
}


template <class X,class Y> inline
void IndexInfo::set( const StepInterval<X>& intv, Y y )
{
    const bool isrev = intv.step < 0;
    const Y hstep = intv.step * 0.5;

    if ( (isrev && y>intv.start+hstep) || (!isrev && y<intv.start-hstep) )
	{ inundef_ = true; roundedtolow_ = false; nearest_ = 0; }
    else if ( (isrev && y< intv.stop-hstep) || (!isrev && y>intv.stop+hstep) )
	{ inundef_ = true; roundedtolow_ = true; nearest_ = intv.nrSteps(); }
    else
    {
	inundef_ = false;
	nearest_ = intv.getIndex( y );
	const Y pred = intv.atIndex( nearest_ );
	roundedtolow_ = isrev ? pred < y : pred > y;
    }
}

template <class X,class Y> inline
void IndexInfo::set( const SamplingData<X>& sd, Y y, int nr )
{
    return set( StepInterval<X>( sd.start, sd.atIndex(nr-1), sd.step ), y );
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef initval_h
#define initval_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        A.H. Lammertink
 Date:          13/01/2005
 RCS:           $Id: initval.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "plftypes.h"

namespace Values
{

/*!
\brief Templatized initialization values.
*/

template<class T>
mClass(Basic) Init
{
public:
    static T		val();
};


/*!
\brief Templatized od_int16 initialization values.
*/

template<>
mClass(Basic) Init<od_int16>
{
public:
    static od_int16	val()		{ return 0; }
};


/*!
\brief Templatized od_uint16 initialization values.
*/

template<>
mClass(Basic) Init<od_uint16>
{
public:
    static od_uint16	val()		{ return 0; }
};


/*!
\brief Templatized od_int32 initialization values.
*/

template<>
mClass(Basic) Init<od_int32>
{
public:
    static od_int32	val()		{ return 0; }
};


/*!
\brief Templatized od_uint32 initialization values.
*/

template<>
mClass(Basic) Init<od_uint32>
{
public:
    static od_uint32	val()		{ return 0; }
};


/*!
\brief Templatized od_int64 initialization values.
*/

template<>
mClass(Basic) Init<od_int64>
{
public:
    static od_int64	val()		{ return 0; }
};


/*!
\brief Templatized od_uint64 initialization values.
*/

template<>
mClass(Basic) Init<od_uint64>
{
public:
    static od_uint64	val()		{ return 0; }
};


/*!
\brief Templatized boolean initialization values.
*/

template<>
mClass(Basic) Init<bool>
{
public:
    static bool		val()		{ return false; }
};


/*!
\brief Templatized float initialization values.
*/

template<>
mClass(Basic) Init<float>
{
public:
    static float	val()		{ return 0.0f; }
};


/*!
\brief Templatized double initialization values.
*/

template<>
mClass(Basic) Init<double>
{
public:
    static double	val()		{ return 0.0; }
};


/*!
\brief Templatized const char* initialization values.
*/

template<>
mClass(Basic) Init<const char*>
{
public:
    static const char*	val()			{ return ""; }
};


template <class T>
T& init( T& e )
{ 
    e = Init<T>::val(); 
    return e; 
}


template <class T>
const T& initVal()
{ 
    static T e= Init<T>::val();
    return e;
}

}

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef iopar_h
#define iopar_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		21-12-1995
 RCS:		$Id: iopar.h 32429 2013-11-14 15:49:00Z bert.bril@dgbes.com $
________________________________________________________________________

-*/
 
#include "basicmod.h"
#include "namedobj.h"
#include "sets.h"
#include "fixedstring.h"
#include "samplingdata.h"

class BinID;
class BufferString;
class BufferStringSet;
class Coord;
class Color;
class Coord3;
class MultiID;
class SeparString;
class ascistream;
class ascostream;

/*!
\brief Generalized set of parameters of the keyword-value type.

  Part of the function of this class is as in an STL map<string,string>.
  Passing a keyword will return the appropriate value.
  
  Tools around this basic idea are paring into other types, key composition,
  reading/writing to/from file, merging, and more.
  
  dumpPretty() is used for reports.  The title of the report is the name of the
  IOPar. If sKeyHdr and sKeySubHdr are the key, there will be a (sub)header
  with the value. Use add() rather than set(). Values may contain newlines.
*/

mExpClass(Basic) IOPar : public NamedObject
{
public:
			IOPar(const char* nm=0); //!< empty
			IOPar(ascistream&);
			IOPar(const IOPar&);
			~IOPar();
    IOPar&		operator =(const IOPar&);
    inline bool		operator ==( const IOPar& iop ) const
			{ return isEqual(iop); }
    inline bool		operator !=( const IOPar& iop ) const
			{ return !isEqual(iop); }

    int			size() const;
    inline bool		isEmpty() const		{ return size() == 0; }
    bool		isEqual(const IOPar&,bool need_same_order=false) const;

    int			indexOf(const char* key) const;
    FixedString		getKey(int) const;
    FixedString		getValue(int) const;
    bool		setKey(int,const char*);
    void		setValue(int,const char*);
    void		remove(int);
    void		remove(const char* key);
    bool		hasKey( const char* s ) const
			{ return !find(s).isEmpty(); }
    const char*		findKeyFor(const char*,int nr=0) const;
				//!< returns null if value not found
    void		removeWithKey(const char* globexpression);
				//!< removes all entries with key matching
				//!< this glob expression

    void		setEmpty();
			//!< remove all entries (doesn't clear name)
    void		merge(const IOPar&);
			//!< merge entries using the set() command
    static const char*	compKey(const char*,const char*);
			//!< The composite key: (a,b) -> a.b
    static const char*	compKey(const char*,int);
			//!< The composite key where int will be --> string
    IOPar*		subselect(const char*) const;
			//!< returns iopar with key that start with <str>.
    IOPar*		subselect(int) const;
			//!< returns iopar with key that start with number.
    void		removeSubSelection(const char*);
			//!< removes with key that start with <str>.
    void		removeSubSelection(int);
			//!< removes with key that start with number.
    void		mergeComp(const IOPar&,const char*);
			//!< merge entries, where IOPar's entries get a prefix

// GET functions

    FixedString		find(const char*) const;
			//!< returns null if not found
    FixedString		operator[](const char*) const;
			//!< returns empty string if not found

    			// Functions for getting 1,2,3 and 4 of the same type
#define mIOParDeclFns(type) \
    bool		get(const char*,type&) const; \
    bool		get(const char*,type&,type&) const; \
    bool		get(const char*,type&,type&,type&) const; \
    bool		get(const char*,type&,type&,type&,type&) const

    			mIOParDeclFns(int);
    			mIOParDeclFns(od_uint32);
    			mIOParDeclFns(od_int64);
    			mIOParDeclFns(od_uint64);
    			mIOParDeclFns(float);
    			mIOParDeclFns(double);
#undef mIOParDeclFns
    bool		getYN(const char*,bool&) const;
    bool		getYN(const char*,bool&,bool&) const;
    bool		getYN(const char*,bool&,bool&,bool&) const;
    bool		getYN(const char*,bool&,bool&,bool&,bool&) const;
    inline bool		isTrue( const char* key ) const
			{ bool is = false; return getYN(key,is) && is; }
    inline bool		isFalse( const char* key ) const
			{ bool is = true; return getYN(key,is) && !is; }

    bool		get(const char*,int&,int&,float&) const;

    bool		get(const char*,TypeSet<int>&) const;
    bool		get(const char*,TypeSet<od_uint32>&) const;
    bool		get(const char*,TypeSet<od_int64>&) const;
    bool		get(const char*,TypeSet<od_uint64>&) const;
    bool		get(const char*,TypeSet<double>&) const;
    bool		get(const char*,TypeSet<float>&) const;

    bool		get(const char*,BinID&) const;
    bool		get(const char*,Coord&) const;
    bool		get(const char*,Coord3&) const;
    bool		get(const char*,MultiID&) const;
    bool		get(const char*,Color&) const;
    bool		get(const char*,SeparString&) const;
    bool		get(const char*,BufferString&) const;
    bool		get(const char*,BufferString&,BufferString&) const;
    bool		get(const char*,BufferStringSet&) const;
    template <class T>
    bool		get(const char*,Interval<T>&) const;
    template <class T>
    bool		get(const char*,SamplingData<T>&) const;

    bool		getPtr(const char*,void*&) const;

#define mIOParDeclFns(type) \
    bool		getScaled(const char*,type&,type applied_scale, \
	    		      bool set_to_undef_if_not_found) const; \
    bool		getScaled(const char*,type&,type&,type,bool) const; \
    bool		getScaled(const char*,type&,type&,type&,type, \
	    			  bool) const; \
    bool		getScaled(const char*,type&,type&,type&,type&,type, \
	    		      bool) const
    			mIOParDeclFns(float);
    			mIOParDeclFns(double);
#undef mIOParDeclFns


// SET functions

    void		set(const char* ky,const char* val);
			/*!< replaces when key already exists, otherwise adds */
    void		add(const char* ky,const char* val);
			/*!< unsafe: does not check for duplicate keys */
    void		update(const char* ky,const char* val);
			/*!< removes if val is empty or null */

    			// Functions for 1,2,3 and 4 of the same type
#define mIOParDeclFns(fnnm,type) \
    void		fnnm(const char*,type); \
    void		fnnm(const char*,type,type); \
    void		fnnm(const char*,type,type,type); \
    void		fnnm(const char*,type,type,type,type)

			mIOParDeclFns(set,int);
			mIOParDeclFns(set,od_uint32);
			mIOParDeclFns(set,od_int64);
			mIOParDeclFns(set,od_uint64);
			mIOParDeclFns(set,float);
			mIOParDeclFns(set,double);
			mIOParDeclFns(add,int);
			mIOParDeclFns(add,od_uint32);
			mIOParDeclFns(add,od_int64);
			mIOParDeclFns(add,od_uint64);
			mIOParDeclFns(add,float);
			mIOParDeclFns(add,double);
#undef mIOParDeclFns
#define mIOParDeclYNFns(fnnm) \
    void		fnnm##YN(const char*,bool); \
    void		fnnm##YN(const char*,bool,bool); \
    void		fnnm##YN(const char*,bool,bool,bool); \
    void		fnnm##YN(const char*,bool,bool,bool,bool)
			mIOParDeclYNFns(set);
			mIOParDeclYNFns(add);
#undef mIOParDeclYNFns

    void		set(const char*,int,int,float);
    void		setPtr(const char*,void*);

    void		set(const char*,const char*,const char*);
    void		set(const char*,const BinID&);
    void		set(const char*,const Coord&);
    void		set(const char*,const Coord3&);
    void		set(const char*,const MultiID&);
    void		set(const char*,const Color&);
    void		set(const char*,const SeparString&);
    void		set(const char*,const FixedString&);
    void		set(const char*,const BufferString&);
    void		set(const char*,const BufferString&,
	    				const BufferString&);
    void		set(const char*,const BufferStringSet&);
    template <class T>
    void		set(const char*,const Interval<T>&);
    template <class T>
    void		set(const char*,const SamplingData<T>&);

    void		set(const char*,const TypeSet<int>&);
    void		set(const char*,const TypeSet<od_uint32>&);
    void		set(const char*,const TypeSet<od_int64>&);
    void		set(const char*,const TypeSet<od_uint64>&);
    void		set(const char*,const TypeSet<double>&);
    void		set(const char*,const TypeSet<float>&);

    void		setToDateTime(const char* ky=0);
    void		setToUser(const char* ky=0);
    void		setStdCreationEntries();


// I/O  functions

    // to/from string: 'serialisation'
    void		getFrom(const char*);
    void		getParsFrom(const char*);
    void		putTo(BufferString&) const;
    void		putParsTo(BufferString&) const;

    // to/from file
    void		getFrom(ascistream&);
    void		putTo(ascostream&) const;
    bool		read(const char* filename,const char* filetype,
	    			bool chktype=false);
    			//!< filetype null will assume no file header
    			//!< uses set(). no clear() done
    bool		read(std::istream&,const char* filetype,
	    			bool chktype=false);
    bool		write(const char* filename,const char* filetype) const;
    			//!< If filetype is set to null no ascstream header
    			//!< sKeyDumpPretty calls dumpPretty.
    bool		write(std::ostream&,const char* filetyp) const;
    void		dumpPretty(BufferString&) const;
    void		dumpPretty(std::ostream&) const;

    static const char*	sKeyDumpPretty()         { return "_pretty"; }
    static const char*	sKeyHdr()		 { return "->";	     }	
    static const char*	sKeySubHdr()		 { return "-->";     }   	

protected:

    BufferStringSet&	keys_;
    BufferStringSet&	vals_;

};


template <class T>
inline bool IOPar::get( const char* k, Interval<T>& i ) const
{
    mDynamicCastGet(StepInterval<T>*,si,&i)
    return si ? get( k, i.start, i.stop, si->step )
	      : get( k, i.start, i.stop );
}


template <class T>
inline void IOPar::set( const char* k, const Interval<T>& i )
{
    mDynamicCastGet(const StepInterval<T>*,si,&i)
    if ( si )	set( k, i.start, i.stop, si->step );
    else	set( k, i.start, i.stop );
}


template <class T>
inline bool IOPar::get( const char* k, SamplingData<T>& sd ) const
{
    return get( k, sd.start, sd.step );
}


template <class T>
inline void IOPar::set( const char* k, const SamplingData<T>& sd )
{
    set( k, sd.start, sd.step );
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef i_qptr_h
#define i_qptr_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          November 2012
 RCS:           $Id: i_qptr.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include <callback.h>
#include <thread.h>

#include <QObject>

QT_BEGIN_NAMESPACE

/*!
\brief Helper class for QPtr to relay Qt's messages. Internal object, to hide
Qt's signal/slot mechanism.
*/

class Export_Basic i_QPtrImpl : public QObject, public CallBacker
{
    Q_OBJECT

public:

    Notifier<i_QPtrImpl> notifier_;
    Threads::Mutex	lock_;

    QObject*		ptr()				{ return sender_; }
    const QObject*	ptr() const			{ return sender_; }
    
    
			operator QObject*()		{ return sender_; }
			operator const QObject*() const	{ return sender_; }
    QObject*		operator->()			{ return sender_; }
    QObject*		operator->() const		{ return sender_; }
    QObject*		operator=(QObject* qo)		{ set( qo ); return qo;}
    
    Threads::Mutex&	mutex()				{ return lock_; }

    
    void		set(QObject* qo);
			i_QPtrImpl( QObject* sndr = 0 );
			~i_QPtrImpl();

private:

    QObject*		sender_;

private slots:

    void		destroyed( QObject* )
			{
			    notifier_.trigger();
			    Threads::MutexLocker lock( lock_ );
			    sender_ = 0;
			}

};

QT_END_NAMESPACE

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef keystrs_h
#define keystrs_h

/*+
________________________________________________________________________

 (C)		dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2002

 RCS:		$Id: keystrs.h 32429 2013-11-14 15:49:00Z bert.bril@dgbes.com $
________________________________________________________________________

-*/
 
 
#include "gendefs.h"
#include "fixedstring.h"

/*!
\brief is used for defining key strings that are 'global'.

The idea is also that we get some uniformity in how we read/write things
from/to file. Thus, if you suspect a string is rather common, try to find
something similar here first.

Also, some standard key strings are shared between otherwise unrelated modules.
To make sure no artificial dependencies are created, such a key can be added
to this namespace.

*/

namespace sKey
{

    inline FixedString All()		{ return "All"; }
    inline FixedString Ascii()		{ return "Ascii"; }
    inline FixedString Attribute()	{ return "Attribute"; }
    inline FixedString Attributes()	{ return "Attributes"; }
    inline FixedString Azimuth()	{ return "Azimuth"; }
    inline FixedString Binary()		{ return "Binary"; }
    inline FixedString Body()		{ return "Body"; }
    inline FixedString Color()		{ return "Color"; }
    inline FixedString Component()	{ return "Component"; }
    inline FixedString Content()	{ return "Content"; }
    inline FixedString Crossline()	{ return "Cross-line"; }
    inline FixedString Cube()		{ return "Cube"; }
    inline FixedString DataRoot()	{ return "Data Root"; }
    inline FixedString DataStorage()	{ return "Data storage"; }
    inline FixedString DataType()	{ return "DataType"; }
    inline FixedString Date()		{ return "Date"; }
    inline FixedString DateTime()	{ return "Date/Time"; }
    inline FixedString Default()	{ return "Default"; }
    inline FixedString Depth()		{ return "Depth"; }
    inline FixedString Desc()		{ return "Description"; }
    inline FixedString EmptyString()	{ return ""; }
    inline FixedString Factor()		{ return "Factor"; }
    inline FixedString Fault()		{ return "Fault"; }
    inline FixedString FileName()	{ return "File name"; }
    inline FixedString Filter()		{ return "Filter"; }
    inline FixedString FloatUdf()	{ return "1e30"; }
    inline FixedString Geometry()	{ return "Geometry"; }
    inline FixedString GeomID()		{ return "GeomID"; }
    inline FixedString Horizon()	{ return "Horizon"; }
    inline FixedString ID()		{ return "ID"; }
    inline FixedString IOSelection()	{ return "I/O Selection"; }
    inline FixedString Inline()		{ return "In-line"; }
    inline FixedString Keys()		{ return "Keys"; }
    inline FixedString Level()		{ return "Level"; }
    inline FixedString Line()		{ return "Line"; }
    inline FixedString LineKey()	{ return "Line key"; }
    inline FixedString LineName()	{ return "Line name"; }
    inline FixedString LineNames()	{ return "Line names"; }
    inline FixedString Log()		{ return "Log"; }
    inline FixedString LogFile()	{ return "Log file"; }
    inline FixedString Name()		{ return "Name"; }
    inline FixedString NewLine()	{ return "\n"; }
    inline FixedString No()		{ return "No"; }
    inline FixedString None()		{ return "None"; }
    inline FixedString Offset()		{ return "Offset"; }
    inline FixedString Output()		{ return "Output"; }
    inline FixedString Pars()		{ return "Parameters"; }
    inline FixedString Polygon()	{ return "Polygon"; }
    inline FixedString Position()	{ return "Position"; }
    inline FixedString Property()	{ return "Property"; }
    inline FixedString Quiet()		{ return "quiet"; }
    inline FixedString Random()		{ return "Random"; }
    inline FixedString Range()		{ return "Range"; }
    inline FixedString Sampling()	{ return "Sampling"; }
    inline FixedString Scale()		{ return "Scale"; }
    inline FixedString Selection()	{ return "Selection"; }
    inline FixedString Subsample()	{ return "Subsample"; }
    inline FixedString Shortcuts()	{ return "Shortcuts"; }
    inline FixedString Size()		{ return "Size"; }
    inline FixedString SpaceString()	{ return " "; }
    inline FixedString Steering()	{ return "Steering"; }
    inline FixedString Stored()		{ return "Stored"; }
    inline FixedString StratRef()	{ return "Strat Level"; }
    inline FixedString Subsel()		{ return "Subsel"; }
    inline FixedString Surface()	{ return "Surface"; }
    inline FixedString Survey()		{ return "Survey"; }
    inline FixedString Table()		{ return "Table"; }
    inline FixedString Target()		{ return "Target"; }
    inline FixedString Time()		{ return "Time"; }
    inline FixedString Title()		{ return "Title"; }
    inline FixedString TmpStor()	{ return "Temporary storage location"; }
    inline FixedString TraceNr()	{ return "Trace number"; }
    inline FixedString Type()		{ return "Type"; }
    inline FixedString TwoD()		{ return "2D"; }
    inline FixedString Thickness()	{ return "Thickness"; }
    inline FixedString ThreeD()		{ return "3D"; }
    inline FixedString Undef()		{ return "Undefined"; }
    inline FixedString Unit()		{ return "Unit"; }
    inline FixedString User()		{ return "User"; }
    inline FixedString Value()		{ return "Value"; }
    inline FixedString Version()	{ return "Version"; }
    inline FixedString Well()		{ return "Well"; }
    inline FixedString XCoord()		{ return "X-Coord"; }
    inline FixedString YCoord()		{ return "Y-Coord"; }
    inline FixedString Yes()		{ return "Yes"; }
    inline FixedString ZRange()		{ return "Z range"; }

    // Stats
    inline FixedString Average()	{ return "Average"; }
    inline FixedString Maximum()	{ return "Maximum"; }
    inline FixedString Median()		{ return "Median"; }
    inline FixedString Minimum()	{ return "Minimum"; }
    inline FixedString StdDev()		{ return "StdDev"; }
    inline FixedString Sum()		{ return "Sum"; }
    inline FixedString Variance()	{ return "Variance"; }

    // (Horizontal) position selection in the survey
    inline FixedString InlRange()	{ return "In-line range"; }
    inline FixedString FirstInl()	{ return "First In-line"; }
    inline FixedString LastInl()	{ return "Last In-line"; }
    inline FixedString StepInl()	{ return "Step In-line"; }
    inline FixedString StepOutInl()	{ return "Stepout In-line"; }
    inline FixedString CrlRange()	{ return "Cross-line range"; }
    inline FixedString FirstCrl()	{ return "First Cross-line"; }
    inline FixedString LastCrl()	{ return "Last Cross-line"; }
    inline FixedString StepCrl()	{ return "Step Cross-line"; }
    inline FixedString StepOutCrl()	{ return "Stepout Cross-line"; }
    inline FixedString FirstTrc()	{ return "First Trace"; }
    inline FixedString LastTrc()	{ return "Last Trace"; }
    inline FixedString TrcRange()	{ return "Trace Range"; }

    // History of objects
    inline FixedString CrBy()		{ return "Created.By"; }
    inline FixedString CrAt()		{ return "Created.At"; }
    inline FixedString CrFrom()		{ return "Created.From"; }
    inline FixedString CrInfo()		{ return "Created.Info"; }

};


// Makes compat with 4.4 easier
#define mGetKeyStr(id)	sKey::id()


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef latlong_h
#define latlong_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		2008
 Contents:	Geographics lat/long <-> Coord transform (an estimate)
 RCS:		$Id: latlong.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/
 
#include "basicmod.h"
#include "position.h"


/*!
\brief Geographical coordinates, decimal but with conv to deg, min, sec.
*/

mExpClass(Basic) LatLong
{
public:
    			LatLong( double la=0, double lo=0 )
			    : lat_(la), lng_(lo)  {}
    			LatLong( const Coord& c ) { *this = transform(c);}
			operator Coord() const	  { return transform(*this); }

    static Coord	transform(const LatLong&); //!< Uses SI()
    static LatLong	transform(const Coord&);   //!< Uses SI()

    void		fill(char*) const;
    bool		use(const char*);

    void		getDMS(bool lat,int&,int&,float&) const;
    void		setDMS(bool lat,int,int,float);

    double		lat_;
    double		lng_;

};


/*!
\brief Estimates to/from LatLong coordinates.

  Needs both survey coordinates and lat/long for an anchor point in the survey.
*/

mExpClass(Basic) LatLong2Coord
{
public:

			LatLong2Coord();
			LatLong2Coord(const Coord&,const LatLong&);
    bool		isOK() const	{ return !mIsUdf(lngdist_); }

    void		set(const LatLong&,const Coord&);

    LatLong		transform(const Coord&) const;
    Coord		transform(const LatLong&) const;

    void		fill(char*) const;
    bool		use(const char*);

    Coord		refCoord() const	{ return refcoord_; }
    LatLong		refLatLong() const	{ return reflatlng_; }

protected:

    Coord		refcoord_;
    LatLong		reflatlng_;

    double		latdist_;
    double		lngdist_;
    double		scalefac_;
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef mallocdefs_h
#define mallocdefs_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2006
 RCS:		$Id: mallocdefs.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#ifdef __mac__
#include <malloc/malloc.h>
#else
#include <malloc.h>
#endif
#include <stdlib.h>

#define mMALLOC(sz,tp)		(tp*)malloc((sz)*sizeof(tp))
#define mREALLOC(var,sz,tp)	(tp*)realloc(var,(sz)*sizeof(tp))
#define mFREE(ptr)		{ if (ptr) free(ptr); ptr = 0; }


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef manobjectset_h
#define manobjectset_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Feb 2009
 RCS:		$Id: manobjectset.h 29029 2013-03-28 16:06:55Z bert.bril@dgbes.com $
________________________________________________________________________

-*/

#include "objectset.h"


/*!
\brief ObjectSet where the objects contained are owned by this set.
*/

template <class T>
mClass(Basic) ManagedObjectSet : public ObjectSet<T>
{
public:

    inline			ManagedObjectSet()	{}
    inline			ManagedObjectSet(const ManagedObjectSet<T>&);
    inline virtual		~ManagedObjectSet();
    inline ManagedObjectSet<T>&	operator =(const ObjectSet<T>&);
    inline ManagedObjectSet<T>&	operator =(const ManagedObjectSet<T>&);
    virtual bool		isManaged() const	{ return true; }

    inline virtual ManagedObjectSet<T>& operator -=( T* ptr );

    inline virtual void		erase()			{ deepErase( *this ); }
    inline virtual void		append(const ObjectSet<T>&);
    inline virtual void		removeRange(od_int64,od_int64);
    inline virtual T*		removeSingle( int idx, bool kporder=true );
				/*!<Deletes entry and returns 0 */
    inline virtual T*		removeAndTake(int idx, bool kporder=true );
				/*!<Does not delete the entry. */

    inline void			setEmpty()		{ erase(); }

};


//ObjectSet implementation

template <class T> inline
ManagedObjectSet<T>::ManagedObjectSet( const ManagedObjectSet<T>& t )
{ *this = t; }


template <class T> inline
ManagedObjectSet<T>::~ManagedObjectSet()
{ erase(); }


template <class T> inline
ManagedObjectSet<T>& ManagedObjectSet<T>::operator =( const ObjectSet<T>& os )
{
    if ( &os != this )
	{ erase(); append( os ); }
    return *this;
}

template <class T> inline
ManagedObjectSet<T>& ManagedObjectSet<T>::operator =(
					const ManagedObjectSet<T>& os )
{
    if ( &os != this ) deepCopy( *this, os );
    return *this;
}


template <class T> inline
ManagedObjectSet<T>& ManagedObjectSet<T>::operator -=( T* ptr )
{
    if ( ptr )
	{ this->vec_.erase( (void*)ptr ); delete ptr; }
    return *this;
}


template <class T> inline
void ManagedObjectSet<T>::append( const ObjectSet<T>& os )
{
    const int sz = os.size();
    this->vec_.setCapacity( this->size()+sz );
    if ( !os.isManaged() )
	ObjectSet<T>::append( os );
    else
	for ( int idx=0; idx<sz; idx++ )
	    *this += new T( *os[idx] );
}


template <class T> inline
T* ManagedObjectSet<T>::removeSingle( int idx, bool kporder )
{
    delete (*this)[idx];
    ObjectSet<T>::removeSingle( idx, kporder );
    return 0; //Don't give anyone a chance to play with the deleted object
}


template <class T> inline
void ManagedObjectSet<T>::removeRange( od_int64 i1, od_int64 i2 )
{
    for ( int idx=(int)i1; idx<=i2; idx++ )
	delete (*this)[idx];
    ObjectSet<T>::removeRange( i1, i2 );
}

template <class T> inline
T* ManagedObjectSet<T>::removeAndTake(int idx, bool kporder )
{
    return ObjectSet<T>::removeSingle( idx, kporder );
}


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef math2_h
#define math2_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		Aug 2005
 RCS:		$Id: math2.h 29298 2013-04-17 06:51:52Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "gendefs.h"
#include <complex>

/* Functions with some extra facilities added to math.h

   Each function has a float and a double version. This may be very
   old-fashioned, but who cares.

   At the end, there is also an all-integer x to the power y.

 */

typedef std::complex<float> float_complex;

namespace Math
{
    
mGlobal(Basic) unsigned int SetFlags( unsigned int curflags,
                              unsigned int flag, bool yn );
    		/*!<Takes curflags, sets/clears the bits in flag, and returns
                    the composite value.*/
mGlobal(Basic) bool IsNormalNumber(float);
		/* Returns 0 for for infinite, NaN, and that sort of crap */
mGlobal(Basic) float IntPowerOf(float,int);
mGlobal(Basic) float PowerOf(float,float);
		/*!< PowerOf(-2,2) returns -4. This may be mathematically
		  incorrect, it delivers continuity with negative numbers */
mGlobal(Basic) float ASin(float);
		/*!<Checks the input range before calling asin, and does thus
		    avoid nan's due to roundoff errors. */
mGlobal(Basic) float ACos(float);
		/*!<Checks the input range before calling acos, and does thus
		    avoid nan's due to roundoff errors. */
mGlobal(Basic) float Log(float);
                /*!<Checks the input range before calling log, returns
		    undefined if negative or zero value is given. */
mGlobal(Basic) float Log10(float);
                /*!<Checks the input range before calling log10, returns
		    mUdf(float) if negative or zero value is given. */
mGlobal(Basic) float Sqrt(float);
                /*!<Checks the input range before calling sqrt, if negative
		    value is given, zero is returned. */
mGlobal(Basic) float_complex Sqrt(const float_complex&);
mGlobal(Basic) float Exp(float);
                /*!<Checks the input range before calling exp, if too large
		    value is given, mUdf(float) is returned. */
mGlobal(Basic) float toDB(float);

inline float	degFromNorth( float azimuth )
		{
		    const float deg = 90 - 57.2957795131f * azimuth;
		    return deg < 0 ? deg + 360 : deg;
		}

mGlobal(Basic) int LCMOf(int,int); /*! <Lowest Common Multiple. */
mGlobal(Basic) int HCFOf(int,int); /*! <Highest Common Factor. */
mGlobal(Basic) bool IsNormalNumber(double);
mGlobal(Basic) double IntPowerOf(double,int);
mGlobal(Basic) double PowerOf(double,double);
mGlobal(Basic) double ASin(double);
mGlobal(Basic) double ACos(double);
mGlobal(Basic) double Log(double);
mGlobal(Basic) double Log10(double);
mGlobal(Basic) double Exp(double);
mGlobal(Basic) double Sqrt(double);
mGlobal(Basic) double toDB(double);
mGlobal(Basic) double toDegrees(double);
mGlobal(Basic) double toRadians(double);
mGlobal(Basic) float toDegrees(float);
mGlobal(Basic) float toRadians(float);

mGlobal(Basic) int IntPowerOf(int,int);
mGlobal(Basic) od_int64 IntPowerOf(od_int64,int);

} // namespace Math


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

/*+
 * (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 * AUTHOR   : A.H. Bril
 * DATE     : Jan 2008
 * SVN      : $Id: math2_inc.h 30292 2013-06-12 07:08:46Z kristofer.tingdahl@dgbes.com $
-*/


bool Math::IsNormalNumber( mTYPE x )
{
    return finite( x );
}


mTYPE Math::IntPowerOf( mTYPE x, int y )
{
    if ( mIsUdf(x) )
	return mUdf(mTYPE);

    if ( x == 0 )
	return y ? (mTYPE)0 : (mTYPE)1;

    if ( x > 1.5 || x < -1.5 )
    {
	if ( y > 150 ) return mUdf(mTYPE);
	if ( y < -150 ) return (mTYPE) 0;
	if ( x > 1.99 || x < -1.99 )
	{
	    if ( y > 100 ) return mUdf(mTYPE);
	    if ( y < -100 ) return (mTYPE) 0;
	}
    }
    else if ( x < 0.5 && x > -0.5 )
    {
	if ( y > 100 ) return (mTYPE) 0;
	if ( y < -100 ) return (mTYPE) 1;
    }

    mTYPE ret = 1;
    while ( y )
    {
	if ( y > 0 )
	    { ret *= x; y--; }
	else
	    { ret /= x; y++; }
    }
    return ret;
}
 

mTYPE Math::PowerOf( mTYPE x, mTYPE y )
{
    if ( x == 0 ) return (mTYPE) (y ? 0 : 1);

    const bool isneg = x < 0 ? 1 : 0;
    if ( isneg ) x = -x;
 
    mTYPE ret = exp( y * log(x) );
    return isneg ? -ret : ret;
}


mTYPE Math::ACos( mTYPE c )
{
    return (mTYPE) c >= 1 ? 0 : (c <= -1 ? mTYPE(M_PI) : acos( c ));
}


mTYPE Math::ASin( mTYPE s )
{
    return (mTYPE) s >= 1 ? mTYPE(M_PI_2) : (s <= -1 ? -mTYPE(M_PI_2) : asin( s ));
}


mTYPE Math::Log( mTYPE s )
{
    return (mTYPE) s <= 0 ? mUdf(mTYPE) : log( s );
}


mTYPE Math::Log10( mTYPE s )
{
    return (mTYPE) s <= 0 ? mUdf(mTYPE) : log10( s );
}


mTYPE Math::Sqrt( mTYPE s )
{
    //A bit silly bu the space before the parantesis
    //makes it avoid the sqrt test.
    return (mTYPE) s <= 0 ? 0 : sqrt ( s );
}

mTYPE Math::toDB( mTYPE s )
{
    return (mTYPE) s <= 0 ? mUdf(mTYPE) : 20*log10( s );
}

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef moddepmgr_h
#define moddepmgr_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Aug 2011
 RCS:		$Id: moddepmgr.h 29359 2013-04-19 13:09:40Z mahant.mothey@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstringset.h"

class SharedLibAccess;

/*!\brief OpendTect*/

namespace OD
{

/*!
\brief Module Dependency
*/

mExpClass(Basic) ModDep
{
public:
    			ModDep( const char* m )
			    : name_(m)	{}
    bool		operator ==( const char* s ) const
			    { return name_ == s; }

    BufferString	name_;
    BufferStringSet	mods_;

};


/*!
\brief Dependency manager - provides tools for the dependencies between the
different OpendTect 'modules'.
*/

mExpClass(Basic) ModDepMgr
{
public:
				ModDepMgr(const char* fnm=0);

    const ModDep*		find(const char*) const;
    const ObjectSet<ModDep>&	deps() const	{ return deps_; }

    void			ensureLoaded(const char*) const;
    const SharedLibAccess*	shLibAccess(const char*) const;

protected:

    ObjectSet<ModDep>	deps_;

    mutable BufferStringSet		loadedmods_;
    mutable ObjectSet<SharedLibAccess>	shlibaccs_;

    void		readDeps(std::istream&);
    int			getLoadIdx(const char*) const;

};

mGlobal(Basic) const ModDepMgr& ModDeps();

#define mDefModInitFn(nm) \
mExternC(nm) void od_##nm##_initStdClasses(); \
extern "C" void od_##nm##_initStdClasses()


} // namespace OD

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef msgh_h
#define msgh_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		19-10-1995
 Contents:	Error handler
 RCS:		$Id: msgh.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "callback.h"


/*!
\brief Class to encapsulate a message to the user.

  Along with the message there's also a type. In any case, there's a handler
  for when UsrMsg is called: theCB. If it is not set, messages go to cerr.
*/

mExpClass(Basic) MsgClass : public CallBacker
{
public:

    enum Type		{ Info, Message, Warning, Error, ProgrammerError };

			MsgClass( const char* s, Type t=Info )
			: msg(s), type_(t)		{}

    const char*		msg;
    Type		type_;

    static CallBack&	theCB( const CallBack* cb=0 );
    			//!< pass non-null to set the CB
    static const char*	nameOf(Type);

};


mGlobal(Basic)  void UsrMsg(const char*,MsgClass::Type t=MsgClass::Info);
//!< Will pass the message to the appropriate destination.



#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef msvcdefs_h
#define msvcdefs_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2006
 RCS:		$Id: msvcdefs.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

 For use with Microsoft Visual C++ 8.0 and 9.0

-*/

#include <stdlib.h>

#define NOMINMAX	// Otherwise Windows will define min/max

#if defined(_MSC_VER) && _MSC_VER == 1500 // && _MSC_FULL_VER >= 150030729
# define Interval StructuredQueryInterval
#  include <structuredquery.h>
# undef Interval
#endif

#ifdef _DEBUG
# define __debug__
#endif

#define snprintf	_snprintf
#define isnan		_isnan

#define strncasecmp	strnicmp
#define strcasecmp	stricmp

#define strtoll		_strtoi64
#define strtoull	_strtoui64
#define strtof		strtod

#define finite		_finite
#define atoll		_atoi64

# define mMaxFilePathLength		_MAX_PATH

# define mPolyRet(base,clss)		base
# define mTFriend(T,clss)
# define mTTFriend(T,C,clss)
# define mProtected			public
# define mPolyRetDownCast(clss,var)	dynamic_cast<clss>(var)
# define mPolyRetDownCastRef(clss,var)	*(dynamic_cast<clss*>(&var))
# define mDynamicCast(typ,out,in) \
	 out = dynamic_cast< typ >( in );
# define mDynamicCastGet(typ,out,in) \
	 typ mDynamicCast(typ,out,in)


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef multiid_h
#define multiid_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		15-1-2000
 RCS:		$Id: multiid.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "compoundkey.h"
#include "string2.h"
#include "fixedstring.h"


/*!
\brief Compound key consisting of ints.
*/

mExpClass(Basic) MultiID : public CompoundKey
{
public:
			MultiID(const FixedString& s)
			: CompoundKey(s)	{}
			MultiID( const char* s=0 )
			: CompoundKey(s)	{}
			MultiID( const MultiID& mid )
			: CompoundKey(mid)	{}
			MultiID( int i )
			{ add(i); }
			MultiID( int i1, int i2 )
			{ add(i1); add(i2); }
			MultiID( int i1, int i2, int i3 )
			{ add(i1); add(i2); add(i3); }

    MultiID&		operator =( const MultiID& mi )
			{ id_ = mi.id_; return *this; }
    MultiID&		operator =( const CompoundKey& ck )
			{ id_ = (const char*)ck; return *this; }
    MultiID&		operator =( const FixedString& fs )
			{ id_ = fs.str(); return *this; }
    MultiID&		operator =( const char* s )
			{ id_ = s; return *this; }

    inline bool		operator==( const MultiID& m ) const
			{ return id_ == m.id_; }
    inline bool		operator==( const char* s ) const
			{ return id_ == s; }

    inline int		ID( int idx ) const
			{ return toInt(key(idx).buf()); }
    inline void		setID( int idx, int i )
			{ setKey( idx, toString(i) ); }
    int			leafID() const;

    inline MultiID&	add( int i )
			{ *this += toString(i);return *this;}

    static const MultiID& udf();
    inline bool		isUdf() const	{ return *this==udf(); }

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef namedobj_h
#define namedobj_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Sep 1994, Aug 2006
 RCS:		$Id: namedobj.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "callback.h"
#include "bufstring.h"


/*!
\brief Object with a name.

  The NamedObject has a name and it can notify another NamedObject when it is
  about to be deleted. The name may either be a string of the object itself,
  or the name of another object, linked directly. This not only saves memory,
  but allows for names that are fundamentally linked.
*/

mExpClass(Basic) NamedObject : public CallBacker
{
public:
			NamedObject(const char* nm=0)
			: linkedto_(0), delnotify_(0)
			{ name_ = new BufferString(nm); }
			NamedObject( const NamedObject* l )
			: name_(0), linkedto_((NamedObject*)l), delnotify_(0)
			{}
			NamedObject( const NamedObject& o )
			: CallBacker( o )
			, linkedto_(o.linkedto_), delnotify_(0)
			{ if ( o.name_ ) name_ = new BufferString(*o.name_); }
    virtual		~NamedObject()	;
    void		setLinked( NamedObject* l )
			{
			    if ( l )	{ delete name_; name_ = 0; }
			    else if ( !name_ ) name_ = new BufferString;
			    linkedto_ = l;
			}

    virtual const BufferString&	name() const
			{ return name_ ? *name_ : linkedto_->name(); }
    virtual void	setName(const char*);
    void		setCleanName(const char*);
    bool		operator ==( const NamedObject& no ) const
			{ return name() == no.name(); }

    void		deleteNotify(const CallBack&);

protected:

    BufferString*	name_;
    NamedObject*	linkedto_;
    CallBackSet*	delnotify_;

private:

    void		cbRem(NamedObject*);

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef objectset_h
#define objectset_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert / many others
 Date:		Apr 1995 / Feb 2009
 RCS:		$Id: objectset.h 30596 2013-07-08 09:16:56Z bert.bril@dgbes.com $
________________________________________________________________________

-*/

#ifndef odset_h
#include "odset.h"
#endif
#ifndef vectoraccess_h
#include "vectoraccess.h"
#endif

#ifdef __debug__
# include "debug.h"
#endif


/*!
\brief Set of pointers to objects.

  The ObjectSet does not manage the objects, it is just a collection of
  pointers to the objects. If you want management, use ManagedObjectSet.
*/

template <class T>
mClass(Basic) ObjectSet : public OD::Set
{
public:

    typedef int			size_type;
    typedef T			object_type;

    inline 			ObjectSet();
    inline			ObjectSet(const ObjectSet<T>&);
    inline virtual		~ObjectSet()		{}
    inline ObjectSet<T>&	operator =(const ObjectSet<T>&);
    virtual bool		isManaged() const	{ return false; }

    inline bool			nullAllowed() const	{ return allow0_; }
    inline void			allowNull(bool yn=true);
    inline size_type		size() const		{ return vec_.size(); }
    inline virtual od_int64	nrItems() const		{ return size(); }

    inline virtual bool		validIdx(od_int64) const;
    inline virtual bool		isPresent(const T*) const;
    inline virtual size_type	indexOf(const T*) const;
    inline virtual T*		operator[](size_type);
    inline virtual const T*	operator[](size_type) const;
    inline virtual T*		operator[](const T*) const; //!< check & unconst

    inline virtual T*		replace(size_type idx,T*);
    inline virtual void		insertAt(T* newptr,size_type);
    inline virtual void		insertAfter(T* newptr,size_type);
    inline virtual void		copy(const ObjectSet<T>&);
    inline virtual void		append(const ObjectSet<T>&);
    inline virtual void		swap(od_int64,od_int64);
    inline virtual void		reverse(); 

    inline virtual ObjectSet<T>& operator +=(T*);
    inline virtual ObjectSet<T>& operator -=(T*);
    inline virtual void		push(T* ptr);
    inline virtual T*		pop();
    
    inline bool			addIfNew(T*);

    inline virtual void		erase()		{ plainErase(); }
    				
    virtual inline T*		removeSingle(size_type,bool keep_order=true);
    				/*!<\returns the removed pointer. */
    virtual void		removeRange(od_int64 from,od_int64 to);

    inline T*			first();
    inline const T*		first() const;
    inline T*			last();
    inline const T*		last() const;


protected:

    VectorAccess<void*,size_type> vec_;
    bool			allow0_;

public:

    inline void			plainErase()	{ vec_.erase(); }
				/*!< Not virtual. Don't use casually. */
};


#define mObjectSetApplyToAll( os, op ) \
    for ( ObjectSet<int>::size_type idx=os.size()-1; idx>=0; idx-- ) \
	op

#define mObjectSetApplyToAllFunc( fn, op, extra ) \
template <class T> \
inline void fn( ObjectSet<T>& os ) \
{ \
    mObjectSetApplyToAll( os, op ); \
    extra; \
}


//! empty the ObjectSet deleting all objects pointed to.
mObjectSetApplyToAllFunc( deepErase, delete os.removeSingle(idx),  )


//! empty the ObjectSet deleting all objects pointed to.
mObjectSetApplyToAllFunc( deepEraseArr, delete [] os.removeSingle(idx), )


//! append copies of one set's objects to another ObjectSet.
template <class T,class S>
inline void deepAppend( ObjectSet<T>& to, const ObjectSet<S>& from )
{
    const int sz = from.size();
    for ( int idx=0; idx<sz; idx++ )
	to += from[idx] ? new T( *from[idx] ) : 0;
}


//! append clones of one set's objects to another ObjectSet.
template <class T,class S>
inline void deepAppendClone( ObjectSet<T>& to, const ObjectSet<S>& from )
{
    const int sz = from.size();
    for ( int idx=0; idx<sz; idx++ )
	to += from[idx] ? from[idx]->clone() : 0;
}


//! fill an ObjectSet with copies of the objects in the other set.
template <class T,class S>
inline void deepCopy( ObjectSet<T>& to, const ObjectSet<S>& from )
{
    if ( &to == &from ) return;
    deepErase( to );
    to.allowNull( from.nullAllowed() );
    deepAppend( to, from );
}


//! fill an ObjectSet with clones of the objects in the other set.
template <class T,class S>
inline void deepCopyClone( ObjectSet<T>& to, const ObjectSet<S>& from )
{
    if ( &to == &from ) return;
    deepErase( to );
    to.allowNull( from.nullAllowed() );
    deepAppendClone( to, from );
}


//! Locate object in set
template <class T,class S>
inline typename ObjectSet<T>::size_type indexOf( const ObjectSet<T>& os,
						 const S& val )
{
    for ( int idx=0; idx<os.size(); idx++ )
    {
	if ( *os[idx] == val )
	    return idx;
    }
    return -1;
}


//! Get const object in set
template <class T,class S>
inline const T* find( const ObjectSet<T>& os, const S& val )
{
    const typename ObjectSet<T>::size_type idx = indexOf( os, val );
    return idx == -1 ? 0 : os[idx];
}


//! Get object in set
template <class T,class S>
inline T* find( ObjectSet<T>& os, const S& val )
{
    const typename ObjectSet<T>::size_type idx = indexOf( os, val );
    return idx == -1 ? 0 : os[idx];
}

//! Sort ObjectSet when nulls are allowed no need to call.
template <class T>
inline void _ObjectSet_sortWithNull( ObjectSet<T>& os )
{
    const typename ObjectSet<T>::size_type sz = os.size();
    for ( typename ObjectSet<T>::size_type d=sz/2; d>0; d=d/2 )
    {
	for ( typename ObjectSet<T>::size_type i=d; i<sz; i++ )
	{
	    for ( typename ObjectSet<T>::size_type j=i-d; j>=0; j-=d )
	    {
		T* o1 = os[j]; T* o2 = os[j+d];
		if ( !o2 || o1 == o2 || (o1 && !(*o1 > *o2) ) )
		    break;
		os.swap( j, j+d );
	    }
	}
    }
}

//! Sort ObjectSet. Must have operator > defined for elements
template <class T>
inline void sort( ObjectSet<T>& os )
{
    if ( os.nullAllowed() )
	_ObjectSet_sortWithNull(os);
    else
    {
	const typename ObjectSet<T>::size_type sz = os.size();
	for ( typename ObjectSet<T>::size_type d=sz/2; d>0; d=d/2 )
	{
	    for ( typename ObjectSet<T>::size_type i=d; i<sz; i++ )
	    {
		for ( typename ObjectSet<T>::size_type j=i-d;
		     j>=0 && *os[j]>*os[j+d]; j-=d )
		{
		    os.swap( j, j+d );
		}
	    }
	}
    }
}

//! See if all objects pointed to are equal
template <class T>
inline bool equalContents( const ObjectSet<T>& os1, const ObjectSet<T>& os2 )
{
    typedef typename ObjectSet<T>::size_type size_type;
    const size_type sz = os1.size();
    if ( os2.size() != sz )
	return false;

    for ( size_type idx=0; idx<sz; idx++ )
    {
	const T* o1 = os1[idx]; const T* o2 = os2[idx];
	if ( !o1 && !o2 )
	    continue;
	if ( !o1 || !o2 || (!(*o1 == *o2)) )
	    return false;
    }
    return true;
}


// Member function implementations
template <class T> inline
ObjectSet<T>::ObjectSet() : allow0_(false)
{}


template <class T> inline
ObjectSet<T>::ObjectSet( const ObjectSet<T>& t )
{ *this = t; }


template <class T> inline
ObjectSet<T>& ObjectSet<T>::operator =( const ObjectSet<T>& os )
{ allow0_ = os.allow0_; copy(os); return *this; }


template <class T> inline
void ObjectSet<T>::allowNull( bool yn )
{ allow0_ = yn; }


template <class T> inline
bool ObjectSet<T>::validIdx( od_int64 idx ) const
{ return idx>=0 && idx<size(); }


template <class T> inline
T* ObjectSet<T>::operator[]( size_type idx )
{
#ifdef __debug__
    if ( !validIdx(idx) )
	DBG::forceCrash(true);
#endif
    return (T*)vec_[idx];
}


template <class T> inline
const T* ObjectSet<T>::operator[]( size_type idx ) const
{
#ifdef __debug__
    if ( !validIdx(idx) )
	DBG::forceCrash(true);
#endif
    return (const T*)vec_[idx];
}


template <class T> inline
T* ObjectSet<T>::operator[]( const T* t ) const
{
    const size_type idx = indexOf(t);
    return idx < 0 ? 0 : const_cast<T*>(t);
}


template <class T> inline
typename ObjectSet<T>::size_type ObjectSet<T>::indexOf( const T* ptr ) const
{
    return vec_.indexOf( (void*) ptr, true );
}


template <class T> inline
bool ObjectSet<T>::isPresent( const T* ptr ) const
{
    return vec_.isPresent( (void*) ptr );
}


template <class T> inline
ObjectSet<T>& ObjectSet<T>::operator +=( T* ptr )
{
    if ( ptr || allow0_ )
	vec_.push_back( (void*)ptr );
    return *this;
}


template <class T> inline
ObjectSet<T>& ObjectSet<T>::operator -=( T* ptr )
{
    if ( ptr || allow0_ )
	vec_.erase( (void*)ptr );
    return *this;
}


template <class T> inline
void ObjectSet<T>::swap( od_int64 idx0, od_int64 idx1 )
{
#ifdef __debug__
    if ( !validIdx(idx0) || !validIdx(idx1) )
	DBG::forceCrash(true);
#endif
    vec_.swap( mCast(size_type,idx0), mCast(size_type,idx1) );
}


template <class T> inline
void ObjectSet<T>::reverse()
{
    const size_type sz = size();
    const size_type hsz = sz/2;
    for ( size_type idx=0; idx<hsz; idx++ )
	swap( idx, sz-1-idx );
}


template <class T> inline
T* ObjectSet<T>::replace( size_type idx, T* newptr )
{
    if ( !validIdx(idx) )
#ifdef __debug__
	DBG::forceCrash(true);
#else
	return 0;
#endif
    T* ptr = (T*)vec_[idx];
    vec_[idx] = (void*)newptr;
    return ptr;
}


template <class T> inline
void ObjectSet<T>::insertAt( T* newptr, size_type idx )
{
    vec_.insert( idx, (void*)newptr );
}


template <class T> inline
void ObjectSet<T>::insertAfter( T* newptr, size_type idx )
{
    *this += newptr;
    if ( idx < 0 )
	vec_.moveToStart( (void*)newptr );
    else
	vec_.moveAfter( (void*)newptr, vec_[idx] );
}


template <class T> inline
void ObjectSet<T>::copy( const ObjectSet<T>& os )
{
    if ( &os != this )
    {
	erase();
	allow0_ = os.allow0_;
	append( os );
    }
}


template <class T> inline
void ObjectSet<T>::append( const ObjectSet<T>& os )
{
    const size_type sz = os.size();
    vec_.setCapacity( size()+sz );
    for ( size_type idx=0; idx<sz; idx++ )
	*this += const_cast<T*>( os[idx] );
}


template <class T> inline
void ObjectSet<T>::push( T* ptr )
{ *this +=ptr; }


template <class T> inline
T* ObjectSet<T>::pop()
{ return (T*)vec_.pop_back(); }


template <class T> inline
bool ObjectSet<T>::addIfNew( T* ptr )
{
    if ( isPresent(ptr) )
	return false;

    *this += ptr;
    return true;
}


template <class T> inline
T* ObjectSet<T>::removeSingle( size_type idx, bool kporder )
{
    T* res = (T*)vec_[idx];
    if ( kporder )
	vec_.remove( idx );
    else
    {
	const size_type lastidx = size()-1;
	if ( idx!=lastidx )
	    vec_[idx] = vec_[lastidx];
	vec_.remove( lastidx );
    }
    return res;
}


template <class T> inline
void ObjectSet<T>::removeRange( od_int64 i1, od_int64 i2 )
{ vec_.remove( (size_type)i1, (size_type)i2 ); }
template <class T> inline T* ObjectSet<T>::first()
{ return isEmpty() ? 0 : (*this)[0]; }
template <class T> inline const T* ObjectSet<T>::first() const
{ return isEmpty() ? 0 : (*this)[0]; }
template <class T> inline T* ObjectSet<T>::last()
{ return isEmpty() ? 0 : (*this)[size()-1]; }
template <class T> inline const T* ObjectSet<T>::last() const
{ return isEmpty() ? 0 : (*this)[size()-1]; }


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odcomplex_h
#define odcomplex_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Nanne Hemstra
 Date:		January 2010
 RCS:		$Id: odcomplex.h 29136 2013-04-08 03:48:14Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include <complex>
#include "undefval.h"

typedef std::complex<float> float_complex;

namespace Values
{

/*!
\brief Undefined float_complex.
*/

template<>
mClass(Basic) Undef<float_complex>
{
public:

    static bool			hasUdf() 		{ return true; }
    static float_complex	val()
				{
				    return float_complex( __mUndefFValue,
					    		  __mUndefFValue);
				}
    static bool			isUdf( float_complex f )
				{
				    const float r = f.real();
				    const float i = f.imag();
				    return __mIsUndefinedF(r)
					|| __mIsUndefinedF(i);
				}
    static void			setUdf( float_complex& f )
				{
				    f = float_complex(__mUndefFValue,
					    	      __mUndefFValue );
				}

};


};//namespace Values

mGlobal(Basic) bool dbgIsUdf(float_complex);

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef oddirs_h
#define oddirs_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		Aug 2005
 RCS:		$Id: oddirs.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

OpendTect directories.

Beware that all functions may return a pointer to *the same* static buffer!

-*/

#ifndef gendefs_h
#include "basicmod.h"
#include "gendefs.h"
#endif

#ifdef __cpp__
extern "C" {
#endif

    /* Functions delivering files/directies in the 'survey data' scope */

mGlobal(Basic) const char* GetBaseDataDir(void);
/*!< Base data directory: DTECT_[WIN]DATA or from User Settings. */

mGlobal(Basic) const char* GetDataDir(void);
/*!< Survey directory: GetBaseDataDir()/<current survey> */

mGlobal(Basic) const char* GetProcFileName(const char*);
/*!< Returns file name in GetDataDir()/Proc. Pass null for directory. */


    /* Functions delivering files/directies in the 'sytem' scope */

mGlobal(Basic) const char* GetSoftwareDir(int acceptnone);
/*!< Directory of the installed software = $DTECT_[WIN]APPL 

 GetSoftwareDir returns the full path of the root of the release.
 If no DTECT_[WIN]APPL set, the location will be determined from argv[0] or
 the 'bundle' location (Mac only).

 If acceptnone is false, program will terminate if none is found.
*/
    
mGlobal(Basic) const char* GetBinSubDir(void);
/*!< Directory for the release-type, i.e. Debug, Release, ... */

mGlobal(Basic) const char* GetApplSetupDir(void);
/*!< Directory with setup files and scripts overruling current software
     release's default setup files.
    
    Tied to environment DTECT_[WIN]APPL_SETUP. If
    the environment is not set (see GetEnvVar), this function returns null.
*/

typedef enum
{
    ODSetupLoc_ApplSetupOnly,
    ODSetupLoc_ApplSetupPref, /* Usual choice for GetSetupDataFileName */
    ODSetupLoc_SWDirPref,
    ODSetupLoc_SWDirOnly
} ODSetupLocType;

mGlobal(Basic) const char* GetSetupDataFileDir(ODSetupLocType,int acceptnone);
/*!< Returns the name of the "data" subdir of the release or the
     site setup directory.
     If acceptnone is false, program will terminate if none is found.
*/
#define mGetApplSetupDataDir() GetSetupDataFileDir(ODSetupLoc_ApplSetupOnly,0)
#define mGetSWDirDataDir() GetSetupDataFileDir(ODSetupLoc_SWDirOnly,0)

mGlobal(Basic) const char* GetSetupDataFileName(ODSetupLocType,const char*,
					 int acceptnone);
/*!< Returns the name of a file in the "data" subdir of the release or the
     appl setup directory.

     For the 'Pref' types, it returns the first existing
     file.

     If acceptnone is false, program will terminate if none is found.
*/
#define mGetSetupFileName(x) GetSetupDataFileName(ODSetupLoc_ApplSetupPref,x,0)
/*!< Usual choice: first look in ApplSetup, if not there, look in release */

mGlobal(Basic) const char* GetPlfSubDir(void);
/*!< Platform subdirectory for platforms

  Tries PLFSUBDIR, if not set: binsubdir, if not set: HDIR
  Ouput medio 2009 is one of lux32, lux64, sol32, mac, win32 or win64.
*/

mGlobal(Basic) const char* GetBinPlfDir(void);
/*!< Platform dependent bin directory
  Returns full path to bin dir:
  GetSoftwareDir()/bin/GetPlfSubDir()/GetBinSubDir()
*/

mGlobal(Basic) const char* GetDocFileDir(const char* filedir);
/*!< Location of Documentation */
#define mGetUserDocDir()	GetDocFileDir("User")
#define mGetProgrammerDocDir()	GetDocFileDir("Programmer")
#define mGetSysAdmDocDir()	GetDocFileDir("SysAdm")


mGlobal(Basic) const char* GetExecScript(int remote);
/*!< Location of launch script for external programs
  
  In GetSiteDataDir() or GetSoftwareDir(): bin/od_exec[_rmt][.bat]
*/
#define		mGetExecScript()	GetExecScript(0)

mGlobal(Basic) const char* GetSoftwareUser(void);
/*!< Sub-user of software: $DTECT_USER

 When multiple people want to run under a single account, they need to
 set DTECT_USER. The output of GetSoftwareUser() will therefore most often
 be null!
*/

mGlobal(Basic) const char* GetUserNm(void);
/*!< user's name */


    /* Functions delivering files/directies in the 'user-specific' scope */
mGlobal(Basic) const char* GetPersonalDir(void);
/*!< Directory for personal settings: 'Home directory'

 This gets the user's home directory. Even on Windows, something will be
 assigned as being the home directory.

Windows:
    DTECT_WINHOME
    DTECT_HOME	-> converted from unix to windows path (cygpath -w)
    HOMEDRIVE+HOMEPATH if exists and not equal to "C:\"
    That should be it. If that still fails, we try HOME, USERPROFILE, APPDATA,
    DTECT_USERPROFILE_DIR. As a last resort, GetSpecialFolderLocation is used.

UNIX:
    DTECT_HOME, HOME; in that order.

 Before anything else, DTECT_PERSONAL_DIR is checked. If it's set, that is
 returned. If all else fails, "C:\\" or "/tmp" are returned.

*/

mGlobal(Basic) const char* GetSettingsDir(void);
/*!< Directory with the user settings

  Returns GetPersonalDir()/.od, unless DTECT_PERSONAL_DIR is set.

*/

mGlobal(Basic) const char* GetSettingsFileName(const char*);
/*!< Returns GetSettingsDir()/filenm */


mGlobal(Basic) const char* GetScriptsDir(const char*);


#ifdef __cpp__
}
#endif

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odimage_h
#define odimage_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        K. Tingdahl
 Date:          August 2010
 RCS:           $Id: odimage.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "color.h"

namespace OD
{

/*!
\brief Class for Red, Green, Blue image.
*/

mExpClass(Basic) RGBImage
{
public:
    virtual			~RGBImage()			{}

    virtual char		nrComponents() const		= 0;
				/*!<\retval 1 grayscale
				    \retval 2 grayscale+alpha
				    \retval 3 rgb
				    \retval 4 rgb+alpha */
    virtual bool		hasAlpha() const;
    virtual bool		setSize(int,int)		= 0;
    virtual int			getSize(bool xdir) const	= 0;
    virtual Color		get(int,int) const		= 0;
    virtual bool		set(int,int,const Color&)	= 0;

    virtual int			bufferSize() const;
    virtual void		fill(unsigned char*) const;
				/*!Fills array with content. Each
				    pixel's components are the fastest
				    dimension, slowet is xdir. Caller
				    must ensure sufficient mem is
				    allocated. */
    virtual bool		put(const unsigned char*);
    virtual bool		putFromBitmap(const unsigned char*
				    bitmap, const unsigned char* mask = 0);
    
    virtual const unsigned char*	getData() const		{ return 0; }
    virtual unsigned char*		getData() 		{ return 0; }
};

};

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odinst_h
#define odinst_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bert
 Date:          Feb 2012
 RCS:           $Id: odinst.h 30942 2013-07-29 10:55:29Z ranojay.sen@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "enums.h"

class Settings;
class BufferStringSet;

/*!\brief OpendTect Installation*/

namespace ODInst
{

    mGlobal(Basic) BufferString	GetInstallerDir();
    mGlobal(Basic) bool		canInstall();
    mGlobal(Basic) void		startInstManagement();
    mGlobal(Basic) bool		updatesAvailable();
    mGlobal(Basic) bool		runInstMgrForUpdt();
    mGlobal(Basic) const char*		getPkgVersion(const char* file_pkg_basenm);
    				//!< For example, the Base pkg has "base" 
    inline bool			isErrPkgVersion( const char* s )
				{ return !s || !*s || *s == '['; }


    enum AutoInstType		{ UseManager, InformOnly, FullAuto, NoAuto  };
				DeclareNameSpaceEnumUtils(Basic,AutoInstType)
    enum RelType		{ Stable, Development, PreStable,
				  PreDevelopment, Ancient, Other };
				DeclareNameSpaceEnumUtils(Basic,RelType)
    /*!
	Policy: Externally, policy can be fixed using OD_INSTALLER_POLICY
	Without OD_INSTALLER_POLICY, read/write user settings
	OD_INSTALLER_POLICY must be the enum string (i.e. the keys in settings)
      */
    mGlobal(Basic) bool		autoInstTypeIsFixed();
    mGlobal(Basic) AutoInstType	getAutoInstType();
    mGlobal(Basic) void		setAutoInstType(AutoInstType);

    mGlobal(Basic) const BufferStringSet& autoInstTypeUserMsgs();
    mGlobal(Basic) const char*		sKeyAutoInst();
    mGlobal(Basic) Settings&		userSettings();
    
    mGlobal(Basic) RelType		getRelType();
    mGlobal(Basic) BufferString		getInstallerPlfDir();


} // namespace

#ifdef __mac__
#define mInstallerDirNm "OpendTect Installer.app"
#else
#define mInstallerDirNm "Installer"
#endif

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odmemory_h
#define odmemory_h
/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		Jan 2009
 RCS:		$Id: odmemory.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "task.h"

class IOPar;

namespace OD
{
    enum		PtrPolicy { UsePtr, CopyPtr, TakeOverPtr };
};

template <class T> class ValueSeries;

// 1M operations min per thread
#define mMemMinThreadSize 1048576


/*!
\brief Sets large amounts of values to a constant using multiple threads.
*/

template <class T>
mClass(Basic) MemSetter : public ParallelTask
{
public:
    		MemSetter();
    		MemSetter(T*,T val,od_int64 sz);
    		MemSetter(ValueSeries<T>&,T val,od_int64 sz);

    void	setValue( const T& val )	{ val_ = val; }
    void	setTarget( T* ptr )		{ ptr_ = ptr; vs_ = 0; }
    void	setTarget( ValueSeries<T>& vs )	{ ptr_ = vs.arr(); vs_ = &vs; }
    void	setSize( od_int64 sz )		{ sz_ = sz; }

    bool	doPrepare(int);
    bool	doWork(od_int64,od_int64,int);
    od_int64	nrIterations() const		{ return sz_; }
    int		minThreadSize() const		{ return mMemMinThreadSize; }

protected:

    bool		setPtr(od_int64 start,od_int64 size);

    ValueSeries<T>*	vs_;
    T*			ptr_;
    od_int64		sz_;
    T			val_;
};


/*!
\brief ValueSeries Copier
*/

template <class T>
mClass(Basic) MemCopier : public ParallelTask
{
public:

    		MemCopier();
    		MemCopier(T*,const T*,od_int64 sz);
    		MemCopier(T*,const ValueSeries<T>&,od_int64 sz);
    		MemCopier(ValueSeries<T>&,const T*,od_int64 sz);
    		MemCopier(ValueSeries<T>&,const ValueSeries<T>&,od_int64 sz);

    void	setInput( const T* ptr )	{ inptr_ = ptr; invs_ = 0; }
    void	setInput( const ValueSeries<T>& vs ) {	inptr_ = vs.arr();
							invs_ = &vs; }
    void	setOutput( T* ptr )		{ outptr_ = ptr; outvs_ = 0; }
    void	setOutput( ValueSeries<T>& vs )	{ outptr_ = vs.arr();
						  outvs_ = &vs; }
    void	setSize(od_int64 sz)		{ sz_ = sz; }

    bool	doPrepare(int);
    bool	doWork(od_int64,od_int64,int);
    od_int64	nrIterations() const		{ return sz_; }
    int		minThreadSize() const		{ return mMemMinThreadSize; }

protected:

    inline bool		setPtr(od_int64 start,od_int64 size);

    const T*		inptr_;
    const ValueSeries<T>* invs_;
    T*			outptr_;
    ValueSeries<T>*	outvs_;
    od_int64		sz_;
};


/*!
\brief Goes through some mem or a ValSeries and replaces one value with another.
*/

template <class T>
mClass(Basic) MemValReplacer : public ParallelTask
{
public:
		MemValReplacer();
		MemValReplacer(T*,const T& fromval,const T& toval,od_int64 sz);
		MemValReplacer(ValueSeries<T>&,const T& from,const T& to,
			       od_int64 sz);

    void        setFromValue(const T& val)	{ fromval_ = val; }
    void        setToValue(const T& val)	{ toval_ = val; }
    void        setPtr(T* ptr)			{ ptr_ = ptr; vs_ = 0; }
    void        setPtr(ValueSeries<T>& vs)	{ ptr_ = vs.arr(); vs_ = &vs; }
    void        setSize(od_int64 sz)		{ sz_ = sz; }

    bool        doPrepare(int);
    bool        doWork(od_int64,od_int64,int);
    od_int64    nrIterations() const            { return sz_; }
    int         minThreadSize() const           { return mMemMinThreadSize; }

protected:

    bool                setPtr(od_int64 start,od_int64 size);

    ValueSeries<T>*     vs_;
    T*                  ptr_;
    od_int64            sz_;
    T                   toval_;
    T                   fromval_;
};


#include "valseries.h"


template <class T> inline
MemSetter<T>::MemSetter()
    : ptr_( 0 )
    , vs_( 0 )
    , sz_( -1 )
{} 


template <class T> inline
MemSetter<T>::MemSetter( T* ptr, T val, od_int64 sz )
    : ptr_( ptr )
    , vs_( 0 )
    , val_( val )
    , sz_( sz )
{} 


template <class T> inline
MemSetter<T>::MemSetter( ValueSeries<T>& vs, T val, od_int64 sz )
    : ptr_( vs.arr() )
    , vs_( &vs )
    , val_( val )
    , sz_( sz )
{}


template <class T> inline
bool MemSetter<T>::doPrepare( int )
{ return ptr_ || vs_; }


template <class T> inline
bool MemSetter<T>::doWork( od_int64 start, od_int64 stop, int )
{
    if ( ptr_ )
	return setPtr( start, stop-start+1 );

    for ( od_int64 idx=start; idx<=stop; idx++ )
	vs_->setValue( idx, val_ );

    return true;
}


template <> inline
bool MemSetter<char>::setPtr( od_int64 start, od_int64 size )
{
    memset( ptr_+start, (int)val_, (size_t) size );
    return true;
}


template <> inline
bool MemSetter<unsigned char>::setPtr( od_int64 start, od_int64 size )
{
    memset( ptr_+start, (int)val_, (size_t) size );
    return true;
}


template <> inline
bool MemSetter<bool>::setPtr( od_int64 start, od_int64 size )
{
    memset( ptr_+start, (int)val_, (size_t) size );
    return true;
}


#define mSetterFullImpl(Type) \
    Type* ptr = ptr_ + start; \
    const Type* stopptr = ptr + size; \
    while ( ptr != stopptr ) \
	{ *ptr = val_; ptr++; } \
 \
    return true


#define mSpecialImpl( Type ) \
template <> inline \
bool MemSetter<Type>::setPtr( od_int64 start, od_int64 size ) \
{ \
    if ( val_==0 ) \
    { \
	memset( ptr_+start, 0, (size_t) (size*sizeof(Type)) ); \
	return true; \
    } \
 \
    mSetterFullImpl(Type); \
}


mSpecialImpl( float );
mSpecialImpl( double );
mSpecialImpl( int );
mSpecialImpl( unsigned int );
mSpecialImpl( short );
mSpecialImpl( unsigned short );
mSpecialImpl( od_int64 );
mSpecialImpl( od_uint64 );



template <class T> inline
bool MemSetter<T>::setPtr( od_int64 start, od_int64 size )
{
    mSetterFullImpl(T);
}

#undef mSpecialImpl
#undef mSetterFullImpl


template <class T> inline
MemCopier<T>::MemCopier()
    : sz_(0), inptr_(0), invs_(0), outptr_(0), outvs_(0)		{}

template <class T> inline
MemCopier<T>::MemCopier( T* o, const T* i, od_int64 sz )
    : sz_(sz), inptr_(i), invs_(0), outptr_(o), outvs_(0)		{}

template <class T> inline
MemCopier<T>::MemCopier( ValueSeries<T>& o, const T* i, od_int64 sz )
    : sz_(sz), inptr_(i), invs_(0), outptr_(o.arr()), outvs_(&o)	{}

template <class T> inline
MemCopier<T>::MemCopier( T* o, const ValueSeries<T>& i, od_int64 sz )
    : sz_(sz), inptr_(i.arr()), invs_(&i), outptr_(o), outvs_(0)	{}

template <class T> inline
MemCopier<T>::MemCopier( ValueSeries<T>& o, const ValueSeries<T>& i,od_int64 sz)
    : sz_(sz), inptr_(i.arr), invs_(&i), outptr_(o.arr()), outvs_(&o)	{}


template <class T> inline
bool MemCopier<T>::doPrepare( int )
{ return (inptr_ || invs_) && (outptr_ || outvs_); }


template <class T> inline
bool MemCopier<T>::doWork( od_int64 start, od_int64 stop, int )
{
    if ( inptr_ && outptr_ )
	return setPtr( start, stop-start+1 );

    if ( outptr_ )
    {
	for ( od_int64 idx=start; idx<=stop; idx++ )
	    outptr_[idx] = invs_->value( idx );
    }
    else if ( inptr_ )
    {
	for ( od_int64 idx=start; idx<=stop; idx++ )
	    outvs_->setValue( idx, inptr_[idx] );
    }
    else
    {
	for ( od_int64 idx=start; idx<=stop; idx++ )
	    outvs_->setValue( idx, invs_->value(idx) );
    }
    return true;
}


template <class T> inline
bool MemCopier<T>::setPtr( od_int64 start, od_int64 size )
{
    memcpy( outptr_ + start, inptr_ + start, (size_t) (size * sizeof(T)) );
    return true;
}


template <class T> inline
MemValReplacer<T>::MemValReplacer( T* ptr, const T& fromval, const T& toval,
				   od_int64 sz )
    : ptr_( ptr )
    , vs_( 0 )
    , fromval_( fromval )
    , toval_( toval )
    , sz_( sz )
{}


template <class T> inline
MemValReplacer<T>::MemValReplacer(ValueSeries<T>& vs, const T& fromval,
				  const T& toval,
				  od_int64 sz)
    : ptr_( vs.arr() )
    , vs_( &vs )
    , toval_( toval )
    , fromval_( fromval )
    , sz_( sz )
{}


template <class T> inline
bool MemValReplacer<T>::doPrepare( int )
{ return ptr_ || vs_; }


template <class T> inline
bool MemValReplacer<T>::doWork( od_int64 start, od_int64 stop, int )
{
    if ( ptr_ )
	return setPtr( start, stop-start+1 );

    for ( od_int64 idx=start; idx<=stop; idx++ )
    {
	if ( vs_->value(idx)==fromval_ )
	    vs_->setValue( idx, toval_ );
    }

    return true;
}

template <class T> inline
bool MemValReplacer<T>::setPtr( od_int64 start, od_int64 size )
{
    T* ptr = ptr_ + start;
    const T* stopptr = ptr + size;
    while ( ptr != stopptr )
    {
	if ( *ptr==fromval_ )
	    *ptr = toval_;

	ptr++;
    }

    return true;
}

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odplatform_h
#define odplatform_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bert
 Date:          May 2010
 RCS:           $Id: odplatform.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "enums.h"

namespace OD
{

/*!
\brief Platform or Operating System
*/

mExpClass(Basic) Platform
{
public:

    static const Platform& local();	//!< This platform

    enum Type	{ Lin32, Lin64, Win32, Win64, Mac };
		DeclareEnumUtils(Type)

    		Platform();		//!< This platform
    		Platform( Type t )	//!< That platform
		    : type_(t)		{}
		Platform( const char* s, bool isshortnm )
					{ set(s,isshortnm); }
		Platform( bool iswin, bool is32, bool ismac=false )
		    			{ set(iswin,is32,ismac); }
    bool        operator ==( const Platform& p ) const
					{ return type_ == p.type_; }
    bool        operator ==( const Platform::Type& t ) const
					{ return type_ == t; }

    const char*	longName() const { return getTypeString(type_); }
    const char*	shortName() const;	//!< mac, lux32, win64, etc.

    static bool	isValidName(const char*,bool isshortnm);
    void	set(const char*,bool isshortnm);
    inline void	set( bool iswin, bool is32, bool ismac=false )
    		{ type_ = ismac ? Mac : (iswin	? (is32 ? Win32 : Win64)
						: (is32 ? Lin32 : Lin64) ); }

    inline bool	isWindows() const
			{ return type_ == Win32 || type_ == Win64; }
    inline bool	isLinux() const
			{ return type_ == Lin32 || type_ == Lin64; }
    inline bool	isMac() const
			{ return type_ == Mac; }

    inline bool	is32Bits() const
			{ return type_ != Win64 && type_ != Lin64; }

    inline Type	type() const		{ return type_; }
    inline Type& type()			{ return type_; }
    inline void	setType( Type t )	{ type_ = t; }

protected:

    Type	type_;

};

} // namespace


#define mPlf(ptyp) OD::Platform(OD::Platform::ptyp)
#define mPlfShortName(ptyp) mPlf(ptyp).shortName()


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odplugin_h
#define odplugin_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Apr 2011
 RCS:		$Id: odplugin.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"

extern "C" {
#include "pluginbase.h"
}
#include "gendefs.h"


/* The following function MUST be defined: */
#define mDefODInitPlugin(pinm) \
    mExternC(pinm) const char* Init##pinm##Plugin(int,char**); \
    mExternC(pinm) const char* Init##pinm##Plugin( int argc, char** argv )

/* The following function SHOULD be defined: */
#define mDefODPluginInfo(pinm) \
    mExternC(pinm) PluginInfo* Get##pinm##PluginInfo(); \
    mExternC(pinm) PluginInfo* Get##pinm##PluginInfo()

/* Define ONLY if your plugin needs early loading (i.e. before any UI)
   This is common for 'Batch'-type plugins.
 */
#define mDefODPluginEarlyLoad(pinm) \
    mExternC(pinm) int Get##pinm##PluginType(); \
    mExternC(pinm) int Get##pinm##PluginType() { return PI_AUTO_INIT_EARLY; }


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odset_h
#define odset_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Feb 2009
 RCS:		$Id: odset.h 30564 2013-07-05 08:00:55Z bert.bril@dgbes.com $
________________________________________________________________________

-*/

#ifndef gendefs_h
# include "gendefs.h"
#endif

namespace OD
{

/*!
\brief Base class for all sets used in OpendTect. 
*/

mExpClass(Basic) Set
{
public:

    virtual		~Set()					{}

    virtual od_int64	nrItems() const				= 0;
    virtual bool	validIdx(od_int64) const		= 0;
    virtual void	swap(od_int64,od_int64)			= 0;
    virtual void	erase()					= 0;
    virtual void	removeRange(od_int64 start,od_int64 stop)  = 0;

    inline bool		isEmpty() const		{ return nrItems() <= 0; }
    inline void		setEmpty()		{ erase(); }

};

} // namespace

#define mODSetApplyToAll( tp, os, op ) \
    for ( tp idx=(tp) os.nrItems()-1; idx>=0; idx-- ) \
        op


/*!\brief Adds all names from a set to another set with an add() function
  	(typically a BufferStringSet)

Note: will only work for sets with int indexes. This will be fixed after od4.6.

 */

template <class ODSET,class WITHADD>
inline void addNames( const ODSET& inp, WITHADD& withadd )
{
    const int sz = (int)(inp.size());
    for ( int idx=0; idx<sz; idx++ )
	withadd.add( inp[idx]->name() );
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odsysmem_h
#define odsysmem_h
/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		April 2012
 RCS:		$Id: odsysmem.h 30452 2013-06-26 07:24:34Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "gendefs.h"
class IOPar;

namespace OD
{
    mGlobal(Basic) void	getSystemMemory(od_int64& total,od_int64& free);
    mGlobal(Basic) void	dumpMemInfo(IOPar&);
}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odver_h
#define odver_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2006
 RCS:		$Id: odver.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#include "basicmod.h"
#include "odversion.h"

#include "gendefs.h"

#ifdef __cpp__
extern "C" {
#endif

    mGlobal(Basic) const char* GetFullODVersion();

#ifdef __cpp__

}

class BufferString;
void mGlobal(Basic) GetSpecificODVersion(const char* typ,BufferString&);
/*!< 'typ' can be "doc" or other like vendor name. if null -> platform */

#endif

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef odversion_h
#define odversion_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2006
 RCS:		$Id: odversion.h.in 30292 2013-06-12 07:08:46Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


This is an automatically generated file. Please edit odversion.h.in for
permanent changes.

-*/

#define mODMajorVersion		4
#define mODMinorVersion		6
#define mODDetailVersion	0
#define mODPatchVersion		l

#define mODVersion		460

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef plfdefs_h
#define plfdefs_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Contents:	Defines that encapsulate system things
 RCS:		$Id: plfdefs.h 29166 2013-04-09 03:22:33Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/


/*!

For every platform, one of the following variables must be set by cmake:

	__lux64__, __lux32__	Linux
	__win64__, __win32__	MS Windows
	__mac__			Apple Mac OSX

Then you get:
OS type:

	__unix__	Unix
	__lux__		Linux
	__win__		Windows

Platform:

	__win32__	Windows 32 bits (x86)
	__win64__	Windows 64 bits (AMD)
	__lux32__	Linux 32 bits (x86)
	__lux64__	Linux 64 bits (AMD)
	__mac__		Mac

	__plfsubdir__	String like "win32", "lux32" etc.
	__plfname__	String like "MS Windows 32 bits", "Linux 32 bits"

Compiler type:

	__gnuc__	GNU gcc
	__msvc__	MS Visual C++

Language:

	__cpp__		C++ (else C)

Byte order:

	__little__	little-endian
 
Always defined:

	__islittle__	'true' if little endian machine, false otherwise
	__islinux__	'true' on Linux, 'false' otherwise
	__is32bits__	'true' on 32 bits platforms, 'false' otherwise
	__ismac__	'true' on Mac, 'false' otherwise
	__iswin__	'true' on Windows, 'false' otherwise

*/


/*____________________________________________________________________________*/
/* OS type */

#undef __unix__
#undef __win__

// herman
#undef UNICODE

#if defined( __win64__ ) || defined ( __win32__ )
# define __win__ 1
#endif

#if defined ( __lux32__ ) || defined ( __lux64__ )
# define __unix__ 1
# define __lux__ 1
#endif

#if defined( __mac__ )
# define __unix__ 1
#endif

#ifndef __unix__
#ifndef __win__
# error "Platform not detected."
#endif
#endif

#ifdef __lux__
# define __islinux__ true
#else
# define __islinux__ false
#endif
#ifdef __mac__
# define __ismac__ true
#else
# define __ismac__ false
#endif
#ifdef __win__
# define __iswin__ true
#else
# define __iswin__ false
#endif


/*____________________________________________________________________________*/
/* Machine type	*/


#undef __little__
// All platforms are little endian
# define __little__ 1
# define __islittle__ true

#ifdef __win32__
# define __plfsubdir__	"win32"
# define __plfname__	"MS Windows 32 bits"
# define __is32bits__	true
#endif
#ifdef __win64__
# define __plfsubdir__	"win64"
# define __plfname__	"MS Windows 64 bits"
# define __is32bits__	false
#endif
#ifdef __lux32__
# define __plfsubdir__	"lux32"
# define __plfname__	"Linux 32 bits"
# define __is32bits__	true
#endif
#ifdef __lux64__
# define __plfsubdir__	"lux64"
# define __plfname__	"Linux 64 bits"
# define __is32bits__	false
#endif
#ifdef __mac__
# define __plfsubdir__	"mac"
# define __plfname__	"Mac"
# define __is32bits__	false
#endif

/*____________________________________________________________________________*/
/* Language type */

#undef __cpp__
#ifdef __cplusplus
# if __cplusplus >= 201103L
#  define __cpp11__ 1
# endif
# define __cpp__ 1
#endif
#ifdef _LANGUAGE_C_PLUS_PLUS
# undef __cpp__
# define __cpp__ 2
#endif
#ifdef c_plusplus
# undef __cpp__
# define __cpp__ 3
#endif


/*____________________________________________________________________________*/
/* Compiler type */

#undef __gnu__
#undef __msvc__
#ifdef __lux__
# define __gnuc__ 1
#endif
#ifdef __GNUC__
# undef __gnuc__
# define __gnuc__ 1
#endif
#if defined( __win__ ) || defined( WIN32 )
# ifndef __gnuc__
#  define __msvc__ 1
# endif
#endif

#if defined( __win__ ) && !defined( __msvc__ )
# define __cygwin__ 1
#endif


#undef mUnusedVar
#if defined( __gnuc__ )
# define mUnusedVar __attribute__ ((unused))
#else
# define mUnusedVar
#endif

/* And, probably unnecessary, for external header files: */
#ifndef NeedFunctionPrototypes
# define NeedFunctionPrototypes 1
#endif
#ifndef _ANSI_C_SOURCE
# define _ANSI_C_SOURCE 1
#endif


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef plftypes_h
#define plftypes_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Contents:	Platform dependent types
 RCS:		$Id: plftypes.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "plfdefs.h"

#ifdef __sun__
# include <sys/types.h>
#else
# ifndef __msvc__
#  include <stdint.h>
# endif

#endif

/* 16 bits short is standard. Only use to emphasise the 16-bitness */
#define od_int16	short
#define od_uint16	unsigned short

/* 32 bits int is standard. Only use to emphasise the 32-bitness */
#define od_int32	int
#define od_uint32	unsigned int

/* 64 bits is int64_t. The definition is in various header files. */
#ifndef __msvc__
# define od_int64	int64_t
# define od_uint64	uint64_t
#else
# define od_int64 	__int64
# define od_uint64	unsigned __int64
#endif

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef pluginbase_h
#define pluginbase_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; No license.
 Author:	A.H.Bril
 Date:		June 2006
 RCS:		$Id: pluginbase.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

 This header file is intended for programmers who want to use their code for
 both OpendTect plugins and programs not using OpendTect. You can freely add
 plugin init functions in your code without linking with OpendTect libs.

 Of course, if you _do_ link with the OpendTect libs, the OpendTect license
 becomes active.

-*/


/* If you do not use OpendTect stuff here, you need a way to figure out whether you are in the C++ world and add something like:

#ifdef __cplusplus
extern "C" {
#endif
*/

#define PI_AUTO_INIT_NONE	0
#define PI_AUTO_INIT_EARLY	1
#define PI_AUTO_INIT_LATE	2

/*!\brief Information about plugin for outside world */

typedef struct {

    const char*	dispname;
    const char*	creator;
    const char*	version;
    const char*	text;

} PluginInfo;

/* } -- for the extern "C" */

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef plugins_h
#define plugins_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Aug 2003
 Contents:	Plugins

 RCS:		$Id: plugins.h 28802 2013-03-12 16:44:11Z kristofer.tingdahl@dgbes.com $

 For making your own plugins, no need to include this file. Use odplugin.h.
________________________________________________________________________

-*/

#include "basicmod.h"
#include "sharedlibs.h"
#include "bufstring.h"
#include "objectset.h"


class FileMultiString;

#ifdef __cpp__
extern "C" {
#endif

#include "pluginbase.h"

/* C Access. C++ should use PluginManager! */

/*! To be called from program (once for EARLY, once for LATE) */
void LoadAutoPlugins(int inittype);
/*! To be called from program if needed */
int LoadPlugin(const char* libnm);

#ifdef __cpp__
}

/*!
\brief Plugin manager - loads plugins: shared libs or DLLs.

  Note: there are macros making most of the below stuff not interesting.
  See header file odplugin.h.
  
  For shared libs to be in any way useful, an init function
  must be called. The name of that function should predictable.
  It is constructed as follows:
  InitxxxPlugin
  where xxx is the name of the plugin file, where:
  libxxx.so -> xxx 
  xxx.dll -> xxx 
  etc.
  
  The signature is:
  
  extern "C" {
  const char* InitxxxPlugin(int,char**);
  }
  
  Optional extras:
  
  1) If you want the plugin to be loaded automatically at
  startup define:
  
  extern "C" int GetxxxPluginType(void);
  
  if not defined, PI_AUTO_INIT_NONE is assumed, which means it will not be
  loaded if not explicitly done so.
  
  Loading from startup is done from $HOME/.od/plugins/$PLFSUBDIR/libs or
  $dGB_APPL/plugins/$PLFSUBDIR/libs. The plguniins in these directories will
  be loaded only if they are mentioned in a .alo file in the parent directory,
  $HOME/.od/plugins/$PLFSUBDIR or $dGB_APPL/plugins/$PLFSUBDIR.
  The alo files are handled in alphabetical order.
  
  2) It may be a good idea to define a function:
  
  extern "C" PluginInfo* GetxxxPluginInfo(void);
  
  Make sure it returns an object of type PluginManager::Info*. Make sure it
  points to an existing object (static or made with new/malloc);
  
  3) The user of PIM() can decide not to load all of the .alo load libs. After
  construction, the getData() list is filled. You can change the source_ to
  None before calling loadAuto().
*/

mExpClass(Basic) PluginManager
{
public:

    mGlobal(Basic) friend PluginManager& PIM();
    
    static PluginManager&	getInstance();

    void			loadAuto(bool late);
				//!< see class comments
    bool			load(const char* libnm);
    					//!< Explicit load of a plugin

    struct Data
    {
	enum AutoSource		{ None, UserDir, AppDir, Both };
	static bool		isUserDir( AutoSource src )
	    			{ return src != AppDir && src != None; }

				Data( const char* nm )
				    : name_(nm)
				    , info_(0)
				    , autosource_(None)
				    , autotype_(PI_AUTO_INIT_NONE)
				    , isloaded_( false )
				    , sla_(0)	{}
				~Data()		{ delete sla_; }

	BufferString		name_;
	const PluginInfo*	info_;
	AutoSource		autosource_;
	int			autotype_;
	SharedLibAccess*	sla_;
	bool			isloaded_;
    };

    ObjectSet<Data>&	getData()		{ return data_; }
    Data*		findData( const char* nm ) { return fndData( nm ); }
    const Data*		findData( const char* nm ) const {return fndData( nm );}
    const Data*		findDataWithDispName(const char*) const;

    bool		isPresent(const char*) const;
    const char*		userName(const char*) const;
    			/*!<returns name in plugin-info, or moduleName
    			    if plugin info is not available. */
    			
    static const char*	moduleName(const char*);
    			//!< returns without path, 'lib' and extension
    const char*		getFileName(const Data&) const;

    const char*		getAutoDir( bool usr ) const
			{ return usr ? userlibdir_ : applibdir_; }

    static const char*	sKeyDontLoad() { return "dTect.Dont load plugins"; }
    void		getNotLoadedByUser(FileMultiString&) const;

private:

    				PluginManager();

    ObjectSet<Data>		data_;

    BufferString		userdir_;
    BufferString		appdir_;
    BufferString		userlibdir_;
    BufferString		applibdir_;

    Data*			fndData(const char*) const;
    void			getDefDirs();
    void			getALOEntries(const char*,bool);
    void			openALOEntries();
    void			mkALOList();
};

mGlobal(Basic) PluginManager& PIM();


#endif /* End of C++ only section */


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef posgeom_h
#define posgeom_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bert
 Date:          Jan 2003
 RCS:           $Id: posgeom.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "geometry.h"
#include "position.h"

inline Geom::Point2D<int>	pt( const BinID& bid )
				{ return Geom::Point2D<int>(bid.inl,bid.crl); }
inline Geom::Point2D<double>	pt( const Coord& c )
				{ return Geom::Point2D<double>(c.x,c.y); }

inline BinID			bid( const Geom::Point2D<int>& p )
				{ return BinID(p.x,p.y); }
inline Coord			crd( const Geom::Point2D<double>& p )
				{ return Coord(p.x,p.y); }


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef posinfo_h
#define posinfo_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		2005 / Mar 2008
 RCS:		$Id: posinfo.h 33121 2014-01-24 10:50:47Z satyaki.maitra@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "manobjectset.h"
#include "typeset.h"
#include "cubesampling.h"
#include "indexinfo.h"
#include "position.h"
class BinID;


/*!\brief Position info, often segmented

In data cubes with gaps and other irregulaities, a complete description
of the positions present can be done by describing the regular segments
per inline. No sorting of inlines is required.

The crossline segments are assumed to be sorted, i.e.:
[1-3,1] [5-9,2] : OK
[9-5,-1] [3-1,-1] : OK
[5-9,2] [1-3,1] : Not OK

Note that the LineData class is also interesting for 2D lines with trace
numbers.

*/

namespace PosInfo
{

/*!
\brief Position info for a line - in a 3D cube, that would be an inline.
Stored as (crossline-)number segments.
*/

mExpClass(Basic) LineData
{
public:
    typedef StepInterval<int>	Segment;

				LineData( int i ) : linenr_(i)	{}

    const int			linenr_;
    TypeSet<Segment>		segments_;

    int				size() const;
    int				segmentOf(int) const;
    Interval<int>		range() const;
    void			merge(const LineData&,bool incl);
    				//!< incl=union, !incl=intersection

    int				nearestSegment(double) const;
    IndexInfo			getIndexInfo(double) const;

};


/*!
\brief Position in a CubeData.
*/

mExpClass(Basic) CubeDataPos
{
public:
    		CubeDataPos( int iln=0, int isn=0, int sidx=-1 )
		    : lidx_(iln), segnr_(isn), sidx_(sidx)	{}

    int		lidx_;
    int		segnr_;
    int		sidx_;

    void	toPreStart()	{ lidx_ = segnr_ = 0; sidx_ = -1; }
    void	toStart()	{ lidx_ = segnr_ = sidx_ = 0; }
    bool	isValid() const	{ return lidx_>=0 && segnr_>=0 && sidx_>=0; }

};


/*!
\brief Position info for an entire 3D cube.
The LineData's are not sorted.
*/

mExpClass(Basic) CubeData : public ManagedObjectSet<LineData>
{
public:

    			CubeData()		{}
    			CubeData( BinID start, BinID stop, BinID step )
						{ generate(start,stop,step); }
    			CubeData( const CubeData& cd )
						{ *this = cd; }
    CubeData&		operator =( const CubeData& cd )
			{ copyContents(cd); return *this; }

    int			totalSize() const;
    int			totalSizeInside(const HorSampling& hrg) const;
    			/*!<Only take positions that are inside hrg. */

    virtual int		indexOf(int inl,int* newidx=0) const;
    			//!< newidx only filled if not null and -1 is returned
    bool		includes(int inl,int crl) const;
    bool		getInlRange(StepInterval<int>&) const;
    			//!< Returns whether fully regular.
    bool		getCrlRange(StepInterval<int>&) const;
    			//!< Returns whether fully regular.

    bool		isValid(const CubeDataPos&) const;
    bool		toNext(CubeDataPos&) const;
    BinID		binID(const CubeDataPos&) const;
    CubeDataPos		cubeDataPos(const BinID&) const;

    bool		haveInlStepInfo() const		{ return size() > 1; }
    bool		haveCrlStepInfo() const;
    bool		isFullyRectAndReg() const;
    bool		isCrlReversed() const;

    void		limitTo(const HorSampling&);
    void		merge(const CubeData&,bool incl);
    				//!< incl=union, !incl=intersection
    void		generate(BinID start,BinID stop,BinID step);

    bool		read(std::istream&,bool asc);
    bool		write(std::ostream&,bool asc) const;

    virtual int		indexOf( const LineData* l ) const
    			{ return ObjectSet<LineData>::indexOf( l ); }

protected:

    void		copyContents(const CubeData&);

};


/*!
\brief Position info for an entire 3D cube.
The LineData's are sorted.
*/

mExpClass(Basic) SortedCubeData : public CubeData
{
public:
    			SortedCubeData()				{}
    			SortedCubeData( const BinID& start, const BinID& stop,
				  const BinID& step )
			    : CubeData(start,stop,step)		{}
    			SortedCubeData( const SortedCubeData& cd )
			    : CubeData( cd )
								{ *this = cd; }
    			SortedCubeData( const CubeData& cd )	{ *this = cd; }
    SortedCubeData&	operator =( const SortedCubeData& scd )
			{ copyContents(scd); return *this; }
    SortedCubeData&	operator =( const CubeData& cd )
			{ copyContents(cd); return *this; }

    virtual int		indexOf(int inl,int* newidx=0) const;
    			//!< newidx only filled if not null and -1 is returned

    virtual CubeData&	operator +=( LineData* ld )	{ return add( ld ); }
    SortedCubeData&	add(LineData*);

    virtual int		indexOf( const LineData* l ) const
    			{ return CubeData::indexOf( l ); }

};


/*!
\brief Fills CubeData object. Requires inline- and crossline-sorting.
*/

mExpClass(Basic) CubeDataFiller
{
public:
    			CubeDataFiller(CubeData&);
    			~CubeDataFiller();

    void		add(const BinID&);
    void		finish();

protected:

    CubeData&		cd_;
    LineData*		ld_;
    LineData::Segment	seg_;
    int			prevcrl;

    void		initLine();
    void		finishLine();
    LineData*		findLine(int);

};


/*!
\brief Iterates through CubeData. 
*/

mExpClass(Basic) CubeDataIterator
{
public:

    			CubeDataIterator( const CubeData& cd )
			    : cd_(cd)	{}

    inline bool		next( BinID& bid )
			{
			    const bool rv = cd_.toNext( cdp_ );
			    bid = binID(); return rv;
			}
    inline void		reset()		{ cdp_.toPreStart(); }
    inline BinID	binID() const	{ return cd_.binID( cdp_ ); }

    const CubeData&	cd_;
    CubeDataPos		cdp_;

};


} // namespace PosInfo

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef posinfo2d_h
#define posinfo2d_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Jul 2010 (org 2005 / 2008)
 RCS:		$Id: posinfo2d.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "typeset.h"
#include "position.h"
class BinID;


namespace PosInfo
{

/*!
\brief One position on a 2D line.
*/

mExpClass(Basic) Line2DPos
{
public:

		Line2DPos( int n=0 ) : nr_(n)		{}
    bool	operator ==( const Line2DPos& p ) const	{ return nr_ == p.nr_; }
    bool	operator !=( const Line2DPos& p ) const	{ return nr_ != p.nr_; }
    bool	operator >( const Line2DPos& p ) const	{ return nr_ > p.nr_; }
    bool	operator <( const Line2DPos& p ) const	{ return nr_ < p.nr_; }
    bool	operator >=( const Line2DPos& p ) const	{ return nr_>=p.nr_; }
    bool	operator <=( const Line2DPos& p ) const	{ return nr_<=p.nr_; }

    int		nr_;
    Coord	coord_;

};


/*!
\brief Line2DPos with a z value.
*/

mExpClass(Basic) Line2DPos3D : public Line2DPos
{
public:
		Line2DPos3D( int n=0, float z=mUdf(float) )
		    : Line2DPos(n), z_(z)		{}

    float	z_;
};


/*!
\brief Position info for a 2D line.
*/

mExpClass(Basic) Line2DData
{
public:
			Line2DData(const char* lnm=0);

			Line2DData(const Line2DData& l2d)
			: zrg_(l2d.zRange())
			, lnm_(l2d.lineName())
			, posns_(l2d.positions()){}

    const StepInterval<float>& zRange() const		{ return zrg_; }
    const BufferString&	lineName() const		{ return lnm_; }
    void		setZRange( const StepInterval<float>& zrg )
							{ zrg_ = zrg; }
    void		setLineName(const BufferString& lnm)
			{ lnm_ = lnm; }
    const TypeSet<Line2DPos>&  positions() const	{ return posns_; }
    bool		isEmpty() const		{ return posns_.isEmpty(); }

    void		add(const Line2DPos&);
    void		remove(int trcnr);
    void		setEmpty()		{ posns_.erase(); }
    void		limitTo(Interval<int> trcrg);

    int			indexOf(int trcnr) const;
    int			nearestIdx( const Coord& crd ) const
						{ return gtIndex(crd); }
    int			nearestIdx(const Coord&,
	    			   const Interval<int>& trcnrrg) const;

    bool		getPos(const Coord& crd,Line2DPos& l2p,
	    		       float* dist=0) const;
    bool		getPos(const Coord& crd,Line2DPos& l2p,
	    		       float threshold_distance) const;
    bool		getPos(int trcnr,Line2DPos&) const;

    void                dump(std::ostream&,bool pretty=true) const;
    bool		read(std::istream&,bool asc);
    bool		write(std::ostream&,bool asc,bool newlns=false) const;

    StepInterval<int>	trcNrRange() const;
    Coord		getNormal(int trcnr) const;
    void		compDistBetwTrcsStats(float& max, float& median) const;

protected:

    StepInterval<float> zrg_;
    BufferString	lnm_;			
    TypeSet<Line2DPos>  posns_;

    int			gtIndex(int,bool&) const;
    int			gtIndex(const Coord&,double* sqdist=0) const;

};

} // namespace PosInfo

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef position_h
#define position_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		21-6-1996
 Contents:	Positions: Inline/crossline and Coordinate
 RCS:		$Id: position.h 30536 2013-07-03 13:29:49Z yuancheng.liu@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "gendefs.h"
#include "rcol.h"
#include "geometry.h"
#include "undefval.h"

class BufferString;
class RowCol;


/*!
\brief A cartesian coordinate in 2D space.
*/

mExpClass(Basic) Coord : public Geom::Point2D<double>
{
public:
		Coord( const Geom::Point2D<double>& p )
		    :  Geom::Point2D<double>( p )			{}
		Coord() :  Geom::Point2D<double>( 0, 0 )		{}
		Coord( double cx, double cy )	
		    :  Geom::Point2D<double>( cx, cy )			{}

    bool	operator==( const Coord& crd ) const
		{ return mIsEqual(x,crd.x,mDefEps)
		      && mIsEqual(y,crd.y,mDefEps); }
    bool	operator!=( const Coord& crd ) const
		{ return ! (crd == *this); }
    bool	operator<(const Coord&crd) const
		{ return x<crd.x || (x==crd.x && y<crd.y); }
    bool	operator>(const Coord&crd) const
		{ return x>crd.x || (x==crd.x && y>crd.y); }

    double	angle(const Coord& from,const Coord& to) const;
    double	cosAngle(const Coord& from,const Coord& to) const;
    		//!< saves the expensive acos() call
		//
    Coord	normalize() const;
    double	dot(const Coord&) const;

    void	fill(char*) const;
    bool	use(const char*);
    
    static const Coord&		udf();
};

bool getDirectionStr( const Coord&, BufferString& );
/*!< Returns strings like 'South-West', NorthEast depending on the given
     coord that is assumed to have the x-axis pointing northwards, and the
     y axis pointing eastwards
*/


/*!
\brief A cartesian coordinate in 3D space.
*/

mExpClass(Basic) Coord3 : public Coord
{
public:

			Coord3() : z(0)					{}
			Coord3(const Coord& a, double z_ )
			    : Coord(a), z(z_)				{}
			Coord3(const Coord3& xyz )
			    : Coord( xyz.x, xyz.y )
			    , z( xyz.z )				{}
    			Coord3( double x_, double y_, double z_ )
			    : Coord(x_,y_), z(z_)			{}

    double&		operator[]( int idx )
			{ return idx ? (idx==1 ? y : z) : x; }
    double		operator[]( int idx ) const
			{ return idx ? (idx==1 ? y : z) : x; }

    inline Coord3	operator+(const Coord3&) const;
    inline Coord3	operator-(const Coord3&) const;
    inline Coord3	operator-() const;
    inline Coord3	operator*(double) const;
    inline Coord3	operator/(double) const;
    inline Coord3	scaleBy( const Coord3& ) const;
    inline Coord3	unScaleBy( const Coord3& ) const;

    inline Coord3&	operator+=(const Coord3&);
    inline Coord3&	operator-=(const Coord3&);
    inline Coord3&	operator/=(double);
    inline Coord3&	operator*=(double);
    inline Coord&	coord()				{ return *this; }
    inline const Coord&	coord() const			{ return *this; }

    inline bool		operator==(const Coord3&) const;
    inline bool		operator!=(const Coord3&) const;
    inline bool		isDefined() const;
    double		distTo(const Coord3&) const;
    double		sqDistTo(const Coord3&) const;

    inline double	dot( const Coord3& b ) const;
    inline Coord3	cross( const Coord3& ) const;
    double		abs() const;
    double		sqAbs() const;
    inline Coord3	normalize() const;

    void	fill(char* str) const { fill( str, "(", " ", ")"); }
    void	fill(char*, const char* start, const char* space,
	    		    const char* end) const;
    bool	use(const char*);

    double	z;

    static const Coord3& udf();

    inline double	distTo( const Geom::Point2D<double>& b ) const
			{ return Geom::Point2D<double>::distTo(b); }
    inline double	sqDistTo( const Geom::Point2D<double>& b ) const
			{ return Geom::Point2D<double>::sqDistTo(b); }
};


inline Coord3 operator*( double f, const Coord3& b )
{ return Coord3(b.x*f, b.y*f, b.z*f ); }


/*!
\brief 2D coordinate and a value.
*/

mExpClass(Basic) CoordValue
{
public:
		CoordValue( double x=0, double y=0, float v=mUdf(float) )
		: coord(x,y), value(v)		{}
		CoordValue( const Coord& c, float v=mUdf(float) )
		: coord(c), value(v)		{}
    bool	operator==( const CoordValue& cv ) const
		{ return cv.coord == coord; }
    bool	operator!=( const CoordValue& cv ) const
		{ return cv.coord != coord; }

    Coord	coord;
    float	value;
};


/*!
\brief 3D coordinate and a value.
*/

mExpClass(Basic) Coord3Value
{
public:
    		Coord3Value( double x=0, double y=0, double z=0, 
			     float v=mUdf(float) )
		    : coord(x,y,z), value(v) 	{}
		Coord3Value( const Coord3& c, float v=mUdf(float) )
		    : coord(c), value(v)		{}
    bool	operator==( const Coord3Value& cv ) const
		{ return cv.coord == coord; }
    bool	operator!=( const Coord3Value& cv ) const
		{ return cv.coord != coord; }

    Coord3	coord;
    float	value;
};


/*!
\brief Positioning in a seismic survey: inline/crossline. Most functions are
identical to RowCol.
*/

mExpClass(Basic) BinID
{
public:
    inline			BinID(int r,int c);
    				BinID(const RowCol&);
    inline			BinID(const BinID&);
    inline			BinID();

    inline bool			operator==(const BinID&) const;
    inline bool			operator!=(const BinID&) const;
    inline BinID		operator+(const BinID&) const;
    inline BinID		operator-(const BinID&) const;
    inline BinID		operator+() const;
    inline BinID		operator-() const;
    inline BinID		operator*(const BinID&) const;
    inline BinID		operator*(int) const;
    inline BinID		operator/(const BinID&) const;
    inline BinID		operator/(int) const;
    inline const BinID&		operator+=(const BinID&);
    inline const BinID&		operator-=(const BinID&);
    inline const BinID&		operator*=(const BinID&);
    inline const BinID&		operator*=(int);
    inline const BinID&		operator/=(const BinID&);
    inline int&			operator[](int idx);
    inline int			operator[](int idx) const;
    inline int			toInt32() const;
    
    inline static BinID		fromInt64(od_int64);
    inline static BinID		fromInt32(int);
    inline int			sqDistTo(const BinID&) const;

    void			fill(char*) const;
    bool			use(const char*);
    inline od_int64		toInt64() const;
    bool                        isNeighborTo(const BinID&,const BinID&,
					     bool eightconnectivity=true) const;

    int				inl;
    int				crl;

    static const BinID&		udf();
    
    int&			trcNr()		{ return crl; }
    int				trcNr() const	{ return crl; }
    int&			lineNr()	{ return inl; }
    int				lineNr() const	{ return inl; }


    od_int64			getSerialized() const;
    				//!<Legacy. Use toInt64 instead.
    void			setSerialized(od_int64);
    				//!<Legacy. Use fromInt64 instead.
};



mImplInlineRowColFunctions(BinID, inl, crl);

/*!
\brief Represents a trace position, with the geometry (2D or 3D) and position in
the geometry.
*/

mExpClass(Basic) TraceID
{
public:
				typedef int GeomID;
    
				TraceID(const BinID& bid);
				TraceID(GeomID geomid,int linenr,int trcnr);

    static GeomID		std3DGeomID();
    static GeomID		cUndefGeomID();
    
    bool			is2D() const
    				{ return geomid_!=std3DGeomID(); }
    int&			trcNr()		{ return pos_.trcNr(); }
    int				trcNr() const	{ return pos_.trcNr(); }
    int&			lineNr()	{ return pos_.lineNr(); }
    int				lineNr() const	{ return pos_.lineNr(); }
    
    bool			operator ==( const TraceID& a ) const
    				{ return a.geomid_==geomid_ && a.pos_==pos_; }

    static const TraceID&	udf();
    
    bool			isUdf() const { return mIsUdf(pos_.trcNr()); }
    
    GeomID			geomid_;
				/*!<std3DGeomID refers to the default 3d survey
				    setup. Any other value refers to the
				    geometry.*/
    BinID			pos_;
};

class BinIDValues;


/*!
\brief BinID and a value.
*/

mClass(Basic) BinIDValue
{
public:
		BinIDValue( int inl=0, int crl=0, float v=mUdf(float) )
		: binid(inl,crl), value(v)	{}
		BinIDValue( const BinID& b, float v=mUdf(float) )
		: binid(b), value(v)		{}
		BinIDValue(const BinIDValues&,int);

    bool	operator==( const BinIDValue& biv ) const
		{ return biv.binid == binid
		      && mIsEqual(value,biv.value,compareEpsilon()); }
    bool	operator!=( const BinIDValue& biv ) const
		{ return !(*this == biv); }

    BinID	binid;
    float	value;

    static float compareEpsilon()		{ return 1e-5; }
};


/*!
\brief BinID and values. If one of the values is Z, make it the first one.
*/

mExpClass(Basic) BinIDValues
{
public:
			BinIDValues( int inl=0, int crl=0, int n=2 )
			: binid(inl,crl), vals(0), sz(0) { setSize(n); }
			BinIDValues( const BinID& b, int n=2 )
			: binid(b), vals(0), sz(0)	{ setSize(n); }
			BinIDValues( const BinIDValues& biv )
			: vals(0), sz(0)		{ *this = biv; }
			BinIDValues( const BinIDValue& biv )
			: binid(biv.binid), vals(0), sz(0)
					{ setSize(1); value(0) = biv.value; }
			~BinIDValues();

    BinIDValues&	operator =(const BinIDValues&);

    bool		operator==( const BinIDValues& biv ) const;
    			//!< uses BinIDValue::compareepsilon
    inline bool		operator!=( const BinIDValues& biv ) const
			{ return !(*this == biv); }

    BinID		binid;
    int			size() const			{ return sz; }
    float&		value( int idx )		{ return vals[idx]; }
    float		value( int idx ) const		{ return vals[idx]; }
    float*		values()			{ return vals; }
    const float*	values() const			{ return vals; }

    void		setSize(int,bool kpvals=false);
    void		setVals(const float*);

protected:

    float*		vals;
    int			sz;
    static float	udf;

};

namespace Values {

/*!
\brief Undefined Coord.
*/

template<>
mClass(Basic) Undef<Coord>
{
public:
    static Coord	val()			{ return Coord::udf(); }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( Coord crd )	{ return !crd.isDefined(); }
    static void		setUdf( Coord& crd )	{ crd = Coord::udf(); }
};


/*!
\brief Undefined Coord3.
*/

template<>
mClass(Basic) Undef<Coord3>
{
public:
    static Coord3	val()			{ return Coord3::udf(); }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( Coord3 crd )	{ return !crd.isDefined(); }
    static void		setUdf( Coord3& crd )	{ crd = Coord3::udf(); }
};

} // namespace Values


inline bool Coord3::operator==( const Coord3& b ) const
{
    const double dx = x-b.x; const double dy = y-b.y; const double dz = z-b.z;
    return mIsZero(dx,mDefEps) && mIsZero(dy,mDefEps) && mIsZero(dz,mDefEps);
}


inline bool Coord3::operator!=( const Coord3& b ) const
{
    return !(b==*this);
}

inline bool Coord3::isDefined() const
{
    return !Values::isUdf(z) && Geom::Point2D<double>::isDefined();
}


inline Coord3 Coord3::operator+( const Coord3& p ) const
{
    return Coord3( x+p.x, y+p.y, z+p.z );
}


inline Coord3 Coord3::operator-( const Coord3& p ) const
{
    return Coord3( x-p.x, y-p.y, z-p.z );
}


inline Coord3 Coord3::operator-() const
{
    return Coord3( -x, -y, -z );
}


inline Coord3 Coord3::operator*( double factor ) const
{ return Coord3( x*factor, y*factor, z*factor ); }


inline Coord3 Coord3::operator/( double denominator ) const
{ return Coord3( x/denominator, y/denominator, z/denominator ); }


inline Coord3 Coord3::scaleBy( const Coord3& factor ) const
{ return Coord3( x*factor.x, y*factor.y, z*factor.z ); }


inline Coord3 Coord3::unScaleBy( const Coord3& denominator ) const
{ return Coord3( x/denominator.x, y/denominator.y, z/denominator.z ); }


inline Coord3& Coord3::operator+=( const Coord3& p )
{
    x += p.x; y += p.y; z += p.z;
    return *this;
}


inline Coord3& Coord3::operator-=( const Coord3& p )
{
    x -= p.x; y -= p.y; z -= p.z;
    return *this;
}


inline Coord3& Coord3::operator*=( double factor )
{
    x *= factor; y *= factor; z *= factor;
    return *this;
}


inline Coord3& Coord3::operator/=( double denominator )
{
    x /= denominator; y /= denominator; z /= denominator;
    return *this;
}


inline double Coord3::dot(const Coord3& b) const
{ return x*b.x + y*b.y + z*b.z; }


inline Coord3 Coord3::cross(const Coord3& b) const
{ return Coord3( y*b.z-z*b.y, z*b.x-x*b.z, x*b.y-y*b.x ); }


inline Coord3 Coord3::normalize() const
{
    const double absval = abs();
    if ( absval < 1e-10 )
	return *this;
    
    return *this / absval;
}

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef positionlist_h
#define positionlist_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        A.H. Bril
 Date:          Jan 2003
 RCS:           $Id: positionlist.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "refcount.h"
#include "position.h"

/*!
\brief Base class for vertex attribute list.
*/

mExpClass(Basic) FloatVertexAttribList
{ mRefCountImpl(FloatVertexAttribList)
public:
    
    
    virtual int		size() const				= 0;
    virtual bool	setSize(int,bool cpdata)		= 0;
    
    virtual void	setCoord(int,const float*)		= 0;
    virtual void	getCoord(int,float*) const		= 0;
    
    virtual void	setNormal(int,const float*)		= 0;
    virtual void	getNormal(int,float*) const		= 0;
    
    virtual void	setTCoord(int,const float*)		= 0;
    virtual void	getTCoord(int,float*) const		= 0;
    
protected:
};


class Coord3;

/*!
\brief Use Coord3ListImpl instead.
*/

mExpClass(Basic) Coord3List
{ mRefCountImplNoDestructor(Coord3List);
public:
    virtual int		nextID(int previd) const			= 0;
    			//!<If previd == -1, first id is returned.
			//!<If -1 is returned, no more id's are available.
    virtual int		add(const Coord3&)				= 0;
    			//!<Return new id, or -1 if unsuccessful
    virtual Coord3	get(int id) const				= 0;
    virtual bool	isDefined(int id) const				= 0;
    virtual void	set(int id,const Coord3&)			= 0;
    virtual void	addValue(int id,const Coord3&)			= 0;
    			//!<Adds value to existing value at id
    virtual void	remove(int id)					= 0;
};


/*!
\brief Use Coord2ListImpl instead.
*/

mExpClass(Basic) Coord2List
{ mRefCountImplNoDestructor(Coord2List);
public:
    virtual int		nextID(int previd) const			= 0;
    			//!<If previd == -1, first id is returned.
			//!<If -1 is returned, no more id's are available.
    virtual Coord	get(int id) const				= 0;
    virtual void	set(int id,const Coord&)			= 0;
    virtual int		add(const Coord&)				= 0;
    			//!<Return new id, or -1 if unsuccessful
    virtual void	addValue(int id,const Coord&)			= 0;
    			//!<Adds value to existing value at id
    virtual void	remove(int id)					= 0;
};


/*!
\brief A list of Coord where each coord has a unique id.
*/

mExpClass(Basic) Coord2ListImpl : public Coord2List
{ 
public:			
    			Coord2ListImpl();
    int			nextID(int previd) const;
    Coord		get(int id) const;
    void		set(int id,const Coord&);	
    int			add(const Coord&); 		
    void		remove(int id);
    void		addValue(int id,const Coord&);
    int			getSize() const 	{ return points_.size(); }

protected:

    TypeSet<int>	removedids_;
    TypeSet<Coord> 	points_;
};


/*!
\brief A list of Coord3 where each coord has a unique id. 
*/

mExpClass(Basic) Coord3ListImpl : public Coord3List
{
public:
    			Coord3ListImpl();
    int                 nextID(int previd) const;
    Coord3              get(int id) const;
    void                set(int id,const Coord3&);
    int                 add(const Coord3&);
    bool		isDefined(int) const;
    void                remove(int id);
    int                 getSize() const         { return coords_.size(); }
    void		addValue(int id,const Coord3&);

protected:

    TypeSet<int>        removedids_;
    TypeSet<Coord3>     coords_;
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef progressmeter_h
#define progressmeter_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl / Bert Bril
 Date:          07-10-1999
 RCS:           $Id: progressmeter.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "gendefs.h"
#include "thread.h"
#include "callback.h"


class Task;

/*!
\brief Is an interface where processes can report their progress.
*/

mExpClass(Basic) ProgressMeter
{
public:
    virtual		~ProgressMeter()		{}
    virtual void	setStarted()			{}
    virtual void	setFinished()			{}

    virtual od_int64	nrDone() const			{ return -1; }
    virtual void	setName(const char*)		{}
    virtual void	setTotalNr(od_int64)		{}
    virtual void	setNrDone(od_int64)		{}
    virtual void	setNrDoneText(const char*)	{}
    virtual void	setMessage(const char*)		{}

    virtual void	operator++()			= 0;
};


/*!
\brief Textual progress indicator for batch programs.
*/

mExpClass(Basic) TextStreamProgressMeter : public ProgressMeter
{
public:
			TextStreamProgressMeter(std::ostream&,
					unsigned short rowlen=cDefaultRowLen());
			~TextStreamProgressMeter();
    static int		cDefaultRowLen() { return 50; }
    static int		cNrCharsPerRow() { return 80; }

    void		setName(const char*);
    void		setStarted();
    void		setFinished();
    void		setNrDone(od_int64);
    void		setTotalNr(od_int64 t)		{ totalnr_ = t; }
    void		setMessage(const char*);

    void		operator++();
    od_int64		nrDone() const			{ return nrdone_; }

protected:
    void		reset();
    void		addProgress(int);

    std::ostream&	strm_;
    BufferString	message_;
    BufferString	name_;
    unsigned short	rowlen_;
    unsigned char	distcharidx_;
    od_int64		nrdoneperchar_;
    od_int64		nrdone_;
    od_int64		lastannotatednrdone_;
    od_int64		totalnr_;
    int 		oldtime_; 
    int 		nrdotsonline_; 
    bool		inited_;
    bool		finished_;
    Threads::Mutex	lock_;

    void		annotate(bool);
}; 


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef ptrman_h
#define ptrman_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          10-12-1999
 RCS:           $Id: ptrman.h 30406 2013-06-21 09:16:56Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "general.h"
#include "errh.h"
#include "thread.h"

#define mImpPtrManPointerAccess( type ) \
    inline type*		ptr() const		{ return this->ptr_; } \
    inline			operator type*() const	{ return this->ptr_; } \
    inline type*		operator ->() const	{ return this->ptr_; } \
    inline type&		operator *() const	{ return *this->ptr_; }

/*! Base class for smart pointers. Don't use directly, use PtrMan, ArrPtrMan
    or RefMan instead. */

template<class T>
mClass(Basic) PtrManBase
{
public:

    inline bool			operator !() const	{ return !ptr_; }

    inline void			set(T* p, bool doerase=true);
    inline void			erase() { set( 0, true ); }
    inline bool			setIfNull(T* p);

protected:

    typedef void		(*PtrFunc)(T*);
    inline			PtrManBase(PtrFunc setfunc,PtrFunc deletor,T*);
    virtual			~PtrManBase()		{ set(0,true); }

    Threads::AtomicPointer<T>	ptr_;

    PtrFunc			setfunc_;
    PtrFunc			deletefunc_;

};


/*!Smart pointer for normal pointers. */
template <class T>
mClass(Basic) PtrMan : public PtrManBase<T>
{
public:
    			PtrMan(const PtrMan<T>&);
			//!<Don't use
    inline		PtrMan(T* = 0);
    PtrMan<T>&		operator=( T* p );
    PtrMan<T>&		operator=(const PtrMan<T>&);
			//!<Don't use
			mImpPtrManPointerAccess( T )
private:

    static void		deleteFunc( T* p )    { delete p; }

};


/*!Smart pointer for normal const pointers. */
template <class T>
mClass(Basic) ConstPtrMan : public PtrManBase<T>
{
public:
    			ConstPtrMan(const ConstPtrMan<T>&);
			//Don't use
    inline		ConstPtrMan(const T* = 0);
    ConstPtrMan<T>&	operator=(const T* p);
    ConstPtrMan<T>&	operator=(const ConstPtrMan<T>&);
			//!<Don't use
			mImpPtrManPointerAccess( const T )
private:

    static void		deleteFunc( T* p )    { delete p; }
};


/*!Smart pointer for pointers allocated as arrays. */
template <class T>
mClass(Basic) ArrPtrMan : public PtrManBase<T>
{
public:
				ArrPtrMan(const ArrPtrMan<T>&);
				//Don't use
    inline			ArrPtrMan(T* = 0);
    ArrPtrMan<T>&		operator=( T* p );
    inline ArrPtrMan<T>&	operator=(const ArrPtrMan<T>& p );
				//!<Don't use
			
				mImpPtrManPointerAccess( T )
private:

    static void		deleteFunc( T* p )    { delete [] p; }

};


/*!Smart pointer for const pointers allocated as arrays. */
template <class T>
mClass(Basic) ConstArrPtrMan : public PtrManBase<T>
{
public:
    			ConstArrPtrMan(const ConstArrPtrMan<T>&);
			//Don't use
    inline		ConstArrPtrMan(const T* = 0);
    ConstArrPtrMan<T>&	operator=(const T* p);
    ConstArrPtrMan<T>&	operator=(const ConstArrPtrMan<T>&);
			//!< Will give linkerror if used
			mImpPtrManPointerAccess( const T )
private:

    static void		deleteFunc( T* p )    { delete p; }
};


/*!Smart pointer for reference counted objects. */
template <class T>
mClass(Basic) RefMan : public PtrManBase<T>
{
public:

    inline		RefMan(const RefMan<T>&);
    inline		RefMan(T* = 0);
    inline RefMan<T>&	operator=( T* p )
    			{ this->set( p, true ); return *this; }
    inline RefMan<T>&	operator=(const RefMan<T>&);
			mImpPtrManPointerAccess( T )

private:

    static void		ref(T* p) { p->ref(); }
    static void		unRef(T* p) { if ( p ) p->unRef(); }
    
};


/*!Smart pointer for reference counted objects. */
template <class T>
mClass(Basic) ConstRefMan : public PtrManBase<T>
{
public:
    inline			ConstRefMan(const ConstRefMan<T>&);
    inline			ConstRefMan(const T* = 0);
    ConstRefMan<T>&		operator=(const T* p);
    inline ConstRefMan<T>&	operator=(const ConstRefMan<T>&);

				mImpPtrManPointerAccess( const T )

private:
    static void		ref(T* p) { p->ref(); }
    static void		unRef(T* p) { if ( p ) p->unRef(); }
    
};

//Implementations below

template <class T> inline
PtrManBase<T>::PtrManBase( PtrFunc setfunc, PtrFunc deletor, T* p )
    : deletefunc_( deletor )
    , setfunc_( setfunc )
{
    this->set(p);
}


template <class T> inline
void PtrManBase<T>::set( T* p, bool doerase )
{
    if ( setfunc_ && p )
	setfunc_(p);
    
    T* oldptr = ptr_.exchange(p);
    if ( doerase )
	deletefunc_( oldptr );
}


template <class T> inline
bool PtrManBase<T>::setIfNull( T* p )
{
    if ( ptr_.setIfEqual( p, 0 ) )
    {
	if ( setfunc_ && p )
	    setfunc_(p);
	return true;
    }

    return false;
}


template <class T> inline
PtrMan<T>::PtrMan( const PtrMan<T>& )
    : PtrManBase<T>( 0, deleteFunc, 0 )
{
    pErrMsg("Should not be called");
}


template <class T> inline
PtrMan<T>& PtrMan<T>::operator=( const PtrMan<T>& )
{
    PtrManBase<T>::set( 0, true );
    pErrMsg("Should not be called");
    return *this;
}


template <class T> inline
PtrMan<T>::PtrMan( T* p )
    : PtrManBase<T>( 0, deleteFunc, p )
{}


template <class T> inline
PtrMan<T>& PtrMan<T>::operator=( T* p )
{
    this->set( p );
    return *this;
}


template <class T> inline
ConstPtrMan<T>::ConstPtrMan( const ConstPtrMan<T>& )
    : PtrManBase<T>( 0, deleteFunc, 0 )
{
    pErrMsg("Should not be called");
}


template <class T> inline
ConstPtrMan<T>& ConstPtrMan<T>::operator=( const ConstPtrMan<T>& )
{
    PtrManBase<T>::set( 0, true );
    pErrMsg("Should not be called");
    return *this;
}


template <class T> inline
ConstPtrMan<T>::ConstPtrMan( const T* p )
    : PtrManBase<T>( 0, deleteFunc, const_cast<T*>(p) )
{}


template <class T> inline
ConstPtrMan<T>& ConstPtrMan<T>::operator=( const T* p )
{
    this->set( const_cast<T*>( p ) );
    return *this;
}


template <class T> inline
ArrPtrMan<T>::ArrPtrMan( const ArrPtrMan<T>& )
    : PtrManBase<T>( 0, deleteFunc, 0 )
{
    pErrMsg("Should not be called");
}


template <class T> inline
ArrPtrMan<T>& ArrPtrMan<T>::operator=( const ArrPtrMan<T>& )
{
    PtrManBase<T>::set( 0, true );
    pErrMsg("Should not be called");
    return *this;
}


template <class T> inline
ArrPtrMan<T>::ArrPtrMan( T* p )
    : PtrManBase<T>( 0, deleteFunc, p )
{}


template <class T> inline
ArrPtrMan<T>& ArrPtrMan<T>::operator=( T* p )
{
    this->set( p );
    return *this;
}


template <class T> inline
ConstArrPtrMan<T>::ConstArrPtrMan( const ConstArrPtrMan<T>& p )
    : PtrManBase<T>( 0, deleteFunc, 0 )
{
    pErrMsg("Shold not be called");
}


template <class T> inline
ConstArrPtrMan<T>::ConstArrPtrMan( const T* p )
    : PtrManBase<T>( 0, deleteFunc, const_cast<T*>(p) )
{}


template <class T> inline
ConstArrPtrMan<T>& ConstArrPtrMan<T>::operator=( const T* p )
{
    this->set( const_cast<T*>(p) );
    return *this;
}


template <class T> inline
RefMan<T>::RefMan( const RefMan<T>& p )
    : PtrManBase<T>( ref, unRef, p.ptr() )
{}

    
template <class T> inline
RefMan<T>::RefMan( T* p )
    : PtrManBase<T>( ref, unRef, p )
{}


template <class T> inline
RefMan<T>& RefMan<T>::operator=( const RefMan<T>& p )
{
    this->set( p.ptr() );
    return *this;
}


template <class T> inline
ConstRefMan<T>::ConstRefMan( const ConstRefMan<T>& p )
    : PtrManBase<T>( ref, unRef, const_cast<T*>(p.ptr()) )
{}

    
template <class T> inline
ConstRefMan<T>::ConstRefMan( const T* p )
    : PtrManBase<T>( ref, unRef, const_cast<T*>(p) )
{}


template <class T> inline
ConstRefMan<T>& ConstRefMan<T>::operator=( const ConstRefMan<T>& p )
{
    this->set( const_cast<T*>(p.ptr()) );
    return *this;
}


template <class T> inline
ConstRefMan<T>&	ConstRefMan<T>::operator=(const T* p)
{
    this->set( const_cast<T*>( p ) );
    return *this;
}

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef qfilesystemcomm_h
#define qfilesystemcomm_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Nanne Hemstra
 Date:          March 2009
 RCS:           $Id: qfilesystemcomm.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include <QFileSystemWatcher>
#include "filesystemwatcher.h"

QT_BEGIN_NAMESPACE

/*!
\brief QFileSystemWatcher communication class

  Internal object, to hide Qt's signal/slot mechanism.
*/

class QFileSystemWComm : public QObject 
{
    Q_OBJECT
    friend class	::FileSystemWatcher;

protected:

QFileSystemWComm( QFileSystemWatcher* qfswatcher, FileSystemWatcher* fswatcher )
    : qfswatcher_(qfswatcher)
    , fswatcher_(fswatcher)
{
    connect( qfswatcher, SIGNAL(directoryChanged(const QString&)),
	     this, SLOT(directoryChanged(const QString&)) );
    connect( qfswatcher, SIGNAL(fileChanged(const QString&)),
	     this, SLOT(fileChanged(const QString&)) );
}

private slots:

void directoryChanged( const QString& path )
{
    fswatcher_->chgddir_ = path.toLatin1().constData();
    fswatcher_->directoryChanged.trigger( *fswatcher_ );
}

void fileChanged( const QString& fnm )
{
    fswatcher_->chgdfile_ = fnm.toLatin1().constData();
    fswatcher_->fileChanged.trigger( *fswatcher_ );
}

private:

    QFileSystemWatcher*		qfswatcher_;
    FileSystemWatcher*		fswatcher_;

};

QT_END_NAMESPACE

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef qptr_h
#define qptr_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          Nov 2012
 RCS:           $Id: qptr.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "commondefs.h"

class NotifierAccess;
class i_QPtrImpl;
namespace  Threads { class Mutex; }

mFDQtclass(QObject);

/*!
\brief Class with a pointer to a QObject. The pointer will be set to null
when the QObject goes out of scope.
*/

mExpClass(Basic) QObjPtr
{
public:
				QObjPtr(mQtclass(QObject)* = 0);
				~QObjPtr();

				operator mQtclass(QObject)*();
				operator const mQtclass(QObject)*() const;
    mQtclass(QObject*)		operator->();
    const mQtclass(QObject*)	operator->() const;
    
    mQtclass(QObject)*		operator=(mQtclass(QObject)*);

    Threads::Mutex&		mutex();
    
    NotifierAccess&		deleteNotifier();

protected:

    i_QPtrImpl*		impl_;
};


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef qtimercomm_h
#define qtimercomm_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Nanne Hemstra
 Date:          March 2009
 RCS:           $Id: qtimercomm.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include <QTimer>
#include "timer.h"

QT_BEGIN_NAMESPACE

/*!
\brief QTimer communication class

  Internal object, to hide Qt's signal/slot mechanism.
*/

class QTimerComm : public QObject 
{
    Q_OBJECT
    friend class	::Timer;

protected:

QTimerComm( QTimer* qtimer, Timer* timer )
    : qtimer_(qtimer)
    , timer_(timer)
    , magic_( 0xdeadbeef )
{
    connect( qtimer, SIGNAL(timeout()), this, SLOT(timeout()) );
}

public:

virtual	~QTimerComm()
{ deactivate(); }


void deactivate() 
{
    if ( qtimer_ && magic_ == 0xdeadbeef ) 
	qtimer_->stop();

    qtimer_ = 0;
    timer_ = 0;
    magic_ = 0;
}

private slots:

void timeout()
{ 
    if ( timer_ && magic_ == 0xdeadbeef ) 
	timer_->notifyHandler();
}

private:

    QTimer*		qtimer_;
    Timer*		timer_;
    unsigned int 	magic_;

};

QT_END_NAMESPACE

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef queue_h
#define queue_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Lammertink
 Date:		March 2004
 RCS:		$Id: queue.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________*_______________________________________________________

-*/

#include "thread.h"


/*!
\brief One single queue entry.
*/

template <class T>
mClass(Basic) QueueEntry
{
public:
			QueueEntry( T item )
			    : value( item ), next( 0 ) {}

    T			value;
    QueueEntry<T>*	next;
};


/*!
\brief Queue of objects.
*/

template <class T>
mClass(Basic) ObjQueue
{
public:
			ObjQueue() : head(0), tail(0) {}

			//! item becomes MINE!
    void		add( T* item ) 
			{
			    mutex.lock();
			    if ( !tail )
				head = tail = new QueueEntry<T*>( item );
			    else
			    {
				tail->next = new QueueEntry<T*>( item );
				tail = tail->next;
			    }
			    mutex.unLock();
			}

			//! becomes YOURS!
    T*			next() 
			{
			    if ( !head ) return 0;

			    mutex.lock();

			    T* value = head->value;

			    QueueEntry<T*>* old = head;
			    head = head->next;
			    delete old;

			    if ( !head ) tail = 0;

			    mutex.unLock();

			    return value;
			}
protected:

    Threads::Mutex	mutex;

    QueueEntry<T*>*	head;
    QueueEntry<T*>*	tail;

};


/*!
\brief Queue of basic data types.
*/

template <class T>
mClass(Basic) TypeQueue
{
public:
			TypeQueue() : head(0), tail(0) {}

    void		add( T item ) 
			{
			    mutex.lock();
			    if ( !tail )
				head = tail = new QueueEntry<T>( item );
			    else
			    {
				tail->next = new QueueEntry<T>( item );
				tail = tail->next;
			    }
			    mutex.unLock();
			}

    bool		empty()		{ return !head; }

    T			next() 
			{
			    if ( empty() ) return 0;

			    mutex.lock();

			    T value = head->value;

			    QueueEntry<T>* old = head;
			    head = head->next;
			    delete old;

			    if ( !head ) tail = 0;

			    mutex.unLock();

			    return value;
			}
protected:

    Threads::Mutex	mutex;

    QueueEntry<T>*	head;
    QueueEntry<T>*	tail;

};

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef ranges_h
#define ranges_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		23-10-1996
 Contents:	Ranges
 RCS:		$Id: ranges.h 30531 2013-07-03 08:23:21Z salil.agarwal@dgbes.com $
________________________________________________________________________

-*/

#include "general.h"
#include "errh.h"
#include "ptrman.h"


template <class T> class Interval;

/*!
\brief Base class for Interval. Has no virtual functions and can hence be
used in places where no virtual functions are allowed (e.g. large memcpy
operations. Does not have sort, clone and scale functions. If you need then,
use the Interval<T> instead.
*/

template <class T>
mClass(Basic) BasicInterval
{
public:
    inline			BasicInterval();
    inline			BasicInterval(const T& start,const T& stop);
    inline BasicInterval<T>&	operator=(const BasicInterval<T>&);
    
    inline void			set(const T& start,const T& stop);
    inline bool			isEqual(const BasicInterval<T>& i,
					const T& eps) const;
    inline bool			operator==(const BasicInterval<T>&) const;
    inline bool			operator!=(const BasicInterval<T>&) const;
    inline BasicInterval<T>	operator+(const BasicInterval<T>&) const;
    inline BasicInterval<T>&	operator+=(const BasicInterval<T>&);
    template <class X>
    const BasicInterval<T>&	setFrom(const BasicInterval<X>&);
    
    inline T			width(bool allowrev=true) const;
    inline T			center() const;
    inline float		getfCenter() const;
    inline void			shift(const T& len);
    inline void			widen(const T& len,bool allowrev=true);
    
    inline T			atIndex(int,const T& step) const;
    template <class X>
    inline int			getIndex(const X&,const T& step) const;
    template <class X>
    inline float		getfIndex(const X&,const T& step) const;
    template <class X>
    inline int			nearestIndex(const X& x,const T& step) const;
    template <class X>
    inline int			indexOnOrAfter(X x,const T& step,
					       float eps=1e-5) const;
    template <class X>
    inline void			limitTo( const BasicInterval<X>& i )
				{ start = i.limitValue(start);
				  stop  = i.limitValue(stop); }
    template <class X>
    inline X			limitValue(const X&) const;
    
    template <class X>
    inline bool			overlaps(const BasicInterval<X>&,
					 bool allrev=true) const;
    template <class X>
    inline bool			includes(const X&, bool allowrev ) const;
    template <class X>
    inline bool			includes(const BasicInterval<X>&,
					 bool allowrev=true) const;
    template <class X>
    inline bool			includes(const Interval<X>&,
					 bool allowrev=true) const;
    
    template <class X>
    inline float        	pos(X val,bool limit=true,
				    bool allowrev=true) const;
				/*!<\returns a value between 0 and 1 if val is
				 between start and stop. */
    inline void			include(const T&, bool allowrev=true);
    inline void			include(const BasicInterval<T>&,
					bool allowrev=true);
    
    T				start;
    T				stop;
    
    static BasicInterval<T>	udf(){return BasicInterval<T>(mUdf(T),mUdf(T));}
    
    inline bool			isRev() const		{ return start > stop; }
};


/*!
\brief Interval of values.

  Note that start does not need to be lower than stop. That's why there is a
  sort() method.
*/

template <class T>
mClass(Basic) Interval : public BasicInterval<T>
{
public:
    inline		Interval() : BasicInterval<T>() 		{}
    inline virtual	~Interval()					{}
    inline		Interval(const T& start,const T& stop);
    inline		Interval(const BasicInterval<T>& b );
    inline
    virtual Interval<T>* clone() const;
    
    virtual bool inline	isUdf() const;

    inline virtual void	scale(const T&);

    virtual void	sort( bool asc=true );

    virtual bool	hasStep() const			{ return false; }
    static Interval<T>	udf()      {return Interval<T>(mUdf(T),mUdf(T));}
};


typedef Interval<int>	SampleGate;
typedef Interval<float> ZGate;


#define cloneTp	mPolyRet( Interval<T>, StepInterval<T> )

/*!
\brief Interval with step.
*/

template <class T>
mClass(Basic) StepInterval : public Interval<T>
{
public:

    inline		StepInterval();
    inline		StepInterval(const T& start,const T& stop,
				     const T& step);
    inline		StepInterval(const Interval<T>&);
    inline		StepInterval( const StepInterval<T>& si )
			: Interval<T>(si), step(si.step)	{}
    inline StepInterval<T>& operator=(const Interval<T>&);

    virtual bool inline	isUdf() const;
    static StepInterval<T> udf()
			{return StepInterval<T>(mUdf(T),mUdf(T),mUdf(T));}

    virtual bool	hasStep() const		{ return true; }

    inline
    virtual cloneTp*	clone() const;
    inline void		set(const T& start,const T& stop,const T& step);

    template <class X>
    const StepInterval<T>& setFrom(const Interval<X>&);

    inline bool		isEqual(const StepInterval<T>& i,const T& eps) const;
    inline bool		operator==(const StepInterval<T>&) const;
    inline bool		operator!=(const StepInterval<T>&) const;
    inline T		atIndex(int) const;
    template <class X>
    inline int		getIndex(const X&) const;
    template <class X> inline
    int			indexOnOrAfter( X x, float eps ) const;

    template <class X>
    inline float	getfIndex(const X&) const;
    template <class X>
    inline int		nearestIndex(const X&) const;
    template <class X>
    inline T		snap(const X&) const;

    inline int		nrSteps() const;
    inline float	nrfSteps() const;
    virtual inline void	sort(bool asc=true);
    inline void		scale(const T&);
    inline T		snappedCenter() const;

    inline bool		isCompatible(const StepInterval<T>&,
	    			     float eps=mDefEps) const;
			/*!< epsilon refers to the steps,
			  	i.e eps=0.1 allows b to be 0.1 steps apart.
			*/
    inline T		snapStep(const T& inpstep) const;
    			/*!<Snaps inpstep to a positive multiple of step. */

     T			step;

};


/*!
\brief Class to store ranges in N dimensions. 
*/

template <class T>
mClass(Basic) IntervalND
{
public:
    				IntervalND( int ndim_ )
				    : ranges (new Interval<T>[ndim_] )
				    , ndim( ndim_ )
				    , isset( false ) {}

    virtual			~IntervalND() { delete [] ranges; }

    int				nDim() const { return ndim; }
    bool			isSet() const { return isset; }

    const Interval<T>&		getRange(int dim) const { return ranges[dim]; }
    template <class X> inline
    void 			setRange(const X& val);
    template <class X> inline
    void			setRange(const X& start,const X& stop);
    template <class X> inline
    void			include(const X& val);

    template <class X> inline
    bool			includes(const X& val,bool allowrev) const;
    inline bool			intersects(const IntervalND<T>&,
	    				   bool allowrev) const;

protected:

    int			ndim;
    Interval<T>*	ranges;
    bool		isset;

};


#include "samplingdata.h"


template <class T> template <class X> inline
void IntervalND<T>::setRange( const X& val )
{
    for ( int dim=0; dim<ndim; dim++ )
	ranges[dim].start = ranges[dim].stop = (T) val[dim];

    isset = true;
}



template <class T> template <class X> inline
void IntervalND<T>::setRange( const X& start, const X& stop)
{
    for ( int dim=0; dim<ndim; dim++ )
    {
	ranges[dim].start = start[dim];
	ranges[dim].stop = stop[dim];
    }

    isset = true;
}


template <class T> template <class X> inline
void IntervalND<T>::include( const X& val )
{
#ifdef __debug__
    if ( !isset )
	pErrMsg("Doing include on undefined IntervalND");
#endif

    for ( int dim=0; dim<ndim; dim++ )
	ranges[dim].include((T) val[dim]);

    isset = true;
}


template <class T> template <class X> inline
bool IntervalND<T>::includes( const X& val, bool allowrev ) const
{
#ifdef __debug__
    if ( !isset )
    {
	pErrMsg("Doing includes on undefined IntervalND");
	return false;
    }
#endif

    for ( int dim=0; dim<ndim; dim++ )
    {
	if ( !ranges[dim].includes(val[dim], allowrev ) )
	    return false;
    }

    return true;
}


template <class T> inline
bool IntervalND<T>::intersects( const IntervalND<T>& b, bool allowrev ) const
{
    if ( !isset || !b.isset || ndim!=b.ndim)
    {
	pErrMsg("Invalid intersection");
	return false;
    }

    ArrPtrMan<T> vector = new T [ndim];
    ArrPtrMan<bool> isstart = new bool [ndim];
    for ( int dim=0; dim<ndim; dim++ )
    {
	vector[dim] = ranges[dim].start;
	isstart[dim] = true;
    }

    do
    {
	if ( b.includes((T*)vector, allowrev ) )
	    return true;

	int dim = 0;
	while ( dim<ndim )
	{
	    if ( isstart[dim] )
	    {
		isstart[dim] = false;
		vector[dim] = ranges[dim].stop;
		break;
	    }
	    else
	    {
		isstart[dim] = true;
		vector[dim] = ranges[dim].start;
		dim++;
	    }
	}

	if ( dim==ndim )
	    break;

    } while ( true );


    return false;
}


template <class T1,class T2>
inline void assign( Interval<T1>& i1, const Interval<T2>& i2 )
{
    i1.start = (T1)i2.start;
    i1.stop = (T1)i2.stop;
    mDynamicCastGet(StepInterval<T1>*,si1,&i1)
    mDynamicCastGet(const StepInterval<T2>*,si2,&i2)
    if ( si1 && si2 )
	si1->step = (T1)si2->step;
}

template <class T1,class T2>
inline void assign( StepInterval<T1>& i1, const StepInterval<T2>& i2 )
{ i1.start = (T1)i2.start; i1.stop = (T1)i2.stop; i1.step = (T1)i2.step; }



// ---------------- BasicInterval ---------------------

template <class T>
inline BasicInterval<T>&
BasicInterval<T>::operator=( const BasicInterval<T>& intv )
{ start = intv.start; stop = intv.stop; return *this; }

template <class T> template <class X> inline
int BasicInterval<T>::nearestIndex( const X& x, const T& step ) const
{
    return SamplingData<T>( start, step ).nearestIndex( x );
}


template <class T>
template <class X> inline
int BasicInterval<T>::indexOnOrAfter( X x, const T& step, float eps ) const
{
    return SamplingData<T>( start, step ).indexOnOrAfter( x, eps );
}


template <class T> inline BasicInterval<T>::BasicInterval()
{ start = 0; stop = 0; }


template <class T> inline
BasicInterval<T>::BasicInterval( const T& t1, const T& t2 )
{ start = t1; stop = t2; }

template <class T> inline
Interval<T>* Interval<T>::clone() const		
{ return new Interval<T>( *this ); }


template <class T> inline
void BasicInterval<T>::set( const T& t1, const T& t2 )
{ start = t1; stop = t2; }


template <class T> inline
bool BasicInterval<T>::isEqual( const BasicInterval<T>& i, const T& eps ) const
{ return mIsEqual(start,i.start,eps) && mIsEqual(stop,i.stop,eps); }


template <class T> inline
bool BasicInterval<T>::operator==( const BasicInterval<T>& i ) const
{ return start == i.start && stop == i.stop; }


template <class T> inline
bool BasicInterval<T>::operator!=( const BasicInterval<T>& i ) const
{ return ! (i == *this); }


template <class T> inline
BasicInterval<T> BasicInterval<T>::operator+( const BasicInterval<T>& i ) const
{ return Interval<T>(start+i.start, stop+i.stop); }

template <class T> inline
BasicInterval<T>& BasicInterval<T>::operator+=( const BasicInterval<T>& i )
{ start += i.start; stop += i.stop; return *this; }


template <class T> template <class X> inline
const BasicInterval<T>& BasicInterval<T>::setFrom( const BasicInterval<X>& i )
{
    start = (T) i.start;
    stop = (T) i.stop;
    return *this;
}


template <class T> inline
T BasicInterval<T>::width( bool allowrev ) const
{ return allowrev && isRev() ? start - stop : stop - start; }

#define mCenterImpl(func,typ) \
template <class T> inline  \
typ BasicInterval<T>::func() const \
{ return ((typ)(start+stop))/2; }

mCenterImpl(center, T )
mCenterImpl(getfCenter, float )

#undef mCenterImpl


template <class T> inline
void BasicInterval<T>::shift( const T& len )
{ start += len; stop += len; }


template <class T> inline
void BasicInterval<T>::widen( const T& len, bool allowrev )
{
    if ( allowrev && isRev() )
	{ start += len; stop -= len; }
    else
	{ start -= len; stop += len; }
}


template <class T> template <class X> inline
bool BasicInterval<T>::includes( const X& t, bool allowrev ) const
{
    return allowrev && isRev()
	? t>=stop && start>=t
	: t>=start && stop>=t;
}


template <class T> template <class X> inline
bool BasicInterval<T>::includes( const BasicInterval<X>& t, bool allowrev ) const
{
    return includes( t.start, allowrev ) && includes( t.stop, allowrev );
}


template <class T> template <class X> inline
bool BasicInterval<T>::includes( const Interval<X>& t, bool allowrev ) const
{
    return BasicInterval<T>::includes( static_cast<BasicInterval>( t ));
}


template <class T> template <class X> inline
float BasicInterval<T>::pos( X val, bool limit, bool allowrev ) const
{
    float res = allowrev && isRev()
	? (val-stop)/(start-stop)
	: (val-start)/(stop-start);

    if ( limit )
    {
	if ( res<0 ) res = 0;
	else if ( res>1 ) res = 1;
    }

    return res;
}


template <class T> template <class X> inline
bool BasicInterval<T>::overlaps( const BasicInterval<X>& t,
				 bool allowrev ) const
{
    return includes( t.start, allowrev ) || includes( t.stop, allowrev ) ||
	   t.includes( start, allowrev ) || t.includes( stop, allowrev );
}


template <class T> inline
void BasicInterval<T>::include( const T& i, bool allowrev )
{
    if ( allowrev && isRev() )
	{ if ( stop>i ) stop=i; if ( start<i ) start=i; }
    else
	{ if ( start>i ) start=i; if ( stop<i ) stop=i; }
}


template <class T> inline
void BasicInterval<T>::include( const BasicInterval<T>& i, bool allowrev )
{ include( i.start, allowrev ); include( i.stop, allowrev ); }


template <class T> inline
T BasicInterval<T>::atIndex( int idx, const T& step ) const
{ return start + step * idx; }


template <class T> template <class X> inline
int BasicInterval<T>::getIndex( const X& t, const T& step ) const
{ return (int)(( t  - start ) / step); }


template <class T> template <class X> inline
float BasicInterval<T>::getfIndex( const X& t, const T& step ) const
{ return SamplingData<T>( start, step ).getfIndex( t ); }


template <class T> template <class X> inline
X BasicInterval<T>::limitValue( const X& t ) const
{
    const bool isrev = isRev();
    if ( (!isrev&&t>stop) || (isrev&&t<stop) ) return stop;
    if ( (!isrev&&t<start) || (isrev&&t>start) ) return start;
    return t;
}
		

// ---------------- Interval ------------------------

template <class T> inline
Interval<T>::Interval( const T& startval, const T& stopval )
    : BasicInterval<T>( startval, stopval )
{}


template <class T> inline
Interval<T>::Interval( const BasicInterval<T>& b )
    : BasicInterval<T>( b )
{}



template <class T> inline
void Interval<T>::sort( bool asc )
{
    if ( (asc && BasicInterval<T>::stop<BasicInterval<T>::start) ||
	 (!asc && BasicInterval<T>::start<BasicInterval<T>::stop) )
	Swap(BasicInterval<T>::start,BasicInterval<T>::stop);
}


template <class T> inline
void Interval<T>::scale( const T& factor )
{ BasicInterval<T>::start *= factor; BasicInterval<T>::stop *= factor; }


template <class T> inline
bool Interval<T>::isUdf() const
{
    return mIsUdf(BasicInterval<T>::start) || mIsUdf(BasicInterval<T>::stop);
}




// ---------------- StepInterval --------------------

template <class T>
StepInterval<T>::StepInterval()
{ step = 1; }


template <class T>
StepInterval<T>::StepInterval( const T& t1, const T& t2, const T& t3 )
    : Interval<T>(t1,t2)
{ step = t3; }


template <class T>
StepInterval<T>::StepInterval( const Interval<T>& intv )
    : Interval<T>(intv)
{ step = intv.hasStep() ? ((StepInterval<T>&)intv).step : 1; }

template <class T>
inline StepInterval<T>& StepInterval<T>::operator=( const Interval<T>& intv )
{ assign( *this, intv ); return *this; }


template <class T> inline
bool StepInterval<T>::isUdf() const
{
    return Interval<T>::isUdf() || mIsUdf(step);
}


template <class T> inline
cloneTp* StepInterval<T>::clone() const	
{ return new StepInterval<T>( *this ); }


template <class T> inline
void StepInterval<T>::set( const T& t1, const T& t2, const T& t3 )
{ Interval<T>::set( t1, t2 ); step = t3; }

template <class T> inline
bool StepInterval<T>::isEqual( const StepInterval<T>& i, const T& eps ) const
{ return Interval<T>::isEqual(i,eps) && mIsEqual(step,i.step,eps); }


template <class T> inline
bool StepInterval<T>::operator==( const StepInterval<T>& i ) const
{ return Interval<T>::operator==(i) && i.step==step; }


template <class T> inline
bool StepInterval<T>::operator!=( const StepInterval<T>& i ) const
{ return ! (i == *this); }


template <class T> template <class X> inline
const StepInterval<T>& StepInterval<T>::setFrom( const Interval<X>& i )
{
    Interval<T>::setFrom( i );
    if ( i.hasStep() )
	step = (T)(((const StepInterval<X>&)i).step);

    return *this;
}


template <class T> inline
T StepInterval<T>::atIndex( int idx ) const
{ return Interval<T>::atIndex(idx,step); }


template <class T> template <class X> inline
int StepInterval<T>::getIndex( const X& t ) const
{ return Interval<T>::getIndex( t, step ); }


template <class T> template <class X> inline
float StepInterval<T>::getfIndex( const X& t ) const
{ return Interval<T>::getfIndex( t, step ); }


template <class T> template <class X> inline
int StepInterval<T>::indexOnOrAfter( X x, float eps ) const
{
    return Interval<T>::indexOnOrAfter( x, step, eps );
}


template <class T> template <class X> inline
int StepInterval<T>::nearestIndex( const X& x ) const
{ return Interval<T>::nearestIndex( x, step ); }


template <class T> template <class X> inline
T StepInterval<T>::snap( const X& t ) const
{ return atIndex( nearestIndex( t ) ); }


template <class T> inline
void StepInterval<T>::sort( bool asc )
{
    Interval<T>::sort(asc);
    if ( (asc && step < 0) || (!asc && step > 0) )
	step = -step;
}

template <class T> inline
void StepInterval<T>::scale( const T& factor )
{
    Interval<T>::scale( factor );
    step *= factor;
}

template <class T> inline
T StepInterval<T>::snappedCenter() const
{ return snap( Interval<T>::center() ); }

template <class T> inline
T StepInterval<T>::snapStep( const T& inputstep ) const
{
    const float relstep = (float) inputstep/step;
    int nrsteps = mNINT32(relstep);
    if ( nrsteps<1 ) nrsteps = 1;
    return step*nrsteps;
}


template <class T> inline
float StepInterval<T>::nrfSteps() const
{
    const float w = Interval<T>::width( true );
    return w/step;
}


template <class T>
inline int StepInterval<T>::nrSteps() const
{
    if ( !step ) return 0;
    int ret = (((int)this->start) - this->stop) / step;
    return ret < 0 ? -ret : ret;
}

#define mDefFNrSteps(typ) \
template <> \
inline int StepInterval<typ>::nrSteps() const \
{ \
    if ( !step ) return 0; \
    typ ns = ( (start > stop ? start : stop) \
	    - (start > stop ? stop : start) ) \
	      / (step > 0 ? step : -step); \
    return mNINT32(ns); \
}

mDefFNrSteps(float)
mDefFNrSteps(double)

template <class T>
inline bool StepInterval<T>::isCompatible( const StepInterval<T>& b,
					   float ) const
{
    if ( step>b.step || b.step%step )
	return false;

    // const T diff = static_cast<const Interval<T>*>(this)->start - b.start;
    const T diff = this->start - b.start;
    return !(diff%step);
}


#define mDefFltisCompat(typ) \
template <> \
inline bool StepInterval<typ>::isCompatible( const StepInterval<typ>& b, \
			float eps ) const \
{ \
    const typ castedeps = (typ) eps; \
    if ( !mIsEqual(step,b.step, castedeps) ) return false; \
 \
    typ nrsteps = (start - b.start) / step; \
    int nrstepsi = mNINT32( nrsteps ); \
    typ diff = nrsteps - nrstepsi; \
    return ( (diff) < (castedeps) && (diff) > (-castedeps) ); \
}

mDefFltisCompat(float)
mDefFltisCompat(double)


#undef cloneTp

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef rcol_h
#define rcol_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		12-8-1997
 RCS:		$Id: rcol.h 32269 2013-11-05 05:23:17Z aneesh.tiwari@dgbes.com $
________________________________________________________________________

-*/

#include "gendefs.h"


/*Macros that implement functions on RowCol and BinID. */


#define mImplInlineRowColFunctions(clss, row, col) \
inline clss::clss( int r, int c ) : row(r), col(c) {}       \
inline clss::clss( const clss& rc ) : row(rc.row), col(rc.col) {}       \
inline clss::clss() : row( 0 ), col ( 0 )  {} \
inline bool clss::operator==(const clss& rc ) const \
	    { return row==rc.row && col==rc.col; }  \
inline bool clss::operator!=(const clss& rc ) const \
	    { return row!=rc.row || col!=rc.col; }  \
inline clss clss::operator+( const clss& rc ) const \
	    { return clss( row+rc.row, col+rc.col ); } \
inline clss clss::operator-( const clss& rc ) const \
	    { return clss( row-rc.row, col-rc.col ); } \
inline clss clss::operator+() const { return clss( +row, +col ); } \
inline clss clss::operator-() const { return clss( -row, -col ); } \
inline clss clss::operator*( const clss& rc ) const \
	    { return clss( row*rc.row, col*rc.col ); } \
inline clss clss::operator*( int factor ) const \
	    { return clss( row*factor, col*factor ); } \
inline clss clss::operator/( const clss& rc ) const \
	    { return clss( row/rc.row, col/rc.col ); } \
inline clss clss::operator/( int denominator ) const \
	    { return clss( row/denominator, col/denominator ); } \
inline const clss& clss::operator+=( const clss& rc ) \
	    { row += rc.row; col += rc.col; return *this; } \
inline const clss& clss::operator-=( const clss& rc ) \
	    { row -= rc.row; col -= rc.col; return *this; } \
inline const clss& clss::operator*=( const clss& rc ) \
	    { row *= rc.row; col *= rc.col; return *this; } \
inline const clss& clss::operator*=( int factor ) \
	    { row *= factor; col *= factor;  return *this; }  \
inline const clss& clss::operator/=( const clss& rc ) \
	    { row /= rc.row; col /= rc.col;  return *this; }  \
inline int& clss::operator[](int idx) { return idx==0 ? row : col; } \
inline int clss::operator[](int idx) const { return idx==0 ? row : col; } \
inline int clss::toInt32() const \
{ return (((unsigned int) row)<<16)+ ((unsigned int) col & 0xFFFF); } \
inline clss clss::fromInt32(int ll) \
{ return clss ( ll>>16, ((short)(ll&0xFFFF)) ); } \
inline od_int64 clss::toInt64() const \
{ \
    return (((od_uint64) row )<<32)+ \
	    ((od_uint64) col &  0xFFFFFFFF); \
} \
inline clss clss::fromInt64( od_int64 serialized ) \
{ \
    return clss( (od_int32) (serialized>>32), \
                 (od_int32) (serialized & 0xFFFFFFFF)); \
} \
 \
 \
inline int clss::sqDistTo( const clss& rc ) const \
{ \
    const int rdist = (row-rc.row); const int cdist = (col-rc.col); \
    return rdist*rdist+cdist*cdist; \
} \
 \
 \



#define mImplRowColFunctions(clss, row, col) \
void	clss::fill(char* str) const \
{ \
    if ( !str ) return; \
    sprintf( str, "%d/%d", row, col ); \
} \
 \
bool	clss::use(const char* str) \
{ \
    if ( !str || !*str ) return false; \
 \
    mDeclStaticString( buf ); buf = str; \
    char* ptr = strchr( buf.buf(), '/' ); \
    if ( !ptr ) return false; \
    *ptr++ = '\0'; \
    row = toInt( buf.buf() ); col = toInt( ptr ); \
    return true; \
} \
 \
bool clss::isNeighborTo( const clss& rc, const clss& step, \
		         bool eightconnectivity ) const \
{ \
    const clss diff(abs(row-rc.row),abs(col-rc.col)); \
    const bool areeightconnected = diff.row<=step.row && diff.col<=step.col && \
	                                 !(!diff.row && !diff.col); \
    if ( eightconnectivity ) \
	return areeightconnected; \
 \
    const int res = int(diff.row>0) + int(diff.col>0); \
    return areeightconnected && res<2; \
} \
 \
 \
od_int64 clss::getSerialized() const \
{ \
    static bool didwarn = false; \
    if ( !didwarn ) \
    { \
	pErrMsg("Legacy, use toInt64 instead" ); \
	didwarn = true; \
    } \
 \
    return toInt64(); \
} \
 \
 \
void clss::setSerialized(od_int64 ll) \
{ \
    static bool didwarn = false; \
    if ( !didwarn ) \
    { \
	pErrMsg("Legacy, use fromInt64 instead" ); \
	didwarn = true; \
    } \
 \
    fromInt64( ll ); \
}


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef rcol2coord_h
#define rcol2coord_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		9-4-1996
 Contents:	RowCol <-> Coord transform
 RCS:		$Id: rcol2coord.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/
 
#include "basicmod.h"
#include "position.h"
#include "rowcol.h"

template <class T> class StepInterval;

/*!
\brief Encapsulates linear transform from (i,j) index to (x,y) coordinates.
*/

mExpClass(Basic) RCol2Coord
{
public:

			RCol2Coord()		{}

    bool		isValid() const		{ return xtr.valid(ytr); }
    Coord		rowDir() const		{ return Coord(xtr.b,ytr.b); }
    Coord		colDir() const		{ return Coord(xtr.c,ytr.c); }
    Coord		transform(const RowCol&) const;
    Coord		transform(const BinID&) const;
    Coord		transform(const Coord& rc) const;
    			/*!< transforms a rowcol stored in a coord.  The 
			     row is stored in the x-component, and the
			     col is stored in the y-component. */
    BinID		transformBack(const Coord&,
	    			  const StepInterval<int>* inlrg=0,
	    			  const StepInterval<int>* crlrg=0 ) const;
			/*!< Transforms Coord to RowCol. If the ranges are
			     given, they are only used for snapping: the
			     actual range is not used */

    Coord		transformBackNoSnap(const Coord&) const;
    			/*!< transforms back, but does not snap. The 
			     row is stored in the x-component, and the
			     col is stored in the y-component. */


    bool		set3Pts(const Coord& c0,const Coord& c1,const Coord& c2,
	    			const RowCol& rc0,const RowCol& rc1,
				od_int32 col2 );
			/*!<Sets up the transform using three points.
			    \note that the third point is assumed to be on
			    the same row as the first point.
			*/
    bool		set3Pts(const Coord& c0,const Coord& c1,const Coord& c2,
	    			const BinID& bid0,const BinID& bid1,
				od_int32 crl2 );
			/*!<Sets up the transform using three points.
			    \note that the third point is assumed to be on
			    the same row as the first point.
			*/
    struct RCTransform
    {
			RCTransform()	{ a = b = c = 0; }

	inline double	det( const RCTransform& bct ) const
			{ return b * bct.c - bct.b * c; }
	inline bool	valid( const RCTransform& bct ) const
			{ double d = det( bct ); return !mIsZero(d,mDefEps); }

	double		a, b, c;
    };

    void		setTransforms(	const RCTransform& x,
					const RCTransform& y )
			{ xtr = x; ytr = y; }
    const RCTransform&	getTransform( bool x ) const
			{ return x ? xtr : ytr; }

protected:

    RCTransform		xtr;
    RCTransform		ytr;

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef refcount_h
#define refcount_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		13-11-2003
 Contents:	Basic functionality for reference counting
 RCS:		$Id: refcount.h 29278 2013-04-16 12:24:49Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "thread.h"
#include "objectset.h"
#include "errh.h"


template <class T> class ObjectSet;

#define mInvalidRefCount (-1)


/*!
\ingroup Basic
\page refcount Reference Counting
   Reference counter is an integer that tracks how many references have been
   made to a class. When a reference-counted object is created, the reference
   count is 0. When the ref() function is called, it is incremented, and when
   unRef() is called it is decremented. If it then reaches 0, the object is
   deleted.

\section example Example usage       
  A refcount class is set up by:
  \code
  class A
  {
     mRefCountImpl(A);
     public:
        //Your class stuff
  };
  \endcode

  This expands to a number of class variables and functions:
  \code
  public:
      void			A::ref() const;
      void			A::unRef() const;

      void			A::unRefNoDelete() const;

				//For debugging only Don't use
      bool			A::refIfReffed() const;

				//For debugging only Don't use
      int			A::nrRefs() const;
  private:
    virtual void		A::refNotify() const {}
    virtual void		A::unRefNotify() const {}
    virtual void		A::unRefNoDeleteNotify() const {}
    mutable ReferenceCounter	A::refcount_;
  protected:
    				A::~A();
  \endcode

  The macro will define a protected destructor, so you have to implement one
  (even if it's a dummy {}).

  If you don't want a destructor on your class use the mRefCountImplNoDestructor
  instead:

  \code
  class A
  {
      mRefCountImplNoDestructor(A);
  public:
          //Your class stuff
  };
  \endcode

\section unrefnodel unRefNoDelete
  The unRefNoDelete() is only used when you want to bring the class back to the
  original state of refcount==0. Such an example may be a static create
  function:
  
  \code
  A* createA()
  {
      A* res = new A;
      res->ref();		//refcount goes to 1
      fillAWithData( res );	//May do several refs, unrefs
      res->unRefNoDelete();	//refcount goes back to 0
      return res;
  }
  \endcode

\section sets ObjectSet with reference counted objects  
  ObjectSets with ref-counted objects can be modified by either:
  \code
  ObjectSet<RefCountClass> set:

  deepRef( set );
  deepUnRefNoDelete(set);
  deepRef( set );
  deepUnRef(set);

  \endcode

\section smartptr Smart pointers ot reference counted objects.
  A pointer management is handled by the class RefMan, which has the same usage
  as PtrMan.

\section localvar Reference counted objects on the stack
  Reference counted object cannot be used directly on the stack, as
  they have no public destructor. Instead, use the RefMan<A>:

  \code
      RefMan<A> variable = new A;
  \endcode
*/

//!\cond
#define mRefCountImplWithDestructor(ClassName, DestructorImpl, delfunc ) \
public: \
    void	ref() const \
		{ \
		    refcount_.ref(); \
		    refNotify(); \
		} \
    bool	refIfReffed() const \
		{ \
		    if ( !refcount_.refIfReffed() ) \
			return false; \
		    \
		    refNotify(); \
		    return true; \
		} \
    void	unRef() const \
		{ \
		    unRefNotify(); \
		    if ( refcount_.unRef() ) \
		    	delfunc; \
		    return; \
		} \
 \
    void	unRefNoDelete() const \
		{ \
    		    unRefNoDeleteNotify(); \
		    refcount_.unRefDontInvalidate(); \
		} \
    int		nrRefs() const { return refcount_.count(); } \
private: \
    virtual void		refNotify() const {} \
    virtual void		unRefNotify() const {} \
    virtual void		unRefNoDeleteNotify() const {} \
    mutable ReferenceCounter	refcount_;	\
protected: \
    		DestructorImpl; \
private:

//!\endcond

//!Macro to setup a class with destructor for reference counting
#define mRefCountImpl(ClassName) \
mRefCountImplWithDestructor(ClassName, virtual ~ClassName(), delete this; );

//!Macro to setup a class without destructor for reference counting
#define mRefCountImplNoDestructor(ClassName) \
mRefCountImplWithDestructor(ClassName, virtual ~ClassName() {}, delete this; );

//!Un-reference class pointer, and set it to zero. Works for null-pointers. 
template <class T> inline
void unRefAndZeroPtr( T*& ptr )
{
    if ( !ptr ) return;
    ptr->unRef();
    ptr = 0;
}


/*! Un-reference class pointer. Works for null pointers. */
template <class T> inline
void unRefPtr( const T* ptr )
{
    if ( !ptr ) return;
    ptr->unRef();
}

//! Reference class pointer. Works for null pointers.
template <class T> inline
void refPtr( const T* ptr )
{
    if ( !ptr ) return;
    ptr->ref();
}

mObjectSetApplyToAllFunc( deepUnRef, unRefPtr( os[idx] ), os.plainErase() )
mObjectSetApplyToAllFunc( deepRef, refPtr( os[idx] ), )


/*! Actual implementation of the reference counting. Normally not used by
    application developers. Use mRefCountImpl marcro instead. */

mClass(Basic) ReferenceCounter
{
public:
    inline void		ref();
    inline bool		unRef();
			/*!<Unref to zero will set it to an deleted state,
			 and return true. */
    
    inline void		unRefDontInvalidate();
			//!<Will allow it to go to zero
    
    od_int32		count() const { return count_.get(); }
    			//!<Don't use in production, for debugging
    inline bool		refIfReffed();
    			//!<Don't use in production, for debugging
    
private:
    
    Threads::Atomic<od_int32>	count_;
};


#ifdef __win__
# define mDeclareCounters	od_int32 oldcount = count_.get(), newcount = 0
#else
# define mDeclareCounters    	od_int32 oldcount = count_.get(), newcount;
#endif

inline void ReferenceCounter::ref()
{
    mDeclareCounters;

    do
    {
	if ( oldcount==mInvalidRefCount )
	{
	    pErrMsg("Invalid ref");
#ifdef __debug__
	    DBG::forceCrash(false);
#else
	    newcount = 1; //Hoping for the best
#endif
	}
	else
	{
	    newcount = oldcount+1;
	}
	
    } while ( !count_.weakSetIfEqual( newcount, oldcount ) );
}


inline bool ReferenceCounter::unRef()
{
    mDeclareCounters;

    do
    {
	if ( oldcount==mInvalidRefCount )
	{
	    pErrMsg("Invalid reference.");
#ifdef __debug__
	    DBG::forceCrash(false);
#else
	    return false;
#endif
	}
	else if ( oldcount==1 )
	    newcount = mInvalidRefCount;
	else
	    newcount = oldcount-1;
	
    } while ( !count_.weakSetIfEqual(newcount,oldcount ) );
    
    return newcount==mInvalidRefCount;
}


inline bool ReferenceCounter::refIfReffed()
{
    mDeclareCounters;

    do
    {
	if ( oldcount==mInvalidRefCount )
	{
	    pErrMsg("Invalid ref");
#ifdef __debug__
	    DBG::forceCrash(false);
#else
	    return false; //Hoping for the best
#endif
	}
	else if ( !oldcount )
	    return false;
	
	newcount = oldcount+1;
	
    } while ( !count_.weakSetIfEqual( newcount, oldcount ) );
    
    return true;
}


inline void ReferenceCounter::unRefDontInvalidate()
{
    mDeclareCounters;

    do
    {
	if ( oldcount==mInvalidRefCount )
	{
	    pErrMsg("Invalid reference.");
#ifdef __debug__
	    DBG::forceCrash(false);
#else
	    newcount = 0; //Hope for the best
#endif
	}
	else
	    newcount = oldcount-1;
	
    } while ( !count_.weakSetIfEqual(newcount,oldcount ) );
}

#undef mDeclareCounters


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef reflectivitymodel_h
#define reflectivitymodel_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Kristofer
 Date:		Jan 2011
 RCS:		$Id: reflectivitymodel.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "odcomplex.h"
#include "sets.h"


/*!
\brief A reflectivity spike.
*/

mClass(Basic) ReflectivitySpike
{
public:
    			ReflectivitySpike()
			    : reflectivity_( mUdf(float), mUdf(float) )
			    , time_( mUdf(float) )
			    , correctedtime_( mUdf(float) )
			    , depth_( mUdf(float) )
			{}
    
    inline bool		isDefined() const;

    inline bool		operator==(const ReflectivitySpike& s) const;
    inline bool		operator!=(const ReflectivitySpike& s) const;

    float_complex	reflectivity_;
    float		time_;
    float		correctedtime_; //!<Corrected for normal moveout
    float		depth_;
};


/*!\brief A table of reflectivies vs time and/or depth */

typedef TypeSet<ReflectivitySpike> ReflectivityModel;


//Implementations

inline bool ReflectivitySpike::operator==(const ReflectivitySpike& s) const
{
    return mIsEqualWithUdf( reflectivity_.real(),s.reflectivity_.real(),1e-5) &&
	   mIsEqualWithUdf( reflectivity_.imag(),s.reflectivity_.imag(),1e-5) &&
	   mIsEqualWithUdf( time_, s.time_, 1e-5 ) &&
	   mIsEqualWithUdf( correctedtime_, s.correctedtime_, 1e-5 ) &&
	   mIsEqualWithUdf( depth_, s.depth_, 1e-5 );
}

inline bool ReflectivitySpike::operator!=(const ReflectivitySpike& s) const
{ return !(*this==s); }


inline bool ReflectivitySpike::isDefined() const
{
    return !mIsUdf(reflectivity_) && !mIsUdf(time_) &&
	   !mIsUdf(correctedtime_) && !mIsUdf(depth_);
}

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef refpair_h
#define refpair_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		July 2011
 RCS:		$Id: refpair.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "gendefs.h"

/*!
\brief Defines a class holding a pair of references of different classes.
*/

#define mDefRefPairClass(clssnm,T1,membnm1,T2,membnm2) \
class clssnm \
{ \
public: \
 \
    inline		clssnm( T1& r1, T2& r2 ) \
				: r1_(&r1), r2_(&r2)		{} \
    inline		clssnm( clssnm& oth ) \
				: r1_(oth.r1_), r2_(oth.r2_)	{} \
 \
    inline clssnm&	operator =( clssnm& oth ) \
			{ r1_ = oth.r1_; r2_ = oth.r2_; return *this; } \
    inline clssnm&	operator =( T1& r ) \
			{ r1_ = &r; return *this; } \
    inline clssnm&	operator =( T2& r ) \
			{ r2_ = &r; return *this; } \
 \
    inline operator	T1&() const			{ return *r1_; } \
    inline operator	T2&() const			{ return *r2_; } \
 \
    inline T1&		membnm1() const			{ return *r1_; } \
    inline T2&		membnm2() const			{ return *r2_; } \
    void		set( T1& r )			{ r1_ = &r; } \
    void		set( T2& r )			{ r2_ = &r; } \
 \
    T1*			r1_; \
    T2*			r2_; \
 \
}


/*!
\brief Defines a class holding a pair of references of the same class.
*/

#define mDefRefPairSameClass(clssnm,T) \
class clssnm \
{ \
public: \
 \
    inline		clssnm( T& r1, T& r2 ) \
				: r1_(&r1), r2_(&r2)		{} \
    inline		clssnm( clssnm& oth ) \
				: r1_(oth.r1_), r2_(oth.r2_)	{} \
 \
    inline clssnm&	operator =( clssnm& oth ) \
			{ r1_ = oth.r1_; r2_ = oth.r2_; return *this; } \
 \
    inline T&		first() const			{ return *r1_; } \
    inline T&		second() const			{ return *r2_; } \
    void		setFirst( T& r )		{ r1_ = &r; } \
    void		setSecond( T& r )		{ r2_ = &r; } \
 \
    T*			r1_; \
    T*			r2_; \
 \
}


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef repos_h
#define repos_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		Nov 2004
 RCS:		$Id: repos.h 29431 2013-04-24 03:39:57Z mahant.mothey@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstring.h"

namespace Repos
{

    enum Source	{ Temp, Rel, ApplSetup, Data, Survey, User };

/*!
\brief Constructs repository file names.
 
  The basename is the name of a file in upper and lower case,
  e.g. UnitsOfMeasure.
  
  Then the files to find are:
  Temp: temp stor dir (/tmp on unix), file "UnitsOfMeasure"
  Rel: Software (release) dir, data subdir, file "UnitsOfMeasure"
  Appl: Application setup dir, data subdir, file "UnitsOfMeasure"
  Data: survey data root, file ".unitsofmeasure"
  Survey: survey directory, file ".unitsofmeasure"
  User: home/user dir, .od subdir, file "unitsofmeasure"

  The 'Temp' will not be visited by the 'next' iterator, it's more or less
  added for as an undef or initial value. When specifying reverse, the iterator
  will start at User.

  Usage example:

  Repos::FileProvider rfp( "UnitsOfMeasure" )
  while ( rfp.next() )
      addUnitsFromFile( rfp.fileName(), rfp.source() );
*/

mExpClass(Basic) FileProvider
{
public:

			FileProvider( const char* base_name, bool rev=false )
			: basenm_(base_name)
			, rev_(rev)		{ reset(); }

    bool		next()			{ return next(cursource_,rev_);}
    void		reset()			{ cursource_ = Temp; }
    Source		source() const		{ return cursource_; }
    BufferString	fileName() const	{ return fileName(cursource_); }

    BufferString	fileName(Source) const;
    static bool		next(Source&,bool rev=false);

protected:

    const BufferString	basenm_;
    Source		cursource_;
    bool		rev_;

    void		getFname(BufferString&,bool) const;

};


}; // namespace Repos

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef rounding_h
#define rounding_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		July 2012
 RCS:		$Id: rounding.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

Macros and inline functions for rounding floats and doubles.

Most applicaiton developers will only need to know mNINT32, mNINT64 or
mRounded which are found in commondefs.h.

-*/

#include "plfdefs.h"
#include "plftypes.h"

#ifdef __cpp__

template <class RT> inline
RT roundOff( double x ) { return (RT) ((x)>0 ? (x)+.5 : (x)-.5); }

template <class RT> inline
RT roundOff( float x ) { return (RT) ((x)>0 ? (x)+.5f : (x)-.5f); }

#endif

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef rowcol_h
#define rowcol_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		12-8-1997
 RCS:		$Id: rowcol.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "rcol.h"

template <class T> class TypeSet;
class BinID;

/*!
\brief Object with row and col. RowCol has most functions in common with
BinID, so template-based functions can be based on both classes.
*/

mExpClass(Basic) RowCol
{
public:
    inline			RowCol(int r,int c);
    inline			RowCol(const RowCol&);
				RowCol(const BinID&);
    inline			RowCol();

    inline bool			operator==(const RowCol&) const;
    inline bool			operator!=(const RowCol&) const;
    inline RowCol		operator+(const RowCol&) const;
    inline RowCol	 	operator-(const RowCol&) const;
    inline RowCol		operator+() const;
    inline RowCol		operator-() const;
    inline RowCol		operator*(const RowCol&) const;
    inline RowCol		operator*(int) const;
    inline RowCol		operator/(const RowCol&) const;
    inline RowCol		operator/(int) const;
    inline const RowCol&	operator+=(const RowCol&);
    inline const RowCol&	operator-=(const RowCol&);
    inline const RowCol&	operator*=(const RowCol&);
    inline const RowCol&	operator*=(int);
    inline const RowCol&	operator/=(const RowCol&);
    inline int&			operator[](int idx);
    inline int			operator[](int idx) const;
    void			fill(char*) const;
    bool			use(const char*);
    inline od_int64		toInt64() const;
    static inline RowCol	fromInt64(od_int64);
    inline int			toInt32() const;
    static inline RowCol	fromInt32(int);
    int				sqDistTo(const RowCol&) const;
    bool			isNeighborTo(const RowCol&,const RowCol&,
					     bool eightconnectivity=true) const;

    RowCol			getDirection() const;
    		/*!<\returns a rowcol where row/col are either -1, 0 or 1 where
		    depending on if row/col of the object is negative, zero or
		    positive. */

    float			angleTo(const RowCol&) const;
		/*!<\returns the smallest angle between the vector
		      going from 0,0 to the object and the vector
		      going from 0,0 to rc.*/
    float			clockwiseAngleTo(const RowCol& rc) const;
    		/*!<\returns the angle between the vector going from
		     0,0 to the object and the vector going from 0,0
		     to rc in the clockwise direction.*/
    float			counterClockwiseAngleTo(const RowCol&) const;
		/*!<\returns the angle between the vector going from
		      0,0 to the object and the vector going from 0,0
		      to rc in the counterclockwise direction.*/


    int				row;
    int				col;

    static const TypeSet<RowCol>&	clockWiseSequence();
    od_int64			getSerialized() const;
    				//!<Legacy. Use toInt64 instead.
    void			setSerialized(od_int64);
    				//!<Legacy. Use fromInt64 instead.
};


mImplInlineRowColFunctions(RowCol, row, col);

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef safefileio_h
#define safefileio_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		Nov 2004
 RCS:		$Id: safefileio.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstring.h"
#include "strmdata.h"
#include <iosfwd>


/*!
\brief Protects file IO when you can't afford to have partly written things
after write errors or have a file garbled by multiple access.
 
  Use the locking only when multiple processes can concurrently write to
  the same file. For most purposes, you won't need the locking, which is kind
  of expensive, too.

  Note that you can either read or write the file, not both at the same time.
  At the end, one of closeFail() or closeSuccess() is absolutely mandatory.
  Thus, when something goes wrong during writing, use closeFail(), otherwise
  use closeSuccess(). For writing, these do different things, and
  closeSuccess() can fail.

  When you write, you write to a new file, which will be renamed to the target
  filename on success (after the previous version is renamed to .bak).
  Note that success during writing (i.e. the integrity of the newly written
  file) is something you determine yourself.

  When you use locking, you sometimes need to re-read the original file before
  writing. In that case, you need to keep the lock that was made for the
  reading. There is where you want to use the 'ignorelock' and 'keeplock'
  flags. Otherwise, don't specify these.
*/

mExpClass(Basic) SafeFileIO
{
public:

			SafeFileIO(const char*,bool locked=false);

    bool		open(bool forread,bool ignorelock=false);
    const char*		errMsg() const		{ return errmsg_.str(); }
    std::istream&	istrm()			{ return *sd_.istrm; }
    std::ostream&	ostrm()			{ return *sd_.ostrm; }
    StreamData&		strmdata()		{ return sd_; }

    void		closeFail( bool keeplock=false )
			{ doClose( keeplock, false ); }
    bool		closeSuccess( bool keeplock=false )
			{ return doClose( keeplock, true ); }

    const char*		fileName() const	{ return filenm_.buf(); }

    // Some setup variables
    bool		usebakwhenmissing_;	//!< default=true
    bool		removebakonsuccess_;	//!< default=false
    int			lockretries_;		//!< default=10
    double		lockwaitincr_;		//!< default=0.5 (seconds)
    bool		allowlockremove_;	//!< default=true
    			//!< when true, will remove the lock after retries
    			//!< i.e. we'll assume the lock is phony then
    			//!< this is safety-- but robustness++

    bool		remove();

protected:

    const bool		locked_;
    const BufferString	filenm_;
    const BufferString	lockfnm_;
    const BufferString	bakfnm_;
    const BufferString	newfnm_;
    mutable BufferString errmsg_;
    StreamData		sd_;

    bool		openRead(bool);
    bool		openWrite(bool);
    bool		commitWrite();
    bool		doClose(bool, bool);

    bool		haveLock() const;
    bool		waitForLock() const;
    void		mkLock(bool);
    void		rmLock();
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef samplingdata_h
#define samplingdata_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		23-10-1996
 RCS:		$Id: samplingdata.h 32486 2013-11-20 10:42:26Z raman.singh@dgbes.com $
________________________________________________________________________

-*/

#include "commondefs.h"

template <class T> class StepInterval;

/*!
\brief Holds the fundamental sampling info: start and interval.
*/

template <class T>
mClass(Basic) SamplingData
{
public:

    inline				SamplingData(T sa=0,T se=1);
    inline				SamplingData(T x0,T y0,T x1,T y1);
    template <class FT>	inline		SamplingData(const SamplingData<FT>&);
    template <class FT>	inline		SamplingData(const StepInterval<FT>&);

    inline bool				operator==(const SamplingData&)const;
    inline bool				operator!=(const SamplingData&)const;

    template <class IT> inline StepInterval<T> interval(IT nrsamples) const;
    template <class FT> inline float	getfIndex(FT) const;
    template <class FT> inline int	nearestIndex(FT) const;
    template <class FT> inline int	indexOnOrAfter(FT,
						    float eps=mDefEps ) const;
    					//!\param eps is in number of samples.
    template <class IT> inline T	atIndex(IT) const;
    template <class FT> inline T	snap(FT) const;

    template <class FT>	inline void	set(FT,FT);
    template <class FT>	inline void	set(const SamplingData<FT>&);
    template <class FT>	inline void	set(const StepInterval<FT>&);
    inline void				scale(T);

    T					start;
    T					step;
};


template <class T> inline
SamplingData<T>::SamplingData( T sa, T se )
    : start(sa), step(se)
{}


template <class T> inline
SamplingData<T>::SamplingData( T x0, T y0, T x1, T y1 )
{
    step = (y1-y0) / (x1-x0);
    start = y0 - step*x0;
}


template <class T> 
template <class FT> inline
SamplingData<T>::SamplingData( const SamplingData<FT>& sd )
    : start( mCast(T,sd.start) ), step( mCast(T,sd.step) )
{}



#include "ranges.h"


template <class T>
template <class FT> inline
SamplingData<T>::SamplingData( const StepInterval<FT>& intv )
    : start(mCast(T,intv.start)), step(mCast(T,intv.step))
{}


template <class T> inline
bool SamplingData<T>::operator==( const SamplingData& sd ) const
{ return start == sd.start && step == sd.step; }

template <> inline
bool SamplingData<float>::operator==( const SamplingData<float>& sd ) const
{
    float val = start - sd.start;
    if ( !mIsZero(val,1e-6f) ) return false;
    val = 1 - (step / sd.step);
    return val < 1e-6f && val > -1e-6f;
}

template <> inline
bool SamplingData<double>::operator==( const SamplingData<double>& sd ) const
{
    double val = start - sd.start;
    if ( !mIsZero(val,1e-10) ) return false;
    val = 1 - (step / sd.step);
    return val < 1e-10 && val > -1e-10;
}


template <class T> inline
bool SamplingData<T>::operator!=( const SamplingData& sd ) const
{ return ! (sd == *this); }


template <class T>
template <class IT> inline
StepInterval<T> SamplingData<T>::interval( IT nrsamp ) const
{
    return nrsamp ? StepInterval<T>( start, start+(nrsamp-1)*step, step )
		  : StepInterval<T>( start, start, step ); }


template <class T>
template <class FT> inline
float SamplingData<T>::getfIndex( FT val ) const
{ return mIsZero(step,mDefEps) ? 0.f : (float) ((val-start) / step); }


template <class T>
template <class FT> inline
int SamplingData<T>::nearestIndex( FT x ) const
{ const float fidx = getfIndex(x); return mNINT32(fidx); }


template <class T>
template <class FT> inline
int SamplingData<T>::indexOnOrAfter( FT x, float eps ) const
{
    float fres = getfIndex( x );
    int res = (int) getfIndex(x);
    const float diff = fres-res;
    if ( diff>eps )
	res++;
    
    return res;
}


template <class T>
template <class FT> inline
T SamplingData<T>::snap( FT val ) const
{ return start + step * nearestIndex(val); }


template <class T>
template <class IT> inline
T SamplingData<T>::atIndex( IT idx ) const
{ return start + step * (T)idx; }

template <class T> 
template <class FT> inline
void SamplingData<T>::set( FT sa, FT se )
{ start = sa; step = se; }

template <class T> 
template <class FT> inline
void SamplingData<T>::set( const StepInterval<FT>& intv )
{ start = intv.start; step = intv.step; }

template <class T> 
template <class FT> inline
void SamplingData<T>::set( const SamplingData<FT>& sd )
{ start = sd.start; step = sd.step; }

template <class T> inline
void SamplingData<T>::scale( T scl )
{ start *= scl; step *= scl; }


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef selector_h
#define selector_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		18-10-1995
 Contents:	Selectors
 RCS:		$Id: selector.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "ranges.h"

/*!
\brief Interface for classes that select on basis of a key.

  Some Selectors may be extensible: you can ask them to include a key value.
*/

template <class T>
mClass(Basic) Selector
{
public:

    virtual		~Selector()				{}
    virtual const char*	selectorType() const			= 0;
    virtual bool	isOK() const				{ return true; }
    bool		isEqual( const Selector<T>& s ) const
			{
			    return selectorType() == s.selectorType()
				&& isEq(s);
			}
    virtual Selector<T>* clone() const				= 0;

    virtual bool	includes(const T&) const		= 0;
    virtual bool	canDoRange() const			{return false;}
    virtual char	includesRange(const T& start,
	    			      const T& stop) const	{ return -1; }
    			/*!<\retval 0 not at all
			    \retval 1 partly
			    \retval 2 completely */

    virtual bool	include(const T&,const char* =0)       { return false; }

private:

    virtual bool	isEq(const Selector<T>&) const		= 0;

};


/*!
\brief Selector selecting only a single value.
*/

template <class T>
mClass(Basic) SingleSelector : public Selector<T>
{
public:

			SingleSelector()			{}
			SingleSelector( const T& t ) : val_(t)	{}
    virtual const char*	selectorType() const		{ return "Single"; }
    virtual Selector<T>* clone() const
			{ return new SingleSelector( val_ ); }

    virtual bool	includes( const T& t ) const
			{ return val_ == t; }
    virtual bool	canDoRange() const			{return true;}
    virtual char	includesRange(const T& start,
	    			      const T& stop) const;
    virtual bool	include( const T& t, const char* )
			{ val_ = t; return true; }

    T			val_;

protected:

    virtual bool	isEq( const Selector<T>& ss ) const
			{ return val_ == ((const SingleSelector<T>&)ss).val_; }

};


/*!
\brief Selector based on range specification (an Interval).
*/

template <class T>
mClass(Basic) RangeSelector : public Selector<T>
{
public:

			RangeSelector()			{}
			RangeSelector( const T& t1, const T& t2 )
			: range_(t1,t2)			{}
    virtual const char*	selectorType() const		{ return "Range"; }
    virtual Selector<T>* clone() const
			{ return new RangeSelector(range_.start,range_.stop); }

    virtual bool	includes( const T& t ) const
			{ return range_.includes( t, true ); }
    virtual bool	include( const T& t, const char* )
			{ range_.include( t ); return true; }

    Interval<T>		range_;

protected:

    virtual bool	isEq( const Selector<T>& rs ) const
			{ return range_==((const RangeSelector<T>&)rs).range_; }

};


/*!
\brief Selector based on array.
*/

template <class T>
mClass(Basic) ArraySelector : public Selector<T>
{
public:

			ArraySelector()
			: vals_(0), sz_(0), valsmine_(true)	  {}
			ArraySelector( const T* v, int s )
			: vals_(v), sz_(s), valsmine_(false)	  {}
			ArraySelector( const ArraySelector& x )
			: vals_(x.vals_), sz_(x.sz_), valsmine_(false) {}
			~ArraySelector()
			{ if ( valsmine_ ) delete [] const_cast<T*>(vals_); }

    virtual const char*	selectorType() const		{ return "Array"; }
    virtual Selector<T>* clone() const
			{ return new ArraySelector( vals_, sz_ ); }

    virtual bool	includes( const T& t ) const
			{
			    for ( int idx=0; idx<sz_; idx++ )
				{ if ( vals_[idx] == t ) return true; }
			    return false;
			}
    void		manageVals( bool yn=true )	{ valsmine_ = yn; }

    const T*		vals_;
    int			sz_;

protected:

    virtual bool	isEq( const Selector<T>& ss ) const
			{
			    const ArraySelector<T>& ass
				= (const ArraySelector<T>&)ss;
			    if ( sz_ != ass.sz_ ) return false;
			    for ( int idx=0; idx<sz_; idx++ )
				{ if ( !ss.includes(vals_[idx]) ) return false;}
			    return true;
			}

    bool		valsmine_;

};


template <class T> inline
char SingleSelector<T>::includesRange( const T& start, const T& stop ) const
{
    const Interval<T> rg( start, stop );
    if ( start==stop==val_ )
	return 2;

    if ( rg.includes( val_, true ) )
	return 1;

    return 0;
}

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef separstr_h
#define separstr_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		May 1995
 Contents:	String with a separator between the items
 RCS:		$Id: separstr.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstring.h"
#include "fixedstring.h"
#include "convert.h"

class BufferStringSet;

/*!
\brief %List encoded in a string.

  SeparString is a list encoded in a string where the items are separated by
  a user chosen separator. The separator in the input is escaped with a
  backslash. A `\' is encoded as `\\' . Elements can have any size.  Input and
  output of elements is done unescaped. Input and output of whole (sub)strings
  is done escaped.
*/

mExpClass(Basic) SeparString
{
public:
			SeparString( const SeparString& ss )
			: rep_(ss.rep_) { initSep( ss.sep_[0] ); }

			SeparString( const char* escapedstr=0, char separ=',' )
			{ initSep( separ ); initRep( escapedstr ); } 

    SeparString&	operator=(const SeparString&);
    SeparString&	operator=(const char* escapedstr);

    inline bool		isEmpty() const		{ return rep_.isEmpty(); }
    inline void		setEmpty()		{ rep_.setEmpty(); }

    int			size() const;
    FixedString		operator[](int) const;		//!< Output unescaped
    FixedString		from(int) const;		//!< Output escaped

    int			getIValue(int) const;
    od_uint32		getUIValue(int) const;
    od_int64		getI64Value(int) const;
    od_uint64		getUI64Value(int) const;
    float		getFValue(int) const;
    double		getDValue(int) const;
    bool		getYN(int) const;

    int			indexOf(const char* unescapedstr) const;

    SeparString&	add(const BufferStringSet&);	//!< Concatenation
    SeparString&	add(const SeparString&);	//!< Concatenation
    SeparString&	add(const char* unescapedstr);		
    template <class T>
    SeparString&	add( T t )
			{ return add( toString(t) ); }

    template <class T>
    SeparString&	operator +=( T t )	{ return add( t ); }

    inline		operator const char*() const
						{ return buf(); }

    inline char*	buf()			{ return rep_.buf(); }
							//!< Output escaped
    inline const char*	buf() const		{ return rep_.buf(); }
							//!< Output escaped
    BufferString&	rep()			{ return rep_; }
							//!< Output escaped
    const BufferString&	rep() const		{ return rep_; }
							//!< Output escaped

    inline const char*	unescapedStr() const	{ return getUnescaped(buf()); }
    			/*!< Use with care! Distinction between separ-chars
			     and escaped separ-chars will get lost. */

    inline char		sepChar() const		{ return *sep_; }
    void		setSepChar(char);

private:

    char		sep_[2];
    BufferString	rep_;

    void		initRep(const char*);
    inline void		initSep( char s )	{ sep_[0] = s; sep_[1] = '\0'; }

    mutable BufferString retstr_;

    const char*		getEscaped(const char* unescapedstr,char sep) const;
    const char*		getUnescaped(const char* escapedstartptr,
				     const char* nextsep=0) const;

    const char*		findSeparator(const char*) const;
};

mGlobal(Basic) std::ostream& operator <<(std::ostream&,const SeparString&);
mGlobal(Basic) std::istream& operator >>(std::istream&,SeparString&);


/*!
\brief SeparString with backquotes as separators, use in most ascii files.
*/

mExpClass(Basic) FileMultiString : public SeparString
{
public:

			FileMultiString(const char* escapedstr=0)
			    : SeparString(escapedstr, separator() )	{} 
    template <class T>	FileMultiString( T t )
			    : SeparString(t, separator() )		{}

    static char		separator() { return '`'; }
    static const char*  separatorStr();

    // The function template overloading add(const SeparString&) in the base
    // class needs an exact match! Passing a derived object would make the
    // template function convert it to (const char*).
    FileMultiString&	add(const FileMultiString& fms)
			{ return add( (SeparString&)fms ); }
    template <class T>
    FileMultiString&	add( T t )
			{ SeparString::add( t ); return *this; }
    template <class T>
    FileMultiString&	operator +=( T t )		{ return add( t ); }

};

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef sets_h
#define sets_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Feb 2009
 RCS:		$Id: sets.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#ifndef typeset_h
# include "typeset.h"
#endif
#ifndef objectset_h
# include "objectset.h"
#endif


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef settings_h
#define settings_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		4-11-1995
 RCS:		$Id: settings.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#include "basicmod.h"
#include "iopar.h"


/*!
\brief Settings class holds the user settings. It is an IOPar.

  The common() settings are basic, global user settings.
  For a specific subject or from a plugin, just call fetch( yourkey ),
  and a new Settings instance will be made if necessary. You can provide
  defaults in a file yourkeySettings which must be located in OD's data
  subdirectory.

  The data is stored in ~/.od/settings (common) and ~/.od/settings_yourkey
  for other keys. If $DTECT_USER is set, '.$DTECT_USER' is appended to the
  filename.
*/

mExpClass(Basic) Settings : public IOPar
{
public:

    inline static Settings&	common() { return fetch(); }

    static Settings&		fetch(const char* settings_name=0);

    bool			write(bool read_before=true) const;
				//!< read_before should be true: this is the
    				//!< protection against another update being
    				//!< screwed by this one
    bool			reRead()	{ return doRead(false); }
				//!< Needed in case you know that the file has
    				//!< been changed by user or external routine.
    				//!< It's not likely that you'll need this.

    static Settings*		fetchExternal(const char* settings_name,
					      const char* dtect_user,
					      const char* usr_settings_dir);
    				//!< for sysadm purposes

protected:

				Settings( const char* fnm )
				    : fname(fnm)		{}
				~Settings()			{}

    FileNameString		fname;

    static Settings*		doFetch(const char*,const char*,const char*,
	    				bool);
    bool			doRead(bool);
};


mExternC( Basic ) const char* GetSettingsDataDir(void);


//!> macro for easy set to Settings::common()
#define mSettUse(fn,basekey,key,value) \
	Settings::common().fn( IOPar::compKey(basekey,key), value )
//!> macro for easy get from Settings::common()
#define mSettGet(basekey,key) \
	Settings::common()[ IOPar::compKey(basekey,key) ]
//!> macro for easy write of Settings::common()
#define mSettWrite() \
	Settings::common().write();

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef sharedlibs_h
#define sharedlibs_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Jun 2006
 RCS:		$Id: sharedlibs.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "gendefs.h"
#ifdef __win__
#   include "windows.h"
    typedef HMODULE Handletype;
#else
    typedef void* Handletype;
#endif


/*!
\brief Gives access to shared libs on runtime. Plugins should be loaded via the Plugin Manager (see plugins.h).
*/

mExpClass(Basic) SharedLibAccess
{
public:

    		SharedLibAccess(const char* file_name);
		//!< handle is only closed if you do it explicitly.
    bool	isOK() const		{ return handle_; }

    void	close();

    void*	getFunction(const char* function_name) const;
    		//!< Difficult for C++ functions as the names are mangled.

    Handletype	handle()		{ return handle_; }

    static void	getLibName(const char* modnm,char*);
    		//!< returns lib name with ".dll" or "lib" and ".so"/".dylib"

protected:

    Handletype	handle_;

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef sighndl_h
#define sighndl_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        A.H. Bril
 Date:          April 2001
 RCS:           $Id: sighndl.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "callback.h"
#include "ptrman.h"

namespace DBG { mGlobal(Basic) void forceCrash(bool); }

/*!
\brief Asynchronous event handling and notification.
*/

mExpClass(Basic) SignalHandling : public CallBacker
{
public:
    static void			initClass();
    
    enum EvType			{
				    ConnClose,
				    ChldStop,
				    ReInit,
				    Stop,
				    Cont,
				    Alarm,
				    Kill	// This process
				};

    static void			startNotify(EvType,const CallBack&);
    static void			stopNotify(EvType,const CallBack&);
    static void			stopProcess(int,bool friendly=true);
    static void			stopRemote( const char*,int, bool friendly=true,
					    const char* rshcomm=0 );
    static void			initFatalSignalHandling();

protected:

					SignalHandling();
    static SignalHandling&		SH();
    					/*!<Access to a static instance */

    CallBackSet				conncbs_;
    CallBackSet				chldcbs_;
    CallBackSet				reinitcbs_;
    CallBackSet				stopcbs_;
    CallBackSet				contcbs_;
    CallBackSet				alarmcbs_;
    CallBackSet				killcbs_;

    CallBackSet&			getCBL(EvType);

    static void				handle(int);

    void				doKill(int);
    void				doStop(int,bool withcbs=true);
    void				doCont();
    void				handleConn();
    void				handleChld();
    void				handleAlarm();
    void				handleReInit();


    friend void				DBG::forceCrash(bool);

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef staticsdesc_h
#define staticsdesc_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		May 2009
 RCS:		$Id: staticsdesc.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "multiid.h"

class IOPar;

/*!
\brief Specifies Statics as a horizon and either a horizon attribute or a
constant velocity. Velocity is always in m/s.
*/

mExpClass(Basic) StaticsDesc
{
public:
			StaticsDesc();

    MultiID		horizon_;
    float		vel_;
    BufferString	velattrib_;	//attrib on statichorizon_
    					//if empty, use vel

    bool		operator==(const StaticsDesc&) const;
    bool		operator!=(const StaticsDesc&) const;

    static void		removePars(IOPar&);
    void		fillPar(IOPar&) const;
    bool		usePar(const IOPar&);

    static const char*	sKeyHorizon();
    static const char*	sKeyVelocity();
    static const char*	sKeyVelocityAttrib();
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef staticstring_h
#define staticstring_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		Jan 2011
 RCS:		$Id: staticstring.h 32200 2013-10-31 09:07:11Z aneesh.tiwari@dgbes.com $
________________________________________________________________________
-*/


#include "basicmod.h"
#include "sets.h"
#include "thread.h"
#include "bufstringset.h"


/*!
\brief Class that keeps one static string per thread. This enables temporary
passing of static strings where needed.
*/

mExpClass(Basic) StaticStringManager
{
public:
    BufferString&		getString();

    				~StaticStringManager();
protected:

    BufferStringSet     	strings_;
    ObjectSet<const void>     	threadids_;
    Threads::Mutex		lock_;
};


#define mDeclStaticString(nm) \
    mDefineStaticLocalObject( StaticStringManager, nm##_ssm, ); \
    BufferString& nm = nm##_ssm.getString()

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef streamconn_h
#define streamconn_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		21-10-1995
 RCS:		$Id: streamconn.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/


#include "basicmod.h"
#include "conn.h"
#include "strmdata.h"


/*!
\brief Connection with an underlying iostream.
*/

mExpClass(Basic) StreamConn : public Conn
{
public:
			StreamConn();
			StreamConn(StreamData&);
				//!< MY stream: Input StreamData will be zero-ed
			StreamConn(std::istream*);
				//!< MY stream: I will delete on destruct
			StreamConn(std::ostream*);
				//!< MY stream: I will delete on destruct
			StreamConn(const char*,State);
				//!< MY stream: I will delete on destruct
			StreamConn(std::istream&,bool close_on_delete=false);
				//!< YOUR stream: I may close only
			StreamConn(std::ostream&,bool close_on_delete=false);
				//!< YOUR stream: I may close only

    virtual		~StreamConn();

    const std::istream&	iStream() const		{ return *sd_.istrm; }
    std::istream&	iStream()		{ return *sd_.istrm; }
    const std::ostream&	oStream() const		{ return *sd_.ostrm; }
    std::ostream&	oStream()		{ return *sd_.ostrm; }
    const StreamData&	streamData() const	{ return sd_; }
    StreamData&		streamData()		{ return sd_; }
    FILE*		fp() const		{ return sd_.filePtr(); }

    virtual State	state() const		{ return state_; }
    virtual bool	bad() const;
    void		clearErr();
    bool		doIO(void*,unsigned int nrbytes);
    void		close();

    const char*		fileName() const	{ return sd_.fileName(); }
    void		setFileName( const char* s ) { sd_.setFileName(s); }

    const char*		connType() const	{ return sType(); }
    bool		isStream() const	{ return true; }

    static const char*	sType()			{ return "Stream"; }	


private:

    StreamData		sd_;
    State		state_;
    bool		mine_;
    bool		closeondel_;

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef string2_h
#define string2_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		11-4-1994
 Contents:	Extra string functions
 RCS:		$Id: string2.h 32507 2013-11-21 07:00:15Z bert.bril@dgbes.com $
________________________________________________________________________
-*/

#include "basicmod.h"
#include "commondefs.h"

class BufferString;

/*!
\brief Advances given pointer to first non-whitespace.
*/

#define mSkipBlanks(ptr) \
    { if ( ptr ) { while ( *(ptr) && isspace(*(ptr)) ) (ptr)++; } }

/*!
\brief Advances given pointer to first whitespace.
*/

#define mSkipNonBlanks(ptr) \
    { if ( ptr ) { while ( *(ptr) && !isspace(*(ptr)) ) (ptr)++; } }

/*!
\brief Advances to first whitespace and removes trailing whitespace.
*/

#define mTrimBlanks(ptr) \
    { mSkipBlanks(ptr); removeTrailingBlanks(ptr); }



/*!> bluntly puts a '\0' on trailing white space. */
mGlobal(Basic) void removeTrailingBlanks(char*);


#ifndef __cpp__
# include "string2_c.h"
#else

#include "undefval.h"
#include "fixedstring.h"
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
/*!> stricmp with option to compare part, default is all */
mGlobal(Basic) bool caseInsensitiveEqual(const char*,const char*,int match_nrchars=-1);
/*!> checks whether a string is the start of another string. */
mGlobal(Basic) bool matchString(const char* startstring,const char* maybebigger);
/*!> is a case insensitive version of matchString */
mGlobal(Basic) bool matchStringCI(const char*,const char*);
mGlobal(Basic) bool stringEndsWith(const char* endstring,const char* maybebigger);
mGlobal(Basic) bool stringEndsWithCI(const char*,const char*);

//DEPRECATED - In 5.0, will be available as BufferString functions only
/*!> counts occurrences of a char in string
  (5.0: BufferString::count(char)) */
mGlobal(Basic) int countCharacter(const char*,char);
/*!> replaces all occurrences of a char with another
  (5.0: BufferString::replace(char,char)) */
mGlobal(Basic) void replaceCharacter(char*,char from,char to);
/*!> replaces all occurrences of a string with another
  (5.0: BufferString::replace(const char*,const char*)) */
mGlobal(Basic) void replaceString(char*,const char* from,const char* to);
/*!> removes all occurrences of a char
  (5.0: BufferString::remove(char)) */
mGlobal(Basic) void removeCharacter(char*,char);
/*!> Removes initial and trailing spaces and tabs
  (5.0: BufferString::trimBlanks()) */
mGlobal(Basic) void removeStartAndEndSpaces(char*);
/*!> Quotes a string.
  (5.0: BufferString::quote(char)) */
mGlobal(Basic) const char* quoteString(const char* str, char qt='"' );
/*!> Back-quotes a string.
  (5.0: BufferString::quote('`')) */
mGlobal(Basic) inline const char* backQuoteString(const char* str, char qt='"' )
{ return quoteString( str, '`' ); }

/*!> cleans a string from non-alpha numeric by replacing with underscores.
     params: allow whitespace, allow slashes, allow dots */
mGlobal(Basic) void cleanupString(char*,bool,bool,bool);
/*!> tells whether a string holds a parseable number */
mGlobal(Basic) bool isNumberString(const char*,bool int_only=false);
/*!> tells whether has printable characters only. */
mGlobal(Basic) bool isAlphaNumString(const char*,bool allowspace = false);

/*!> fills a buffer with the next word (delimited by whitespace) in string.
     It returns a ptr just after the word. */
mGlobal(Basic) const char* getNextWord(const char*,char*);

/*!> Fills string with string for an int.
     If you pass 0 for retbuf, then a static buffer is used. */
mGlobal(Basic) const char* getStringFromInt(od_int32,char* retbuf);
mGlobal(Basic) const char* getStringFromUInt(od_uint32,char* retbuf);
mGlobal(Basic) const char* getStringFromInt64(od_int64,char* retbuf);
mGlobal(Basic) const char* getStringFromUInt64(od_uint64,char* retbuf);

/*!> Normally, pass null for fmt. Then it will do removal of
     trailing zeros and use %lf in more cases than std.
     If you pass 0 for retbuf, then a static buffer is used (not MT safe). */
mGlobal(Basic) const char* getStringFromDouble(const char* fmt,double,
					       char* retbuf);

/*>Prints a double with the requested nr of digits.
    Use the returned string result immediately.*/
mGlobal(Basic) const char* getStringFromDouble(double,char* retbuf=0,
					       int nrdigits=15);

/*!> is like getStringFromDouble, with special %f treatment. */

mGlobal(Basic) const char* getStringFromFloat(const char* fmt,float,char* retbuf);

/*>Prints a float with the requested nr of digits.
	    Use the returned string result immediately.*/
mGlobal(Basic) const char* getStringFromFloat(float,char* retbuf=0,
					      int nrdigits=7);
/*!> removes unwanted zeros and dots from a floating point in string. */
mGlobal(Basic) void prettyNumber(char*,bool is_float);

/*!> returns ptr to static buffer with "yes" or "No". */
mGlobal(Basic) const char* getYesNoString(bool);
/*!> returns ptr to static buffer with "m" or "ft" */
mGlobal(Basic) const char* getDistUnitString(bool isfeet,bool withparentheses);

/*!> returns 1 or 0 by inspecting string */
mGlobal(Basic) int yesNoFromString(const char*);
/*!> returns "th" or "st" or "nd" or "rd"; like in 1st, 2nd, 3rd etc. */
mGlobal(Basic) const char* getRankPostFix(int);
/*!> returns a nicely, readable size, in bytes, KB, MB, GB, or TB */
mGlobal(Basic) const char* getBytesString(od_uint64);
/*!> returns a string for display, never larger than specified nr of chars */
mGlobal(Basic) const char* getLimitedDisplayString(const char*,int nrchars,
					    bool trimright);

/*!> Finds a string in string array, case insensitive */
mGlobal(Basic) int getIndexInStringArrCI(const char*,const char* const* arr,
				  int startnr=0,int nr_chars_to_match=0,
				  int notfoundidx=-1);

/*!>Returns a string with an area and its unit, depending on survey and
    area size, unit is ft^2, m^2, km^2 or mile^2. */
mGlobal(Basic) const char* getAreaString( float m2, bool parensonunit, char* str=0 );

// toString functions.
mGlobal(Basic) const char* toString( od_int32 i );
mGlobal(Basic) const char* toString( od_uint32 i );
mGlobal(Basic) const char* toString( od_int64 i );
mGlobal(Basic) const char* toString( od_uint64 i );
mGlobal(Basic) const char* toString( float f )	;
mGlobal(Basic) const char* toString( double d );
mGlobal(Basic) const char* toString( short i );
mGlobal(Basic) const char* toString( unsigned short i );
mGlobal(Basic) const char* toString( const char* str );
mGlobal(Basic) const char* toString( unsigned char c );
mGlobal(Basic) const char* toString( signed char c );
mGlobal(Basic) const char* toString( bool b );

/*!Converts integer with number of bytes to a string with KB, GB or similar
   unit. (5.0: gets its own header file nrbytes2string.h) */

mExpClass(Basic) NrBytesToStringCreator
{
public:
			NrBytesToStringCreator();
    enum Unit		{ Bytes=0, KB=1, MB=2, GB=3, TB=4, PB=5 };

    void		setUnitFrom(od_uint64 number,bool maximum=true);
			/*!<Sets the unit (B, KB, MB, GB, TB) based on the
			 number.
			 \param maximum will only change unit if a larger
			 unit is needed.
			 */

    FixedString		getString(od_uint64 number,int nrdecimals=2,
				  bool withunit=true) const;
			/*!<Use string before doing anything else, as it will be
			    overwritten at next call from same thread. */

    FixedString		getUnitString() const;
    static FixedString	toString(Unit);

protected:
    Unit		unit_;
};


#define mImplGetFromStrFunc( type, func, udfv ) \
inline bool getFromString( type& i, const char* s, type undef=udfv ) \
{ \
    if ( s && *s ) \
    { \
	char* e; \
	i = (type)func; \
	if ( e==s ) \
	{ \
	    i = undef; \
	    return false;\
	}\
	return true; \
    } \
 \
    i = undef; \
    return false; \
}



// inline bool getFromString( double& d, const char* s, double udefval );
mImplGetFromStrFunc(double, strtod(s,&e), mUdf(double) )
// inline bool getFromString( float& d, const char* s, float udefval );
mImplGetFromStrFunc(float, strtod(s,&e), mUdf(float) )
// inline bool getFromString( int& d, const char* s, int udefval );
mImplGetFromStrFunc(int, strtol(s,&e,10), mUdf(int) )
#undef mImplGetFromStrFunc

mGlobal(Basic) bool getFromString(BufferString&,const char*);

inline bool getFromString( bool& b, const char* s )
{
    if ( s )
    {
	b = ( yesNoFromString( s ) ? true : false );
	return true;
    }

    b = false;
    return false;
}

inline bool toBool( const char* s, bool defval=true )
{
    return s && *s ? yesNoFromString(s) : defval;
}

inline float toFloat( const char* s, float defval=0 )
{
    float ret = defval; getFromString( ret, s, ret ); return ret;
}

inline double toDouble( const char* s, double defval=0 )
{
    double ret = defval; getFromString( ret, s, ret ); return ret;
}

inline int toInt( const char* s, int defval=0 )
{
    int ret = defval; getFromString( ret, s, ret ); return ret;
}


#endif


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef string2_c_h
#define string2_c_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Jan 2011
 Contents:	Remainder of string2.h that has to be available for C
 RCS:		$Id: string2_c.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________
-*/

#include "basicmod.h"
#include "gendefs.h"
#include <string.h>
#include <ctype.h>

/*!
\brief Advances given pointer to first non-whitespace.
*/

#define mSkipBlanks(ptr) \
    { if ( ptr ) { while ( *(ptr) && isspace(*(ptr)) ) (ptr)++; } }

/*!
\brief Advances given pointer to first whitespace.
*/

#define mSkipNonBlanks(ptr) \
    { if ( ptr ) { while ( *(ptr) && !isspace(*(ptr)) ) (ptr)++; } }

/*!
\brief Advances to first whitespace and removes trailing whitespace.
*/

#define mTrimBlanks(ptr) \
    { mSkipBlanks(ptr); C_removeTrailingBlanks(ptr); }

mGlobal(Basic) void C_removeTrailingBlanks(char*);
mGlobal(Basic) int C_caseInsensitiveEqual(const char*,const char*,
				     int nr_chars_to_match_0_is_all);
mGlobal(Basic) void C_replaceCharacter(char*,char from,char to);


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef strmdata_h
#define strmdata_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		3-4-1996
 Contents:	Data on any stream
 RCS:		$Id: strmdata.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/
 
#include "basicmod.h"
#include "gendefs.h"
#include <stdio.h>
#include <iosfwd>


/*!
\brief Holds data to use and close an iostream.

  Usually created by StreamProvider.
  Need to find out what to do with the pipe in windows.
*/

mExpClass(Basic) StreamData
{
public:

		StreamData() : fname_(0)	{ initStrms(); }
		~StreamData()			{ delete [] fname_; }
		StreamData( const StreamData& sd )
		: fname_(0)			{ copyFrom( sd ); }
    StreamData&	operator =(const StreamData&);
    void	transferTo(StreamData&);	//!< retains fileName()

    void	close();
    bool	usable() const;

    void	setFileName(const char*);
    const char*	fileName() const	{ return fname_; }
    						//!< Beware: may be NULL

    FILE*	filePtr() const		{ return const_cast<FILE*>(fp_); }

    std::istream* istrm;
    std::ostream* ostrm;

protected:

    FILE*	fp_;
    bool	ispipe_;
    char*	fname_;
    void	copyFrom(const StreamData&);

private:

    inline void	initStrms() { istrm = 0; ostrm = 0; fp_ = 0; ispipe_ = false; }
    friend class StreamProvider;

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef strmio_h
#define strmio_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Nanne Hemstra
 Date:		January 2010
 RCS:		$Id: strmio.h 31300 2013-08-29 07:17:57Z aneesh.tiwari@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "commondefs.h"
#include "plftypes.h"
#include <iostream>

class IOPar;

/*!
\brief Class for simple ascii/binary stream read/write.
*/

mExpClass(Basic) StreamIO
{
public:
    				StreamIO( std::ostream& s,bool binary )
				    : ostrm_(&s), istrm_(0), binary_(binary) {}

				StreamIO( std::istream& s, bool binary )
				    : istrm_(&s), ostrm_(0), binary_(binary) {}

    bool			writeInt16(const od_int16&,
	    				   const char* post="\t");
    bool			writeInt32(const od_int32&,
	    				   const char* post="\t");
    bool			writeInt64(const od_int64&,
	    				   const char* post="\t");
    bool			writeFloat(const float&,
	    				   const char* post="\t");

    virtual od_int16		readInt16() const;
    virtual od_int32		readInt32() const;
    virtual od_int64		readInt64() const;
    virtual float		readFloat() const;

    od_int64			tellg() const;
    od_int64			tellp() const;
    bool			seekg(od_int64,
	    			    std::ios_base::seekdir=std::ios_base::beg);
    bool			seekp(od_int64,
	    			    std::ios_base::seekdir=std::ios_base::beg);

    virtual void		fillPar(IOPar&) const		{}
    virtual bool		usePar(const IOPar&)		{ return true; }

    bool			writeBlock(void* ptr,od_uint64 nrbytes);
    bool			readBlock(void* ptr,od_uint64 nrbytes) const;

protected:

    std::ostream*		ostrm_;
    std::istream*		istrm_;
    bool			binary_;
};

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef strmoper_h
#define strmoper_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Bril
 Date:		23-10-1996
 Contents:	Stream opening etc.
 RCS:		$Id: strmoper.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "gendefs.h"
#include <iosfwd>
#include <iostream>
class BufferString;

/*!\brief Stream operations. operations will be retried on soft errors */

namespace StrmOper
{
    mGlobal(Basic) bool	readBlock(std::istream&,void*,od_uint64 nrbytes);
    mGlobal(Basic) bool	writeBlock(std::ostream&,const void*,od_uint64);

    mGlobal(Basic) bool	getNextChar(std::istream&,char&);
    mGlobal(Basic) bool	wordFromLine(std::istream&,char*,int maxnrchars);

    mGlobal(Basic) bool	readLine(std::istream&,BufferString* b=0);
    mGlobal(Basic) bool	readFile(std::istream&,BufferString&);

    mGlobal(Basic) od_int64	tell(std::istream&);
    mGlobal(Basic) od_int64	tell(std::ostream&);
    mGlobal(Basic) void	seek(std::istream&,od_int64 pos);
    mGlobal(Basic) void	seek(std::istream&,od_int64 offset,std::ios::seekdir);
    mGlobal(Basic) void	seek(std::ostream&,od_int64 pos);
    mGlobal(Basic) void	seek(std::ostream&,od_int64 offset,std::ios::seekdir);
   

}


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef strmprov_h
#define strmprov_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		17-5-1995
 Contents:	Generalized stream opener.
 RCS:		$Id: strmprov.h 30528 2013-07-03 04:58:23Z salil.agarwal@dgbes.com $
________________________________________________________________________

-*/
 
#include "basicmod.h"
#include "strmdata.h"
#include "bufstring.h"
class CallBack;
class TaskRunner;
class BufferStringSet;


/*!
\brief Provides I/O stream for file or system command.

  StreamProvider provides a stream with requested source attached:
   - starting with '@' --> OS command that produces the data on stdin/stdout
   - Hostname may preceed before a ':' (UNIX variants) or '\\' (Windows).
  
  Thus:
   - dgb1:@handle_data
        Executable handle_data on remote host dgb1 will get/put on stdin/stdout.   - \\winserv\foo\bar
	File \foo\bar on remote host winserv.
   - foo.bar
	File foo.bar in current directory.

  A null string or StreamProvider::sStdIO will select std input and output.
*/

mExpClass(Basic) StreamProvider
{
public:
		StreamProvider(const char* nm=0);
		StreamProvider(const char* hostnm,const char* fnm,bool iscomm);
    void	set(const char*);
    bool	rename(const char*,const CallBack* cb=0);
    		//!< renames if file. if successful, does a set()

    bool	bad() const				{ return isbad_; }

    bool	exists(int forread) const;
    bool	remove(bool recursive=true) const;
    bool	setReadOnly(bool yn) const;
    bool	isReadOnly() const;

    StreamData	makeOStream(bool binary=true,bool editmode=false) const;
		/*!< On win32, binary mode differs from text mode. 
		    Use binary=false when explicitly reading txt files. 
                    Use editmode=true when want to edit/modify existing data 
                    in a file.*/
    StreamData	makeIStream(bool binary=true,bool allowpreloaded=true) const;
		//!< see makeOStream remark
    bool	executeCommand(bool inbg=false,bool inconsole=false) const;
    		//!< If type is Command, execute command without opening pipe
    		//!< 'inbg' will execute in background if remote
    void	mkBatchCmd(BufferString& comm) const;

    const char*	fullName() const;
    const char*	hostName() const		{ return hostname_.buf(); }
    const char*	fileName() const		{ return fname_.buf(); }
    const char*	command() const			{ return fname_.buf(); }
    long	blockSize() const		{ return blocksize_; }

    void	setHostName( const char* hname ) { hostname_ = hname; }
    void	setFileName( const char* fn )	{ fname_ = fn; }
    void	setCommand( const char* fn )	{ fname_ = fn; }
    void	setBlockSize( long bs )		{ blocksize_ = bs; }
    void	addPathIfNecessary(const char*);
		//!< adds given path if stored filename is relative
    void	setRemExec( const char* s )	{ rshcomm_ = s; }

    bool	isCommand() const		{ return iscomm_; }
    bool	isNormalFile() const;

    static const char*	sStdIO();
    static const char*	sStdErr();

    static bool		isPreLoaded(const char*,bool isid);
			    //!< If isid, a single hit will return true
    static bool		preLoad(const char*,TaskRunner&,const char* id);
    			    //!< id can be anything, usually MultiID though
    static bool		preLoad(const BufferStringSet&,TaskRunner&,
	    			const char* id);
    			    //!< id can be anything, usually MultiID though
    static void		getPreLoadedIDs(BufferStringSet&);
    static void		getPreLoadedFileNames(const char* id,BufferStringSet&);
			    //!< pass null id for all files
    static int		getPreLoadedDataPackID(const char*);
    static void		unLoad(const char*,bool isid=false);
			    //!< If isid, unload all with this id
    static void		unLoadAll();

protected:

    BufferString		fname_;
    BufferString		hostname_;
    BufferString		rshcomm_;

    long			blocksize_;
    bool			isbad_;
    bool			iscomm_;

    void			mkOSCmd(bool,BufferString&) const;
    static StreamData		makePLIStream(int);

    static void	sendCBMsg(const CallBack*,const char*);
    		//!< The callback will be called with a const char* capsule

};

//! Execute command in OS
mGlobal(Basic) bool ExecOSCmd(const char*,bool inconsloe=false,bool inbg=false);

//! Execute command
mGlobal(Basic) bool ExecuteScriptCommand(const char* prognm,const char* filenm);

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef surv2dgeom_h
#define surv2dgeom_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Aug 2010
 RCS:		$Id: surv2dgeom.h 29163 2013-04-09 02:09:11Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/
 
 
#include "basicmod.h"
#include "posinfo2d.h"
#include "separstr.h"
#include "survgeom.h"
#include "thread.h"

class IOPar;
class FilePath;
class BufferStringSet;


namespace PosInfo
{

/*!
\brief Geometry ID. 
*/

mExpClass(Basic) GeomID
{
public:
    		GeomID( int lsid=-1, int lineid=-1 )
		    : lsid_(lsid) ,lineid_(lineid)	{}

    int		lsid_;
    int		lineid_;

    bool	isOK() const;
    void	setUndef();
    bool	isUndef() const;

    bool	operator ==( const GeomID& a ) const
   		{ return a.lsid_ == lsid_ && a.lineid_ == lineid_; }
    bool	operator !=( const GeomID& a ) const
		{ return !( operator==(a) ); }
    BufferString toString() const;
    bool	fromString(const char*);
};


/*!
\brief Repository for 2D line geometries.

  You can access it using S2DPOS() (or PosInfo::POS2DAdmin()).
*/

mExpClass(Basic) Survey2D : public CallBacker
{
public:

    static void		initClass();
    bool		isEmpty() const		{ return lsnm_.isEmpty(); }

    //using names
    bool		hasLineSet(const char*) const;
    bool		hasLine(const char* lnm,const char* lsnm=0) const;
    void		getLineSets( BufferStringSet& nms ) const
						{ getKeys(lsindex_,nms); }
    void		getLines(BufferStringSet&,const char* lsnm=0) const;

    const char*		curLineSet() const	{ return lsnm_.buf(); }
    void		setCurLineSet(const char*) const;

    bool		getGeometry(Line2DData&) const; //!< using lineName()
    bool		setGeometry(const Line2DData&);

    void		removeLine(const char*);
    void		removeLineSet(const char*);
    void		renameLineSet(const char*,const char*);
    
    // using ids
    const char*		getLineSet(int lsid) const;
    const char*		getLineName(int lineid) const;
    int			getLineSetID(const char*) const;
    int			getLineID(const char*) const;
    bool		hasLineSet(int lsid) const;
    bool		hasLine(int lineid,int lsid=-1) const;
    void		getLineIDs(TypeSet<int>&,int lsid) const;
    void		getLines(BufferStringSet&,int lsid) const;

    int			curLineSetID() const;
    void		setCurLineSet(int lsid) const;

    bool		getGeometry(int lid,Line2DData&) const;
    bool		getGeometry(const GeomID&,Line2DData&) const;
    			//!< thread safe

    void		renameLine(const char*oldnm,const char*newnm);
    void		removeLine(int lid);
    void		removeLineSet(int lsid);

    GeomID		getGeomID(const char* lsnm,const char* linenm) const;
    const char*		getLSFileNm(const char* lsnm) const;
    const char*		getLineFileNm(const char* lsnm,const char* lnm) const;

    bool		readDistBetwTrcsStats(const char* linemn,float& max,
	    				      float& median) const;

protected:
    int			getNewID(IOPar&);
    void		updateMaxID(int,IOPar&);

private:

    FilePath&		basefp_;
    FilePath&		lsfp_;
    BufferString	lsnm_;
    IOPar&		lsindex_;
    IOPar&		lineindex_;
    mutable BufferString curlstimestr_;
    mutable Threads::Mutex mutex_;

    void		readIdxFiles();
    bool		isIdxFileNew(const char* lsnm=0) const;
    BufferString 	getIdxTimeStamp(const char* lsnm=0) const;
    static void		readIdxFile(const char*,IOPar&);
    void		writeIdxFile(bool) const;
    void		getKeys(const IOPar&,BufferStringSet&) const;
    void		getIDs(const IOPar&,TypeSet<int>&) const;
    BufferString	getNewStorageName(const char*,const FilePath&,
	    				  const IOPar&) const;
    int			getLineSetIdx(int lsid) const;
    int			getLineIdx(int lineid) const;

    mGlobal(Basic) friend Survey2D&	POS2DAdmin();

    			Survey2D();
public:
    			~Survey2D();

};

mGlobal(Basic) Survey2D& POS2DAdmin();

} // namespace PosInfo


inline mGlobal(Basic) const PosInfo::Survey2D& S2DPOS()
{ return const_cast<PosInfo::Survey2D&>( PosInfo::POS2DAdmin() ); }



//New Stuff post 4.4 that will replace the old stuff in due course

namespace Survey
{

/*!
\brief Geometry of a 2D Line.
*/

mExpClass(Basic) Geometry2D : public Geometry
{
public:
                   		Geometry2D();
				Geometry2D(PosInfo::Line2DData*);
				//!<Line2DData becomes mine

    virtual Coord		toCoord(int linenr,int tracenr) const;
    virtual TraceID		nearestTrace(const Coord&,float* dist) const;

    virtual bool		includes(int linenr,int tracenr) const;

    bool			is2D() const		{ return true; }
    PosInfo::Line2DData&	data()			{ return data_; }
    const PosInfo::Line2DData	data() const		{ return data_; }
    
    StepInterval<float>		zRange() const;

    static BufferString  	makeUniqueLineName(const char* lsnm,
	    					   const char* lnm);
protected:

                    		~Geometry2D();

    PosInfo::Line2DData&	data_;
};

} // namespace Survey

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef survgeom_h
#define survgeom_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		9-4-1996
 RCS:		$Id: survgeom.h 29163 2013-04-09 02:09:11Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "factory.h"
#include "position.h"
#include "refcount.h"

class MultiID;
class TaskRunner;
class IOObj;

namespace Survey
{

/*!
\brief A Geometry which holds trace positions.
*/

mExpClass(Basic) Geometry
{ mRefCountImpl(Geometry);
public:
    virtual bool	is2D() const					= 0;
    TraceID::GeomID	getGeomID() const { return geomid_; }
    void		setGeomID( TraceID::GeomID id ) { geomid_ = id; }
    Coord		toCoord(const TraceID& tid) const;
    virtual Coord	toCoord(int linenr,int tracenr) const		= 0;
    virtual TraceID	nearestTrace(const Coord&,float* distance) const= 0;
    virtual TraceID	getTrace(const Coord&,float maxdist) const;
			//!<returns undef if no trace found

    bool		includes(const TraceID& tid) const;
    virtual bool	includes(int linenr,int tracenr) const		= 0;
    
    virtual StepInterval<float>   zRange() const			= 0;
protected:
			Geometry();
    TraceID::GeomID	geomid_;
};


/*!
\brief Makes geometries accessible from a geometry id, or a multi id.
*/

mExpClass(Basic) GeometryManager
{
public:
				GeometryManager();
				~GeometryManager();
    const Geometry*		getGeometry(TraceID::GeomID) const;
    const Geometry*		getGeometry(const MultiID&) const;

    TraceID::GeomID		getGeomID(const char* linename) const;
    const char*			getName(TraceID::GeomID) const;
    
    Coord			toCoord(const TraceID&) const;

    bool			fetchFrom2DGeom();
				//converts od4 geometries to od5 geometries.

    bool			write(Geometry&);

    IOObj*			createEntry(const char* name,const bool is2d);
				// returns new GeomID.
    
    void			removeGeometry(TraceID::GeomID);    
    
    bool			fillGeometries(TaskRunner*);
    static TraceID::GeomID	cDefault3DGeom() { return -1; }
    static TraceID::GeomID	cUndefGeomID() { return mUdf(TraceID::GeomID); }

protected:
    void			addGeometry(Geometry&);
    bool			hasDuplicateLineNames();

    int				indexOf(TraceID::GeomID) const;

    ObjectSet<Geometry>		geometries_;
};


mGlobal(Basic) GeometryManager& GMAdmin();


inline mGlobal(Basic) const GeometryManager& GM()
{ return const_cast<GeometryManager&>( Survey::GMAdmin() ); }


/*!
\brief Geometry Reader
*/

mExpClass(Basic) GeometryReader
{
public:
			GeometryReader(){};
			mDefineFactoryInClass(GeometryReader,factory);

    virtual bool	read(ObjectSet<Geometry>&,TaskRunner*) const
							{ return true; }
};


/*!
\brief Geometry Writer
*/

mExpClass(Basic) GeometryWriter
{
public:
			GeometryWriter(){};
			mDefineFactoryInClass(GeometryWriter,factory);

    virtual bool	write(Geometry&) const		{ return true; }
    virtual IOObj*	createEntry(const char*) const	{ return 0; }
};

} //namespace Survey


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef survinfo_h
#define survinfo_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		9-4-1996
 RCS:		$Id: survinfo.h 32022 2013-10-18 11:52:28Z bert.bril@dgbes.com $
________________________________________________________________________

-*/
 
#include "basicmod.h"
#include "namedobj.h"
#include "ranges.h"
#include "rcol2coord.h"
#include "enums.h"
#include "zdomain.h"
#include "refcount.h"
#include "thread.h"
#include "cubesampling.h"
#include "survgeom.h"

class ascostream;
class IOPar;
class CubeSampling;
class LatLong2Coord;


/*!
\brief Scaled down survey geometry for an inl/crl geometry.
*/

mExpClass(Basic) InlCrlSystem : public Survey::Geometry
{
public:
    friend		class SurveyInfo;
    
			InlCrlSystem(const char* nm,const ZDomain::Def& zd )
			    : name_( nm )
    			    , zdomain_( zd )
			{}
    bool		is2D() const		{ return false; }
    const BufferString&	name() const		{ return name_; }
    			    
    float		zScale() const 		{ return zscale_; }

    StepInterval<int>	inlRange() const	{ return cs_.hrg.inlRange(); }
    StepInterval<int>	crlRange() const	{ return cs_.hrg.crlRange(); }
    StepInterval<float>	zRange() const		{ return cs_.zrg; }
    int			inlStep() const 	{ return cs_.hrg.step.inl; }
    int			crlStep() const 	{ return cs_.hrg.step.crl; }
    
    float		zStep() const 		{ return cs_.zrg.step; }
    
    Coord		toCoord(int line,int tracenr) const;
    TraceID		nearestTrace(const Coord&,float* distance) const;
    bool		includes(int line,int tracenr) const;

    Coord		transform(const BinID&) const;
    BinID		transform(const Coord&) const;
    const RCol2Coord&	binID2Coord() const	{ return b2c_; }

    float		inlDistance() const;
    float		crlDistance() const;
    
    const CubeSampling&	sampling() const	{ return cs_; }
    
    Coord3		oneStepTranslation(const Coord3& planenormal) const;
    
    
    const ZDomain::Def&	zDomain() const		{ return zdomain_; }
    
protected:
    
    BufferString	name_;
    RCol2Coord		b2c_;
    
    CubeSampling	cs_; 
    ZDomain::Def	zdomain_;
    float		zscale_;
};


/*!
\brief Holds survey general information.

  The surveyinfo is the primary source for ranges and steps.It also provides
  the transformation between inline/xline <-> coordinates and lat/long estimates
  
  Note: the Z range step is only a default. It should not be used further
  because different cubes/lines have different sample rates.
  
  The ranges are defined for two cubes: the entire survey, and a 'working area'.
  Normally, you'll want to have the working area.
  
  If you are an expert, and you feel you need more 'power', you may want to look
  at the bottom part of the class too for some more public functions.
*/

mExpClass(Basic) SurveyInfo : public NamedObject
{

    mGlobal(Basic) friend const SurveyInfo&	SI();
		

public:
			~SurveyInfo();
    bool		isValid() const		{ return valid_; }
    bool		has2D() const;
    bool		has3D() const;
    
    RefMan<InlCrlSystem> 		get3DGeometry(bool work) const;
    Survey::GeometryManager&		geomManager()	{ return geometryman_; }
    const Survey::GeometryManager&	geomManager() const
    					{ return geometryman_; }

    StepInterval<int>	inlRange(bool work) const;
    StepInterval<int>	crlRange(bool work) const;
    const StepInterval<float>& zRange( bool work ) const;
    int			inlStep() const;
    int			crlStep() const;
    float		zStep() const;
    float		inlDistance() const; //!< distance for one increment
    float		crlDistance() const;
    float		computeArea(const Interval<int>& inl,
	    		     const Interval<int>& crl) const;	//!<returns m2
    float		computeArea(bool work) const ;		//!<returns m2

    Coord3		oneStepTranslation(const Coord3& planenormal) const;

    const CubeSampling&	sampling( bool work ) const
    			{ return work ? wcs_ : cs_; }

    Coord		transform( const BinID& b ) const
			{ return b2c_.transform(b); }
    BinID		transform(const Coord&) const;
    			/*!<\note BinID will be snapped using work step. */

    inline bool		xyInFeet() const	{ return xyinfeet_;}
    const char*		getXYUnitString(bool withparens=true) const;
    const ZDomain::Def&	zDomain() const;
    bool		depthsInFeet() const	{ return depthsinfeet_; }
    inline float	showZ2UserFactor() const
			{ return (float)zDomain().userFactor(); }

    bool		depthsInFeetByDefault() const { return depthsInFeet(); }
    			//!<Legacy, don't use. Use depthsInFeet().
    bool		zIsTime() const;
    			//!<Legacy, don't use. Use zDomain().isTime()
    inline bool		zInMeter() const
    			{ return zDomain().isDepth() && !depthsinfeet_;}
    			//!<Legacy, don't use
    inline bool		zInFeet() const
    			{ return zDomain().isDepth() && depthsinfeet_;}
    			//<Legacy, don't use
    const char*		getZUnitString(bool withparens=true) const
    			//!<Legacy, don't use
			{ return zDomain().unitStr( withparens ); }
    enum Unit		{ Second, Meter, Feet };
    Unit		xyUnit() const;
    			//!<Legacy, don't use
    Unit		zUnit() const;
    			//!<Legacy, don't use

    Coord		minCoord(bool work) const;
    Coord		maxCoord(bool work) const;
    bool		isInside(const BinID&,bool work) const;
    bool		isReasonable(const BinID&) const;
				//!< Checks if in or near survey
    bool		isReasonable(const Coord&) const;
				//!< Checks if in or near survey
    Interval<int>	reasonableRange(bool inl) const;
    int			maxNrTraces(bool work) const;

    void		checkInlRange(Interval<int>&,bool work) const;
			//!< Makes sure range is inside
    void		checkCrlRange(Interval<int>&,bool work) const;
			//!< Makes sure range is inside
    void		checkZRange(Interval<float>&,bool work) const;
			//!< Makes sure range is inside
    bool		includes(const BinID&,const float,bool work) const;
			//!< Returns true when pos is inside survey-range

    void		snap(BinID&,const BinID& dir=BinID(0,0)) const;
			//!< dir = 0 : auto; -1 round downward, 1 round upward
    void		snapStep(BinID&,const BinID& dir=BinID(0,0))const;
    			//!< see snap() for direction
    void		snapZ(float&,int direction=0) const;
    			//!< see snap() for direction
    
    double		seismicReferenceDatum() const	 {return seisrefdatum_;}
			/*!<In depth units (m or ft), positive upward
    			from sea level */
    void		setSeismicReferenceDatum(double d){ seisrefdatum_=d; }

    const IOPar&	pars() const			{ return pars_; }
    void		putZDomain(IOPar&) const;

    // Some public fns moved to bottom because they are rarely used; some fns
    // that have 'no user servicable parts inside' are at the very bottom

    enum Pol2D      	{ No2D=0, Both2DAnd3D=1, Only2D=2 };

protected:

			SurveyInfo();
			// do not use, will be removed
    bool		valid_;

    BufferString	datadir_;
    BufferString	dirname_;

    ZDomain::Def&	zdef_;

    bool		xyinfeet_;
    bool		depthsinfeet_;

    BufferString	comment_;
    BufferString	wsprojnm_;
    BufferString	wspwd_;
    CubeSampling&	cs_;
    CubeSampling&	wcs_;
    IOPar&		pars_;
    
    double		seisrefdatum_;
    
    mutable Threads::AtomicPointer<InlCrlSystem>	inlcrlsystem_;
    mutable Threads::AtomicPointer<InlCrlSystem>	winlcrlsystem_;
    
    Survey::GeometryManager geometryman_;

    RCol2Coord		b2c_;
    LatLong2Coord&	ll2c_;
    BinID		set3binids_[3];
    Coord		set3coords_[3];

    Pol2D		survdatatype_;
    bool		survdatatypeknown_;

 
    void		handleLineRead(const BufferString&,const char*);
    bool		wrapUpRead();
    void		writeSpecLines(ascostream&) const;

    void		setTr(RCol2Coord::RCTransform&,const char*);
    void		putTr(const RCol2Coord::RCTransform&,
	    			ascostream&,const char*) const;

private:

    // ugly, but hard to avoid:
    friend class		IOMan;
    friend class		uiSurvey;
    friend class		uiSurveyInfoEditor;

    RCol2Coord::RCTransform	rdxtr_;
    RCol2Coord::RCTransform	rdytr_;

    				// For IOMan only
    static void			setSurveyName(const char*);
    				// friends only
    static const char*		surveyFileName();

public:

	// These fns are rarely used by non-specialist classes.

    void		setWorkRange(const CubeSampling&);
    Notifier<SurveyInfo> workRangeChg;

    const RCol2Coord&	binID2Coord() const	{ return b2c_; }
    void		get3Pts(Coord c[3],BinID b[2],int& xline) const;
    const LatLong2Coord& latlong2Coord() const	{ return ll2c_; }
    bool		isClockWise() const;
    			/*!< Orientation is determined by rotating the
			     inline axis to the crossline axis. */
    float		computeAngleXInl() const;
    			/*!< It's the angle (0 to pi/2) between
			     the X-axis and the Inl-axis (not an inline) */
    void		setXYInFeet( bool yn=true ) { xyinfeet_ = yn; }
    void		setDepthInFeet( bool yn=true ) { depthsinfeet_ = yn; }
    void		setZUnit(bool istime,bool infeet=false);
    static float	defaultXYtoZScale(Unit,Unit);
    			/*!<Gives a ballpark figure of how to scale XY to
			    make it comparable to Z. */
    float		zScale() const;
    			/*!<Gives a ballpark figure of how to scale Z to        
			    make it comparable to XY. */

    static const char*	sKeyInlRange();
    static const char*	sKeyCrlRange();
    static const char*	sKeyXRange();
    static const char*	sKeyYRange();
    static const char*	sKeyZRange();
    static const char*	sKeyWSProjName();
    static const char*	sKeyXYInFt();
    static const char*	sKeyDpthInFt(); //!< Not used by SI, just a UI default
    static const char*	sKeySurvDataType();
    static const char*  sKeySeismicRefDatum();
    static const char*	sKeySetupFileName()		{ return ".survey"; }
    static const char*	sKeyBasicSurveyName()		{ return "BasicSurvey";}

    BufferString	getDirName() const	{ return dirname_; }
    void		updateDirName(); //!< May be used after setName()

    			DeclareEnumUtils(Pol2D);
    Pol2D		survDataType() const	{ return survdatatype_; }
    void		setSurvDataType( Pol2D typ )
    			{ survdatatype_ = typ; survdatatypeknown_ = true; }
    BufferString	sipName() const		{ return sipnm_; }
    void		setSipName( BufferString sipnm )     { sipnm_ = sipnm; }

    const char*		comment() const		{ return comment_.buf(); }

    const char*		getWSProjName() const	{ return wsprojnm_.buf(); }
    			// Password only in memory this session
    const char*		getWSPwd() const	{ return wspwd_.buf(); }

	// These fns are used by specialist classes. Know what you are doing!

    			SurveyInfo(const SurveyInfo&);
    SurveyInfo&		operator =(const SurveyInfo&);

    RCol2Coord&		getBinID2Coord() const
    			{ return const_cast<SurveyInfo*>(this)->b2c_; }
    LatLong2Coord&	getLatlong2Coord() const
    			{ return const_cast<SurveyInfo*>(this)->ll2c_; }
    IOPar&		getPars() const	
    			{ return const_cast<SurveyInfo*>(this)->pars_; }

    bool		write(const char* basedir=0) const;
    			//!< Write to .survey file
    void		savePars(const char* basedir=0) const;
    			//!< Write to .defs file
    static SurveyInfo*	read(const char*);
    void		setRange(const CubeSampling&,bool);
    const char*		set3Pts(const Coord c[3],const BinID b[2],int xline);
    void		gen3Pts();
    void		setComment( const char* s )	{ comment_ = s; }
    			// do not use, will be removed
    void		setInvalid() const;

    void		setWSProjName( const char* nm ) const
			{ const_cast<SurveyInfo*>(this)->wsprojnm_ = nm; }
    void		setWSPwd( const char* nm ) const
			{ const_cast<SurveyInfo*>(this)->wspwd_ = nm; }

    static const char*	curSurveyName();

    			// No, you really don't need these!
    static void		pushSI(SurveyInfo*);
    static SurveyInfo*	popSI();
    static void		deleteInstance()		{ delete popSI(); }

protected:

    BufferString	sipnm_;

};


mGlobal(Basic) const SurveyInfo& SI();
mGlobal(Basic) inline SurveyInfo& eSI()
			{ return const_cast<SurveyInfo&>(SI()); }

/* The following can be used at all times to get the current survey name: */
mExternC( Basic ) const char* GetSurveyName(void);


/* Deprecated, these will go away in 5.0: */
mExternC( Basic ) const char* GetSurveyFileName(void);
mExternC( Basic ) int SurveyNameDirty(void);
mExternC( Basic ) void SetSurveyNameDirty(void);
mExternC( Basic ) void SetSurveyName(const char*);



#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

// Generated automatically by CMakeModules/ODSubversion.cmake
//
#ifndef mSVN_VERSION
#define mSVN_VERSION 35233
#define mSVN_URL "https://opendtect.googlecode.com/svn/tags/od4.6.0l"
#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef task_h
#define task_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril/K.Tingdahl
 Date:		13-10-1999
 RCS:		$Id: task.h 30724 2013-07-15 04:29:53Z satyaki.maitra@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "namedobj.h"
#include "objectset.h"
#include "thread.h"


namespace Threads { class ThreadWorkManager; }

class ProgressMeter;

/*!
\brief Generalization of something (e.g. a computation) that needs to be
done in multiple steps.
*/

mExpClass(Basic) Task : public NamedObject
{
public:
    virtual		~Task();

    virtual void	setProgressMeter(ProgressMeter*)	{}
    			//!<Must be called before execute()

    virtual od_int64	nrDone() const			{ return -1; }
    			/*!<\note nrDone is only used for displaying progress
			          and will be compared to totalNr to show
				  user how large part of the task that is
				  finished. */
    			
    virtual od_int64	totalNr() const			{ return -1; }
    			/*!\note totalNr is only used for displaying
			         progress. */
    virtual const char*	message() const			{ return "Working"; }
    virtual const char*	nrDoneText() const		{ return "Nr Done"; }

    virtual bool	execute()			= 0;

    virtual void	enableWorkControl(bool=true);
    			//!<Must be called before execute()
    enum Control	{ Run, Pause, Stop };
    virtual void	controlWork(Control);
    virtual Control	getState() const;

protected:
					Task(const char* nm=0);
    virtual bool			shouldContinue();
    					//!<\returns wether we should continue
    Threads::ConditionVar*		workcontrolcondvar_;
    Task::Control			control_;
};


/*!
\brief A collection of tasks, that behave as a single task.
*/

mExpClass(Basic) TaskGroup : public Task
{
public:
			TaskGroup();
    			~TaskGroup() { deepErase( tasks_ ); }
    void		addTask( Task* );
    			//Becomes mine
    
    void		setParallel(bool);

    void		setProgressMeter(ProgressMeter*);
    virtual od_int64	nrDone() const;
    virtual od_int64	totalNr() const;

    virtual const char*	message() const;
    virtual const char*	nrDoneText() const;

    virtual bool	execute();

    void		enableWorkControl(bool=true);
    virtual void	controlWork(Control);
    virtual Control	getState() const;

protected:
    ObjectSet<Task>		tasks_;
    int				curtask_;

    mutable Threads::Mutex	lock_;
};


/*!
\brief The generalization of something (e.g. a computation) where the steps must
be done in sequence, i.e. not parallely.
*/

mExpClass(Basic) SequentialTask : public Task
{
public:
		SequentialTask(const char* nm=0)
		    : Task(nm), progressmeter_( 0 )	{}
    
    virtual	~SequentialTask() 			{}
    void	setProgressMeter(ProgressMeter*);
    virtual int	doStep();
    		/*!<\retval MoreToDo()		Not finished. Call me again.
		    \retval Finished()		Nothing more to do.
		    \retval ErrorOccurred()	Something went wrong.
		    \note if function returns a value greater than cMoreToDo(),
			  it should be interpreted as cMoreToDo(). */

    static int	ErrorOccurred()				{ return -1; }
    static int	Finished()				{ return 0; }
    static int	MoreToDo()				{ return 1; }
    static int	WarningAvailable()			{ return 2; }

    bool	execute();

protected:

    virtual int	nextStep()				= 0;
    		/*!<\retval MoreToDo()		Not finished. Call me again.
		    \retval Finished()		Nothing more to do.
		    \retval ErrorOccurred()	Something went wrong.
		    \note if function returns a value greater than cMoreToDo(),
			  it should be interpreted as cMoreToDo(). */

    ProgressMeter*					progressmeter_;
};

class ParallelTaskRunner;


/*!
\brief Generalization of a task that can be run in parallel. Any task that has
a fixed number of computations that are independent (i.e. they don't need to
be done in a certain order) can inherit ParallelTask and be executed in
parallel by calling the ParallelTask::execute().

  Example of usage:
 
  \code
    float result[N];
    for ( int idx=0; idx<N; idx++ )
    	result[idx] = input1[idx]* function( idx, other, variables );
  \endcode

  Could be made parallel by adding the class:

  \code
  
  class CalcClass : public ParallelTask
  {
  public:
        od_int64	nrIterations() const { return N; }
    	int		doWork( od_int64 start, od_int64 stop, int threadid )
			{
    			for ( int idx=start;idx<=stop &&shouldContinue();idx++ )
    			{
				result[idx] = input1[idx] *
				function( idx, other, variables );
				addToNrDone( 1 );
	    		}
			
    			return true;
			}
			};
			
  \endcode
  and in use that instead of the for-loop:
  \code
      CalcClass myclass( N, my, parameters );
      myclass.exectute();
  \endcode
*/

mExpClass(Basic) ParallelTask : public Task
{
public:
    virtual		~ParallelTask();

    bool		execute() { return executeParallel(true); }
    			/*!<Runs the process the desired number of times. \note
			    that the function has static threads (normally the
			    same number as there are processors on the machine),
			    and these static threads will be shared by all
			    instances of ParallelTask::execute. */
    bool		execute(bool parallel)
    			{ return executeParallel(parallel); };
    			/*!<Legacy, use executeParallel instead>*/
    virtual bool	executeParallel(bool parallel);
    			/*!<Runs the process the desired number of times. \note
			    that the function has static threads (normally the
			    same number as there are processors on the machine),
			    and these static threads will be shared by all
			    instances of ParallelTask::execute. */

    void		setProgressMeter(ProgressMeter*);
    od_int64		nrDone() const;
    			//!<May be -1, i.e. class does not report nrdone.
    
    od_int64		totalNr() const	{ return nrIterations(); }

protected:
    virtual od_int64	nrIterations() const				= 0;
    			/*!<\returns the number of times the process should be
			    run. */
    virtual int		maxNrThreads() const;
    virtual int		minThreadSize() const	{ return 1; }
    			/*!<\returns the minimum number of computations that
			     effectively can be run in a separate thread.
			     A small number will give a large overhead for when
			     each step is quick and nrIterations is small. */
    virtual bool 	stopAllOnFailure() const	{ return true; }
    			/*!<If one thread fails, should an attempt be made to
			    stop the others? If true, enableWorkControl will
			    be enabled, and threads should call shouldContinue()
			    regularly. */

			ParallelTask(const char* nm=0);
			ParallelTask(const ParallelTask&);
    od_int64		calculateThreadSize(od_int64 totalnr,int nrthreads,
	    				    int thread) const;

    void		addToNrDone(int increment);
    			/*!<Call this from within your thread to say
			    that you have done something. */
    
    void		resetNrDone();
    
private:
    virtual bool	doWork(od_int64 start,od_int64 stop,int threadid) = 0;
    			/*!<The functions that does the job. The function
			    will be called with all intervals from 0 to 
			    ParallelTask::nrIterations()-1. The function must
			    be designed to be able to run in parallel.
			    \param threadid gives an identifier (between 0 and
			    	   nr of threads -1) that is unique to each call
				   to doWork. */
    virtual bool	doPrepare(int nrthreads)	{ return true; }
    			/*!<Called before any doWork is called. */
    virtual bool	doFinish(bool success)		{ return success; }
    			/*!<Called after all doWork have finished.
			    \param success indicates whether all doWork returned
			           true. */

    friend class			ParallelTaskRunner;
    ProgressMeter*			progressmeter_;
    Threads::Atomic<od_int64>		nrdone_;

private:
    od_int64				totalnrcache_;
};


/*!Macros to define a class to exectute your loop in parallel.

  The loop index is 'idx'.

Example:

    The original loop was:

for ( int isamp=0; isamp<outnrsamples; isamp++ )
    trc.set( isamp, storinterp_->get(blockbuf_,isamp), curcomp );

    There are 4 parameters (trc, curcomp, blockbuf_ and storinterp_) to
    pass to the executing object, thus:

mDefParallelCalc4Pars( SEGYSampleInterpreter, trc.size(),
		   SeisTrc&,trc, int,curcomp, unsigned char*,blockbuf,
		   const TraceDataInterpreter*,storinterp)
mDefParallelCalcBody( \* No initializations *\,
	    trc_.set( idx, storinterp_->get(blockbuf_,idx), curcomp_ );
		    , \* No post-operations *\)

SEGYSampleInterpreter interp( trc.size(), trc, curcomp, blockbuf_, storinterp_);
interp.execute();
 
 */

#define mDefParallelCalcNoPars(clss) \
	class clss : public ParallelTask \
	{ \
	public: \
	    od_int64	sz_; \
	    clss( od_int64 _sz_ ) : sz_(_sz_)  		{} \
	    od_int64 nrIterations() const { return sz_; }

#define mDefParallelCalc1Par(clss,T1,v1) \
	class clss : public ParallelTask \
	{ \
	public: \
	    od_int64	sz_; \
	    T1 		v1##_; \
	    clss( od_int64 _sz_, T1 _##v1##_ ) \
		: sz_(_sz_), v1##_(_##v1##_) 		{} \
	    od_int64 nrIterations() const { return sz_; }

#define mDefParallelCalc2Pars(clss,T1,v1,T2,v2) \
	class clss : public ParallelTask \
	{ \
	public: \
	    od_int64	sz_; \
	    T1 v1##_; T2 v2##_; \
	    clss( od_int64 _sz_, T1 _##v1##_, T2 _##v2##_ ) \
		: sz_(_sz_) \
		, v1##_(_##v1##_), v2##_(_##v2##_) 			{} \
	    od_int64 nrIterations() const { return sz_; }

#define mDefParallelCalc3Pars(clss,T1,v1,T2,v2,T3,v3) \
	class clss : public ParallelTask \
	{ \
	public: \
	    od_int64	sz_; \
	    T1 v1##_; T2 v2##_; T3 v3##_; \
	    clss( od_int64 _sz_, \
		    T1 _##v1##_, T2 _##v2##_, T3 _##v3##_ ) \
		: sz_(_sz_) \
		, v1##_(_##v1##_), v2##_(_##v2##_) , v3##_(_##v3##_)	{} \
	    od_int64 nrIterations() const { return sz_; }

#define mDefParallelCalc4Pars(clss,T1,v1,T2,v2,T3,v3,T4,v4) \
	class clss : public ParallelTask \
	{ \
	public: \
	    od_int64	sz_; \
	    T1 v1##_; T2 v2##_; T3 v3##_; T4 v4##_; \
	    clss( od_int64 _sz_, \
		    T1 _##v1##_, T2 _##v2##_, T3 _##v3##_, T4 _##v4##_ ) \
		: sz_(_sz_) \
		, v1##_(_##v1##_), v2##_(_##v2##_) \
		, v3##_(_##v3##_), v4##_(_##v4##_)		{} \
	    od_int64 nrIterations() const { return sz_; }

#define mDefParallelCalcBody(preop,impl,postop) \
	    bool doWork( od_int64 start, od_int64 stop, int ) \
	    { \
		preop; \
		for ( int idx=(int) start; idx<=stop; idx++ ) \
		    { impl; } \
		postop; \
		return true; \
	    } \
	};


/*!
\brief Class that can execute a task. Can be used as such, be inherited by
fancy subclasses with user interface and progressbars etc.
*/

mExpClass(Basic) TaskRunner
{
public:
    static bool		execute(TaskRunner* tr, Task& );
    			//!<Taskrunner may be zero
    
			TaskRunner() : execres_(false)	{}
    virtual 		~TaskRunner()			{}

    virtual bool	execute(Task& t)
    			{ return (execres_ = t.execute()); }
    virtual bool	execResult() const		{ return execres_; }

protected:

    bool		execres_;
};

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef thread_h
#define thread_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		9-3-1999
 RCS:		$Id: thread.h 30429 2013-06-24 11:33:15Z bert.bril@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "commondefs.h"
#include "plftypes.h"
#include "atomic.h"

#ifndef OD_NO_QT
mFDQtclass(QThread)
mFDQtclass(QMutex)
mFDQtclass(QWaitCondition)
#endif

class CallBack;

/*!\brief interface to threads that should be portable.

As usual, other thread systems are available but they are as far as we know
simply too big and dependent.

*/

namespace Threads
{

/*!
\brief Is a lock that allows a thread to have exlusive rights to something.

  It is guaranteed that once locked, no one else will be able to lock it before
  it is unlocked. If a thread tries to lock it, it will be postponed until
  the thread that has locked it will unlock it.
*/

mExpClass(Basic) Mutex
{
public:
		Mutex( bool recursive=false );
		/*\If recursive, mutex can be locked
		   multiple times from the same thread without deadlock.
		   It will be unlock when unLock has been called the same
		   number of times as lock(). */
		Mutex(const Mutex&);
    virtual	~Mutex();	

    void	lock();
    void	unLock();

    bool	tryLock();
    		/*!< Returns true if mutex is locked.
		     If it is locked, it you must unLock it when
		     you are finished. If it returns false, 
		     carry on with your life.
		*/

protected:

#ifndef OD_NO_QT
    mQtclass(QMutex*)		qmutex_;
#endif

#ifdef __debug__
    const void*			lockingthread_;
    int				count_;
#endif
};


/*!
\brief Is an alternative to Mutex. It is a lock which causes a thread trying to acquire it to simply wait in a loop ("spin") while repeatedly checking if the
lock is available. Because they avoid overhead from operating system process
re-scheduling or context switching, spinlocks are efficient if threads are only likely to be blocked for a short period.
*/

mExpClass(Basic) SpinLock
{
public:
		SpinLock(bool recursive = false);
		/*\If recursive, mutex can be locked
		   multiple times from the same thread without deadlock.
		   It will be unlock when unLock has been called the same
		   number of times as lock(). */
		SpinLock(const SpinLock&);
		~SpinLock();

    SpinLock&	operator=(const SpinLock& b)
		{ recursive_ = b.recursive_; return *this; }

    void	lock();
    void	unLock();
    bool	tryLock();

protected:
    AtomicPointer<const void>	lockingthread_;
    				/*!<0 if unlocked, otherwise set to locking
				      thread */
    int				count_;
    bool			recursive_;

public:
    int				count() const 	{ return count_; }
				/*!<Only for debugging.  */
};


/*!
\brief Is an object that faciliates many threads to wait for something to
happen.

  Usage:
  
  From the working thread
  1. lock()
     You will now be the only one allowed to check weather condition is true
     (e.g. if new work has arrived).
     
  2. Check condition. If false, call wait(). You will now sleep until someone
     calls signal(); If you are awakened, check the condition again and go back
     to sleep if it is false.
     
  3. If condition is true, unLock() and start working. When finished working
     go back to 1.

  It is wise to put an exit flag in the loop, so it's possible to say that we
  are about to quit.
  
  From the manager:
  When you want to change the condition:
  1. lock
  2. set condition (e.g. add more work)
  3. signal
  4. unLock  
*/


mExpClass(Basic) ConditionVar : public Mutex
{
public:
				ConditionVar();
				ConditionVar(const ConditionVar&);
				~ConditionVar();

    void			wait();
    void 			signal(bool all);
    				/*!< If all is true, all threads that have
				     called wait() will be Notified about the
				     signal. If all is false, only one thread
				     will respond.
				*/

protected:

#ifndef OD_NO_QT
    mQtclass(QWaitCondition*)		cond_;
#endif
};


/*!
\brief Lock that permits multiple readers to lock the object at the same time,
but it will not allow any readers when writelocked, and no writelock is allowed
when readlocked.
*/

mExpClass(Basic) ReadWriteLock
{
public:
    			ReadWriteLock();
    			ReadWriteLock(const ReadWriteLock&);
    virtual		~ReadWriteLock();

    void		readLock();
    			//!<No writers will be active.
    bool		tryReadLock();
			//!<No writers will be active.
    void		writeLock();
    			//!<No readers will be active.
    bool		tryWriteLock();
			//!<No readers will be active.
    void		permissiveWriteLock();
    			/*!<Same as readlock, but I'm guaranteed to convert to
			    writelock without giving up my lock. Only one
			    thread may have the permissive write lock
			    at any given time. */
    void		readUnLock();
    void		writeUnLock();
    void		permissiveWriteUnLock();

    bool		convReadToWriteLock();
    			/*!<Lock MUST be readLocked when calling. Object Will
			    always be in write-lock status on return.
			    \returns false if it had to release the readlock
			             when switching to writelock.*/
    void		convWriteToReadLock();
    			//!<Lock MUST be writeLocked when calling.

    void		convPermissiveToWriteLock();
    void		convWriteToPermissive();

protected:
    int			nrreaders_;
    char		status_;
    			//0 not writelocked, -2 write lock, -1 permissive lock
			//>0, number of readers
    ConditionVar	statuscond_;
};


/*!
\ingroup Basic
\brief Is an object that is convenient to use when a mutex should be
locked and unlocked automatically when returning.

  Example:
  
  int function()
  {
     MutexLocker lock( myMutex );
     //Do whatever you want to do
  }
*/

#define mLockerClassImpl( mod, clssnm, clss, lockfn, unlockfn, trylockfn ) \
mExpClass(mod) clssnm \
{ \
public: \
		clssnm( clss& thelock, bool wait=true ) \
		    : lock_( thelock ) \
		    , islocked_( true ) \
		{ \
		    if ( wait ) thelock.lockfn; \
		    else islocked_ = thelock.trylockfn; \
		} \
 \
		~clssnm() { if ( islocked_ ) lock_.unlockfn; } \
    bool	isLocked() const { return islocked_; } \
 \
    void	unLock() { islocked_ = false; lock_.unlockfn; } \
		/*!<Use at own risk! To be safe, it should only be called \
		    by the process that created the lock. */ \
    void	lock() { islocked_ = true; lock_.lockfn; } \
		/*!<Use at own risk! To be safe, it should only be called \
		    by the process that created the lock, and have \
		    called the unLock(). */ \
 \
protected: \
 \
    clss&	lock_; \
    bool	islocked_; \
};

mLockerClassImpl( Basic, MutexLocker, Mutex, lock(), unLock(), tryLock() )
mLockerClassImpl( Basic, SpinLockLocker, SpinLock, lock(), unLock(), tryLock() )
mLockerClassImpl( Basic, ReadLockLocker, ReadWriteLock,
		  readLock(), readUnLock(), tryReadLock() )
mLockerClassImpl( Basic, WriteLockLocker, ReadWriteLock,
		  writeLock(), writeUnLock(), tryWriteLock() )


/*!
\brief Waits for a number of threads to reach a certain point (i.e. the call to
Barrier::waitForAll). Once everyone has arrived, everyone is released.
*/

mExpClass(Basic) Barrier
{
public:
    			Barrier(int nrthreads=-1,bool immediatrelease=true);
    void		setNrThreads(int);
    int			nrThreads() const 		{ return nrthreads_; }

    bool		waitForAll(bool unlock=true);
    			/*!<\returns true if current thread is the first
				     one to return. If immediaterelease_ is
				     false, this thread has to release all
				     other threads with releaseAll() or 
				     releaseAllNoLock().
			    \param   unlock If false, the mutex will still be
			    	     locked when returning, and mutex().unLock()
				     must be called to allow other threads to
				     be released(). */
    void		releaseAll();
    			/*!<Locks, and releases all. */
    void		releaseAllNoLock();
    			/*!<Releases all. */

    Mutex&		mutex()				{ return condvar_; }

protected:
    void		releaseAllInternal();

    ConditionVar	condvar_;
    int			nrthreads_;
    int			threadcount_;
    bool		dorelease_;

    bool		immediaterelease_;
};


/*!
\brief Is the base class for all threads. Start it by creating it and give it
the function or CallBack to execute. 

  The process that has created the thread must call destroy() or detach().
*/

mExpClass(Basic) Thread
{
public:

				Thread(void (*)(void*));
				Thread(const CallBack&);
    virtual			~Thread();

    const void*			threadID() const;

    void			waitForFinish();
    				/*!< Stop the thread with this function.
				    Will wait for the thread to return.  */

protected:

#ifndef OD_NO_QT
    mQtclass(QThread*)			thread_;
#endif
};

/*! Fetches number of processors from operating system, unless:
  * DTECT_USE_MULTIPROC is set to 'n' or 'N'
  * The user settings contain a 'Nr Processors' entry.
*/

mGlobal(Basic) int getSystemNrProcessors();
mGlobal(Basic) int getNrProcessors();
mGlobal(Basic) const void* currentThread();



/*! Causes the current thread to sleep */
mGlobal(Basic) void sleep(double time); /*!< Time in seconds */


#define mThreadDeclareMutexedVar(T,var) \
    T			var; \
    Threads::Mutex	var##mutex

#define mThreadMutexedSet(var,newval) \
    var##mutex.lock(); \
    var = newval; \
    var##mutex.unLock()

#define mThreadMutexedGet(retvar,var) \
    var##mutex.lock(); \
    retvar = var; \
    var##mutex.unLock()

#define mThreadMutexedGetVar(T,retvar,var) \
    var##mutex.lock(); \
    T retvar = var; \
    var##mutex.unLock()


} //namespace

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef threadlock_h
#define threadlock_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		June 2013
 RCS:		$Id: threadlock.h 32200 2013-10-31 09:07:11Z aneesh.tiwari@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "commondefs.h"
#include "plftypes.h"


/*!\brief simple interface to thread locking

The two ingredients are:
* The lock itself - commonly a class variable
* A locker (managing the setting and releasing of the lock)

Typical usage:

class X
{
//...
    Threads::Lock	datalock_;
//...
};

void X::doSomething()
{
    Threads::Locker locker( datalock_ );
    for ( int i.....
}

*/

namespace Threads
{
class Mutex;
class SpinLock;
class ReadWriteLock;

/*!\brief A lock of a type that (hopefully) suits your needs.
  To use it, you need the Locker class. */


mExpClass(Basic) Lock
{
public:

    enum Type			{ BigWork, SmallWork, MultiRead };

    				Lock(bool for_just_a_few_operations=false);
    				Lock(Type);
    				Lock(const Lock&);
    Lock&			operator =(const Lock&);
    virtual			~Lock();


    // For thread-specialists:
    inline bool			isMutex() const		{ return (bool)mutex_; }
    inline bool			isSpinLock() const	{ return (bool)splock_;}
    inline bool			isRWLock() const	{ return (bool)rwlock_;}
    inline Mutex&		mutex()			{ return *mutex_; }
    inline SpinLock&		spinLock()		{ return *splock_; }
    inline ReadWriteLock&	readWriteLock()		{ return *rwlock_; }

protected:

    Mutex*		mutex_;
    SpinLock*		splock_;
    ReadWriteLock*	rwlock_;

};


/*!\brief Locks the lock, shutting out access from other threads if needed. */

mExpClass(Basic) Locker
{
public:

    enum WaitType		{ WaitIfLocked, DontWaitForLock };
    				//!< if DontWaitForLock, check isLocked()
    enum RWType			{ ReadLock, WriteLock };
    				//!< only interesting for MultiRead locks

    				// default = WaitIfLocked / ReadLock
    				Locker(Lock&);
    				Locker(Lock&,WaitType);
    				Locker(Lock&,RWType);
    				Locker(Lock&,WaitType,RWType);
    				Locker(Lock&,RWType,WaitType);
    virtual			~Locker()		{ unlockNow(); }

    inline bool			isLocked() const	{ return needunlock_; }
     				//<! only useful if DontWaitForLock
    void			unlockNow();
     				//<! to explicitly release earlier than the
     				//!< Locker goes out of scope
    void			reLock(WaitType wt=WaitIfLocked);
    bool			convertToWriteLock();
    				//<! only interesting for MultiRead

protected:

     Lock&			lock_;
     bool			needunlock_;
     bool			isread_;

private:

     				Locker(const Locker&);
					//!< intentionally not implemented
    Locker&			operator =(const Locker&);
					//!< intentionally not implemented

};

/*!Any volatile integer that is initialized to 0 can act as a spinlock using
   this funciton. If you lock it, you have to unlock it by setting it to 0.
   Note that parallelStudio will report these as violations of thread-safety.
   Hence use thes only when standard locks cannot be used (e.g. static locks in
   functions). */


mGlobal(Basic) bool lockSimpleSpinWaitLock(volatile int& lock);
mGlobal(Basic) bool lockSimpleSpinLock(volatile int& lock,Locker::WaitType);
mGlobal(Basic) void unlockSimpleSpinLock(volatile int& lock);


} // namespace Threads


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef threadwork_h
#define threadwork_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Kristofer Tingdahl
 Date:		4-11-2002
 RCS:		$Id: threadwork.h 32823 2013-12-23 03:31:01Z aneesh.tiwari@dgbes.com $
________________________________________________________________________


-*/

#include "basicmod.h"
#include "task.h"
#include "objectset.h"
#include "callback.h"

typedef bool (*StaticTaskFunction)();
typedef bool (CallBacker::*TaskFunction)();

namespace Threads
{
class Thread;
class ConditionVar;
class WorkThread;
class Work;


/*!
\brief Takes work and puts it on a queue for execution either in parallel,
singlethread or manual.
*/

mExpClass(Basic) WorkManager : public CallBacker
{
public:

				//Interface from outside world
    				WorkManager(int nrthreads=-1);
				~WorkManager();

    void			shutdown();

    enum QueueType 		{ MultiThread, SingleThread, Manual };
    int				addQueue(QueueType type);
    				/*!<Manual queues will not be executed
				    automaticall, only at executeQueue.
				    \returns queid */
    int				queueSize(int queueid) const;
    void			emptyQueue(int queueid,bool finishall);
    void			removeQueue(int queueid,bool finishall);
    				/*!<Removes queue. If finishall is true,
				    all work in the queue will be finished. */
    static int			cDefaultQueueID() { return 0; }
    bool			executeQueue(int queueid);
    				/*!<Runs all jobs in a que. Only for manual
				    queues */

    void			addWork(const Work&,CallBack* finished,
	    				int queueid, bool putfirstinline,
					bool discardduplicates=false);

    void			addWork(const Work&,CallBack* finished,
	    				int queueid, bool putfirstinline,
					bool discardduplicates,
					bool forcedifferentthread);
				/*!<\param forcedifferentthread will force
					work to be put on the queue, even if it
					could be done directly in current
					thread. */

    bool			addWork(TypeSet<Work>&, int queueid = -1,
	    				bool firstinline = false);
    
    bool			executeWork( Work*, int sz, int queueid = -1,
					bool firstinline = false );
    				//!<Returns when finished with all
    bool			removeWork(const Work&);	
    				/*!< Removes the task from queue
				     and stop it if allready running.
				    \returns true if the task was removed
				    before it had started.*/

    const Work*			getWork(CallBacker*) const;
    				/*!When a work is sumbmitted with a
				   callback, the callback is called with a
				   callbacker. If called from the callback and
				   the callbacker is non-zero, a pointer to the
				   work that was completed is returned.
				   If not possible, a zero pointer will be
				   returned. */

    int				nrThreads() const { return threads_.size(); }
    int				nrFreeThreads() const;
    				//!<Valid right now, may change any time
    bool			isWorkThread() const;

    Notifier<WorkManager>	isidle;
    
    static Threads::WorkManager&	twm();
protected:

    int				queueSizeNoLock(int queueid) const;
    int				reportFinishedAndAskForMore(WorkThread*,
							    int oldqueueid );
    inline void			reduceWorkload(int queueidx);

    friend class		WorkThread;

    //Linked (one entry per que-entry)
    TypeSet<Work>		workload_;
    TypeSet<int>		workqueueid_;
    TypeSet<CallBack>		callbacks_;

    ObjectSet<WorkThread>	threads_;
    ObjectSet<const void>	threadids_;
    ObjectSet<WorkThread>	freethreads_;


    //Linked (one entry per queue)
    TypeSet<int>		queueids_;
    TypeSet<int>		queueworkload_; //Nr threads working on it
    TypeSet<QueueType>		queuetypes_;
    BoolTypeSet			queueisclosing_;

    ConditionVar&		workloadcond_;

    int				freeid_;
};


/*!
\brief The abstraction of something that can be done. It can be an ordinary
CallBack, a static function (must return bool) or a TaskFunction on a CallBackerinheriting class, or a Task. The three examples are shown below.

\code
    mExpClass(Basic) MyClass : public CallBacker
    {
        void		normalCallBack(CallBacker*);
	bool		taskFunction();
	static bool	staticFunc();
    };
\endcode
    Calls to normalCallBack and task functions can be invoked as:
\code
    Threads::WorkManager::twm().addWork( Work(mCB(this,MyClass,normalCallBack) ) );
\endcode
    or
\code
    Threads::WorkManager::twm().addWork( mWMT(this,MyClass,taskFunction));
\endcode
    or
\code
    Threads::WorkManager::twm().addWork( Work( &MyClass::staticFunc) );
\endcode

You can also add Tasks, with the option that they may be deleted when
the work is done, or if there is an error.
*/

mExpClass(Basic) Work
{
public:
    inline		Work();
    inline		Work(const CallBack&);
    inline		Work(CallBacker* o,TaskFunction f);
    inline		Work(StaticTaskFunction f);
    inline		Work(Task& t,bool takeover);
    bool		operator==(const Work&) const;

    inline bool		isOK() const;
    inline bool        	doRun();

protected:

    friend class	WorkThread;
    friend class	WorkManager;
    void		destroy();
    CallBacker*		obj_;
    CallBackFunction	cbf_;
    TaskFunction	tf_;
    StaticTaskFunction	stf_;
    bool		takeover_;
};

#define mSTFN(clss,fn) ((::TaskFunction)(&clss::fn))
#define mWMT(obj,clss,fn) ::Threads::Work( obj, mSTFN(clss,fn) )


}; // Namespace

inline Threads::Work::Work()
    : obj_( 0 ), cbf_( 0 ), tf_( 0 ), stf_( 0 )				{}


inline Threads::Work::Work( const CallBack& cb )
    : obj_( const_cast<CallBacker*>(cb.cbObj()) )
    , cbf_( cb.cbFn() ), tf_( 0 ), stf_( 0 )				{}


inline Threads::Work::Work( CallBacker* o, TaskFunction f )
    : obj_( o ), cbf_( 0 ), tf_( f ), stf_( 0 ), takeover_( false )	{}


inline Threads::Work::Work( StaticTaskFunction f )
    : obj_( 0 ), cbf_( 0 ), tf_( 0 ), stf_( f )				{}


inline Threads::Work::Work( Task& t, bool takeover )
    : obj_( &t ), cbf_( 0 ), tf_( mSTFN(Task,execute) ), stf_( 0 )
    , takeover_( takeover )						{}


inline bool Threads::Work::isOK() const
{ return stf_ || (obj_ && (tf_ || cbf_ ) ); }


inline bool Threads::Work::doRun()
{
    if ( stf_ )     return stf_();
    if ( tf_ )
    {
	const bool res = (obj_->*tf_)();
	if ( takeover_ ) delete obj_;
	return res;
    }

    (obj_->*cbf_)( 0 );

    return true;
}

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef timefun_h
#define timefun_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		3-5-1994
 Contents:	Time functions
 RCS:		$Id: timefun.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "gendefs.h"

mFDQtclass(QTime)

namespace Time
{

/*!
\brief Time Counter
*/

mExpClass(Basic) Counter
{
public:
    		Counter();
		~Counter();
    void	start();
    int		restart();		//!< Returns elapsed time in ms
    int		elapsed() const;	//!< Returns elapsed time in ms

protected:
    mQtclass(QTime&)	qtime_;
};


    mGlobal(Basic) int getMilliSeconds();          //!< From day start
    mGlobal(Basic) int passedSince(int);


    mGlobal(Basic) const char*	defDateTimeFmt();
    mGlobal(Basic) const char*	defDateFmt();
    mGlobal(Basic) const char*	defTimeFmt();

    mGlobal(Basic) const char*	getDateTimeString(const char* fmt=defDateTimeFmt(),
					  bool local=true);
    mGlobal(Basic) const char*	getDateString(const char* fmt=defDateFmt(),
				      bool local=true);
    mGlobal(Basic) const char*	getTimeString(const char* fmt=defTimeFmt(),
				      bool local=true);

    mGlobal(Basic) bool isEarlier(const char* first, const char* second,
	    		   const char* fmt=defDateTimeFmt());
			/*! returns true if the first DateTime string is
			  earlier than the second */

} // namespace Time

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef timer_h
#define timer_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        A.H. Lammertink
 Date:          16/10/2000
 RCS:           $Id: timer.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "namedobj.h"

mFDQtclass(QTimer)
mFDQtclass(QTimerComm)

/*!
\brief Timer class.
*/

mExpClass(Basic) Timer : public NamedObject
{
public :
			Timer(const char* nm="Timer");
    virtual		~Timer();

    bool		isActive() const;
    bool		isSingleShot() const;

    void		start(int msec,bool singleshot=false);
    void		stop();

    Notifier<Timer>	tick;

    void		notifyHandler();

    enum ScriptPolicy	{ DefaultPolicy, DontWait, UserWait, KeepWaiting };
    void		setScriptPolicy(ScriptPolicy);

protected:
    mQtclass(QTimer*)		timer_;
    mQtclass(QTimerComm*)		comm_;
    ScriptPolicy	scriptpolicy_;		

public:	
				// Not for casual use

    ScriptPolicy		scriptPolicy() const;
    static bool			setUserWaitFlag(bool);	// returns old state

    static Notifier<Timer>*	timerStarts();
    static Notifier<Timer>*	timerStopped();
    static Notifier<Timer>*	timerShoots();
    static Notifier<Timer>*	timerShot();

};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef toplist_h
#define toplist_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K Tingdahl
 Date:		April 2003
 RCS:		$Id: toplist.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "typeset.h"

#include <utility>

/*!
\brief Is a class that holds a "top N" list with the N highest (or lowest)
values that is added. Each value has an associated value that can be used as an
identifier of where the value comes from or something like that.
*/

template <class VT, class AVT>
mClass(Basic) TopList
{
public:
			TopList( int maxsize )
			    : maxsize_( maxsize )		{}

    virtual		~TopList()				{}

    inline void		reset();
    			/*!< Removes all values */

    inline VT		getValue(int rank) const;
    inline AVT		getAssociatedValue(int rank) const;

    inline bool		getHighestValue( VT& ) const;
    inline bool		getLowestValue( VT& ) const;

    inline int		size() const;
    inline int		isEmpty() const { return !size(); }

    inline void		addValue( VT val, AVT aval );
private:

    TypeSet<std::pair<VT,AVT> >	values_;
    const int			maxsize_;
};


template <class VT, class AVT> inline
void TopList<VT,AVT>::reset()
{
    values_.erase();
}


template <class VT, class AVT> inline
VT TopList<VT,AVT>::getValue(int pos) const
{ return values_[pos].first; }


template <class VT, class AVT> inline
AVT TopList<VT,AVT>::getAssociatedValue(int pos) const
{ return values_[pos].second; }


template <class VT, class AVT> inline
int TopList<VT,AVT>::size() const
{ return values_.size(); }



template <class VT, class AVT> inline
bool TopList<VT,AVT>::getHighestValue( VT& res ) const
{
    if ( size() )
    {
	res = values_[0].first;
	return true;
    }

    return false;
}


template <class VT, class AVT> inline
bool TopList<VT,AVT>::getLowestValue( VT& res ) const
{
    const int sz = size();
    if ( sz )
    {
	res = values_[sz-1].first;
	return true;
    }

    return false;
}



template <class VT, class AVT> inline
void TopList<VT,AVT>::addValue( VT val, AVT aval )
{
    int pos = 0;
    const int mysize = size();

    while ( pos<mysize && values_[pos].first>val ) pos++;

    if ( pos==mysize )
    {
	if ( mysize>=maxsize_ )
	    return;

	values_ += std::pair<VT,AVT>( val, aval );
    }
    else
    {
	values_.insert( pos, std::pair<VT,AVT>(val,aval) );

	if ( mysize==maxsize_ )
	    values_.removeSingle(mysize);
    }
}
#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef typeset_h
#define typeset_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert / many others
 Date:		Apr 1995 / Feb 2009
 RCS:		$Id: typeset.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#ifndef odset_h
#include "odset.h"
#endif
#ifndef vectoraccess_h
#include "vectoraccess.h"
#endif

#ifdef __debug__
# include "debug.h"
#endif

/*!
\brief Use TypeSet instead.
*/

template <class T, class I>
mClass(Basic) TypeSetBase : public OD::Set
{
public:
    inline virtual		~TypeSetBase();
    inline TypeSetBase<T,I>&	operator =(const TypeSetBase<T,I>&);

    inline I			size() const	{ return vec_.size(); }
    inline virtual od_int64	nrItems() const	{ return size(); }
    inline virtual bool		setSize(I,T val=T());
				/*!<\param val value assigned to new items */
    inline virtual bool		setCapacity( I sz );
				/*!<Allocates mem only, no size() change */
    inline void			setAll(T);

    inline T&			operator[](I);
    inline const T&		operator[](I) const;
    inline T&			first();
    inline const T&		first() const;
    inline T&			last();
    inline const T&		last() const;
    inline virtual bool		validIdx(od_int64) const;
    inline virtual I		indexOf(T,bool forward=true,I start=-1) const;
    inline bool			isPresent(const T&) const;
    inline I			count(const T&) const;

    inline TypeSetBase<T,I>&	operator +=(const T&);
    inline TypeSetBase<T,I>&	operator -=(const T&);
    inline virtual TypeSetBase<T,I>& copy(const T*,I);
    inline virtual TypeSetBase<T,I>& copy(const TypeSetBase<T,I>&);
    inline virtual bool		append(const T*,I);
    inline virtual bool		append(const TypeSetBase<T,I>&);
    inline bool			add(const T&);
    inline bool			push(const T& t) { return add(t); }
    inline T			pop();
    inline virtual void		swap(od_int64,od_int64);
    inline virtual void		reverse();
    virtual inline void		createUnion(const TypeSetBase<T,I>&);
				/*!< Adds items not already there */
    virtual inline void		createIntersection(const TypeSetBase<T,I>&);
				//!< Only keeps common items
    virtual inline void		createDifference(const TypeSetBase<T,I>&,
	    				 bool must_preserve_order=false);
				//!< Removes all items present in other set.

    inline virtual bool		addIfNew(const T&);

    inline virtual void		erase();

    inline virtual void		removeSingle(I,bool preserver_order=true);
    inline virtual void		removeRange(od_int64 from,od_int64 to);
    
    inline virtual void		insert(I,const T&);

				//! 3rd party access
    inline virtual T*		arr()		{ return gtArr(); }
    inline virtual const T*	arr() const	{ return gtArr(); }
    inline std::vector<T>&	vec();
    inline const std::vector<T>& vec() const;

protected:
    
    inline			TypeSetBase();
    inline			TypeSetBase(I nr,T typ);
    inline			TypeSetBase(const T*,I nr);
    inline			TypeSetBase(const TypeSetBase<T,I>&);

    VectorAccess<T,I>		vec_;

    inline virtual T*		gtArr() const;

};


/*!
\brief Set of (small) copyable elements.

  TypeSet is meant for simple types or small objects that have a copy
  constructor. The `-=' function will only remove the first occurrence that
  matches using the `==' operator. The requirement of the presence of that  
  operator is actually not that bad: at least you can't forget it.
  
  Do not make TypeSet<bool> (don't worry, it won't compile). Use the
  BoolTypeSet typedef just after the class definition. See vectoraccess.h for
  details on why.
*/

template <class T>
mClass(Basic) TypeSet : public TypeSetBase<T,int>
{
    	typedef int size_type;
public:
	TypeSet() : TypeSetBase<T,size_type>() 				{}
	TypeSet(int nr,T typ) : TypeSetBase<T,size_type>( nr, typ )	{}
	TypeSet(const T* t,int nr) : TypeSetBase<T,size_type>( t, nr )	{}
	TypeSet(const TypeSet<T>& t) : TypeSetBase<T,size_type>( t )	{}
};


/*!
\brief We need this because STL has a crazy specialisation of the vector<bool>.
*/

mClass(Basic) BoolTypeSetType
{
public:
   BoolTypeSetType(bool v=false) : val_( v ){}
       operator bool () const { return (bool) val_; }
    bool  operator=(bool v) { val_ = v; return v; }
protected:
    char  val_;
};

typedef TypeSet<BoolTypeSetType> BoolTypeSet;
//!< This sux, BTW.


/*!
\brief Large Value Vector. Publicly derived from TypeSetBase.
*/

template <class T>
mClass(Basic) LargeValVec : public TypeSetBase<T,od_int64>
{
	typedef od_int64 size_type;
public:
	LargeValVec() : TypeSetBase<T,size_type>() 			{}
	LargeValVec(int nr,T typ) : TypeSetBase<T,size_type>( nr, typ )	{}
	LargeValVec(const T* t,int nr) : TypeSetBase<T,size_type>( t, nr ){}
	LargeValVec(const TypeSet<T>& t) : TypeSetBase<T,size_type>( t ){}

};

template <class T, class I>
inline bool operator ==( const TypeSetBase<T,I>& a, const TypeSetBase<T,I>& b )
{
    if ( a.size() != b.size() ) return false;

    const I sz = a.size();
    for ( I idx=0; idx<sz; idx++ )
	if ( !(a[idx] == b[idx]) ) return false;

    return true;
}

template <class T, class I>
inline bool operator !=( const TypeSetBase<T,I>& a, const TypeSetBase<T,I>& b )
{ return !(a == b); }


//! append allowing a different type to be merged into set
template <class T, class I, class J, class S>
inline bool append( TypeSetBase<T,I>& to, const TypeSetBase<S,J>& from )
{
    const J sz = from.size();
    if ( !to.setCapacity( sz + to.size() ) ) return false;
    for ( J idx=0; idx<sz; idx++ )
	to += from[idx];

    return true;
}


//! copy from different possibly different type into set
//! Note that there is no optimisation for equal size, as in member function.
template <class T, class I,class S>
inline void copy( TypeSetBase<T,I>& to, const TypeSetBase<S,I>& from )
{
    if ( &to == &from ) return;
    to.erase();
    append( to, from );
}


//! Sort TypeSetBase. Must have operator > defined for elements
template <class T, class I>
inline void sort( TypeSetBase<T,I>& ts )
{
    T tmp; const I sz = ts.size();
    for ( I d=sz/2; d>0; d=d/2 )
	for ( I i=d; i<sz; i++ )
	    for ( I j=i-d; j>=0 && ts[j]>ts[j+d]; j-=d )
		{ tmp = ts[j]; ts[j] = ts[j+d]; ts[j+d] = tmp; }
}


// Member function implementations
template <class T, class I> inline
TypeSetBase<T,I>::TypeSetBase()
{}


template <class T, class I> inline
TypeSetBase<T,I>::TypeSetBase( I nr, T typ )
{ setSize( nr, typ ); }


template <class T, class I> inline
TypeSetBase<T,I>::TypeSetBase( const T* tarr, I nr )
{ append( tarr, nr ); }

template <class T, class I> inline
TypeSetBase<T,I>::TypeSetBase( const TypeSetBase<T,I>& t )
    : OD::Set( t )
{ append( t ); }


template <class T, class I> inline
TypeSetBase<T,I>::~TypeSetBase() {}


template <class T, class I> inline
TypeSetBase<T,I>& TypeSetBase<T,I>::operator =( const TypeSetBase<T,I>& ts )
{ return copy( ts ); }


template <class T, class I> inline
bool TypeSetBase<T,I>::setSize( I sz, T val )
{ return vec_.setSize( sz, val ); }


template <class T, class I> inline
bool TypeSetBase<T,I>::setCapacity( I sz )
{ return vec_.setCapacity( sz ); }


template <class T, class I> inline
void TypeSetBase<T,I>::setAll( T val )
{ vec_.fillWith( val ); }


template <class T, class I> inline
void TypeSetBase<T,I>::swap( od_int64 idx0, od_int64 idx1 )
{
    if ( !validIdx(idx0) || !validIdx(idx1) )
	return;

    T tmp = vec_[(I)idx0];
    vec_[(I)idx0] = vec_[(I)idx1];
    vec_[(I)idx1] = tmp;
}


template <class T, class I> inline
void TypeSetBase<T,I>::reverse()
{
    const I sz = size();
    const I hsz = sz/2;
    for ( I idx=0; idx<hsz; idx++ )
	swap( idx, sz-1-idx );
}


template <class T, class I> inline
bool TypeSetBase<T,I>::validIdx( od_int64 idx ) const
{
    return vec_.validIdx( (I) idx );
}


template <class T, class I> inline
T& TypeSetBase<T,I>::operator[]( I idx )
{
    return vec_[idx];
}


template <class T, class I> inline
const T& TypeSetBase<T,I>::operator[]( I idx ) const
{
    return vec_[idx];
}


template <class T, class I> inline
T& TypeSetBase<T,I>::first()			{ return vec_.first(); }
template <class T, class I> inline
const T& TypeSetBase<T,I>::first() const	{ return vec_.first(); }
template <class T, class I> inline
T& TypeSetBase<T,I>::last()			{ return vec_.last(); }
template <class T, class I> inline
const T& TypeSetBase<T,I>::last() const		{ return vec_.last(); }


template <class T, class I> inline
T TypeSetBase<T,I>::pop()
{
    return vec_.pop_back();
}


template <class T, class I> inline
I TypeSetBase<T,I>::indexOf( T typ, bool forward, I start ) const
{
    return vec_.indexOf( typ, forward, start );
}


template <class T, class I> inline
bool TypeSetBase<T,I>::isPresent( const T& t ) const
{
    return vec_.isPresent(t);
}


template <class T, class I> inline
I TypeSetBase<T,I>::count( const T& typ ) const
{
    return vec_.count( typ );
}


template <class T, class I> inline
TypeSetBase<T,I>& TypeSetBase<T,I>::operator +=( const T& typ )
{ vec_.push_back( typ ); return *this; }


template <class T, class I> inline
TypeSetBase<T,I>& TypeSetBase<T,I>::operator -=( const T& typ )
{ vec_.erase( typ ); return *this; }


template <class T, class I> inline
TypeSetBase<T,I>& TypeSetBase<T,I>::copy( const TypeSetBase<T,I>& ts )
{
    return this == &ts ? *this : copy( ts.arr(), ts.size() );
}


template <class T, class I> inline
TypeSetBase<T,I>& TypeSetBase<T,I>::copy( const T* tarr, I sz )
{
    if ( size() != sz )
	{ erase(); append(tarr,sz); }
    else
    {
	for ( I idx=0; idx<sz; idx++ )
	    (*this)[idx] = tarr[idx];
    }
    return *this;
}


template <class T, class I> inline
bool TypeSetBase<T,I>::add( const T& t )
{
    return vec_.push_back( t );
}


template <class T, class I> inline
bool TypeSetBase<T,I>::append( const TypeSetBase<T,I>& ts )
{
    if ( this != &ts )
	return append( ts.arr(), ts.size() );

    const TypeSetBase<T,I> tscp( ts );
    return append( tscp );
}


template <class T, class I> inline
bool TypeSetBase<T,I>::append( const T* tarr, I sz )
{
    if ( !sz ) return true;

    if ( !setCapacity( sz+size() ) )
	return false;

    for ( I idx=0; idx<sz; idx++ )
	*this += tarr[idx];

    return true;
}


template <class T, class I>
inline void TypeSetBase<T,I>::createUnion( const TypeSetBase<T,I>& ts )
{
    const I sz = ts.size();
    const T* ptr = ts.arr();
    for ( I idx=0; idx<sz; idx++, ptr++ )
	addIfNew( *ptr );
}


template <class T, class I>
inline void TypeSetBase<T,I>::createIntersection( const TypeSetBase<T,I>& ts )
{
    for ( I idx=0; idx<size(); idx++ )
    {
	if ( ts.isPresent((*this)[idx]) )
	    continue;
	removeSingle( idx--, false );
    }
}


template <class T, class I>
inline void TypeSetBase<T,I>::createDifference( const TypeSetBase<T,I>& ts, bool kporder )
{
    const I sz = ts.size();
    for ( I idx=0; idx<sz; idx++ )
    {
	const T typ = ts[idx];
	for ( I idy=0; idy<size(); idy++ )
	{
	    if ( vec_[idy] == typ )
		removeSingle( idy--, kporder );
	}
    }
}


template <class T, class I> inline
bool TypeSetBase<T,I>::addIfNew( const T& typ )
{
    if ( !isPresent(typ) )
	{ *this += typ; return true; }
    return false;
}


template <class T, class I> inline
void TypeSetBase<T,I>::erase()
{ vec_.erase(); }


template <class T, class I> inline
void TypeSetBase<T,I>::removeSingle( I idx, bool kporder )
{
    if ( kporder )
	vec_.remove( idx );
    else
    {
	const I lastidx = size()-1;
	if ( idx != lastidx )
	    vec_[idx] = vec_[lastidx];
	vec_.remove( lastidx );
    }
}


template <class T, class I> inline
void TypeSetBase<T,I>::removeRange( od_int64 i1, od_int64 i2 )
{ vec_.remove( (I)i1, (I)i2 ); }


template <class T, class I> inline
void TypeSetBase<T,I>::insert( I idx, const T& typ )
{ vec_.insert( idx, typ );}


template <class T, class I> inline
std::vector<T>& TypeSetBase<T,I>::vec()
{ return vec_.vec(); }


template <class T, class I> inline
const std::vector<T>& TypeSetBase<T,I>::vec() const
{ return vec_.vec(); }


template <class T, class I> inline
T* TypeSetBase<T,I>::gtArr() const
{ return size()>0 ? const_cast<T*>(&(*this)[0]) : 0; }


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef undefarray_h
#define undefarray_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        K. Tingdahl
 Date:          13/01/2005
 RCS:           $Id: undefarray.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "commondefs.h"
#include "plftypes.h"
#include "ptrman.h"
#include "valseries.h"

class BinDataDesc;

/*! Filter out undefined values and replaces them by a linear interpolation
    of surrounding defined values. If undefined values are found at start/end,
    they are replaced by the first/last defined value.
    Input and output may be the same.
    \returns true if success, false if no defined value was found. */
template <class T> 
inline bool filterUndef(const T* input,T* output,int sz);

template <class T>
inline bool filterUndef(const ValueSeries<T>& input,ValueSeries<T>& output,int);


/*!
\brief Class that handles undefvalues in arrays that are in a format described
by a BinDataDesc.
*/

mExpClass(Basic) UndefArrayHandler
{
public:
		UndefArrayHandler(const BinDataDesc& desc);
    bool	set(const BinDataDesc& desc);
    bool	isOK() const;

    bool	isUdf(const void* ptr, od_int64 idx) const;
    void	setUdf(void* ptr, od_int64 idx) const;
    void	unSetUdf(void* ptr, od_int64 idx) const;
    		/*!<If the value is undef, it is replaced by a similar value
		    that isn't undef. */

protected:
    		typedef	bool (*IsUdfFunc)(const void*,od_int64 idx);
    		typedef	void (*SetUdfFunc)(void*,od_int64 idx);
    		typedef	void (*UnsetUdfFunc)(void*,od_int64 idx);

    IsUdfFunc		isudf_;
    SetUdfFunc		setudf_;
    UnsetUdfFunc	limitrange_;

    static bool	isUdfUChar(const void*,od_int64);
    static void setUdfUChar(void*,od_int64);
    static void unsetUdfUChar(void*,od_int64);

    static bool	isUdfChar(const void*,od_int64);
    static void setUdfChar(void*,od_int64);
    static void unsetUdfChar(void*,od_int64);

    static bool	isUdfUShort(const void*,od_int64);
    static void setUdfUShort(void*,od_int64);
    static void unsetUdfUShort(void*,od_int64);

    static bool	isUdfShort(const void*,od_int64);
    static void setUdfShort(void*,od_int64);
    static void unsetUdfShort(void*,od_int64);

    static bool	isUdfUInt32(const void*,od_int64);
    static void setUdfUInt32(void*,od_int64);
    static void unsetUdfUInt32(void*,od_int64);

    static bool	isUdfInt32(const void*,od_int64);
    static void setUdfInt32(void*,od_int64);
    static void unsetUdfInt32(void*,od_int64);

    static bool	isUdfUInt64(const void*,od_int64);
    static void setUdfUInt64(void*,od_int64);
    static void unsetUdfUInt64(void*,od_int64);

    static bool	isUdfInt64(const void*,od_int64);
    static void setUdfInt64(void*,od_int64);
    static void unsetUdfInt64(void*,od_int64);

    static bool	isUdfFloat(const void*,od_int64);
    static void setUdfFloat(void*,od_int64);
    static void unsetUdfFloat(void*,od_int64);

    static bool	isUdfDouble(const void*,od_int64);
    static void setUdfDouble(void*,od_int64);
    static void unsetUdfDouble(void*,od_int64);
};


template <class T> inline
bool filterUndef( const ValueSeries<T>& input, ValueSeries<T>& output, int sz )
{
    if ( !sz ) return true;
    
    const T* inptr = input.arr();
    T* outptr = output.arr();
    
    ArrPtrMan<T> myinp = 0, myoutp = 0;
    if ( !inptr )
    {
	myinp = new T[sz];
	for ( int idx=0; idx<sz; idx++ )
	    myinp[idx] = input.value(idx);
    }
    
    if ( !outptr )
	myoutp = outptr = new T[sz];
    
    return filterUndef( inptr ? inptr : myinp, outptr, sz );
}


template <class T> inline
bool filterUndef(const T* input, T* output, int sz )
{
    if ( !sz )
	return true;
    
    int firstdefined = 0;
    while ( firstdefined<sz && mIsUdf(input[firstdefined]) )
	firstdefined++;
    
    if ( firstdefined==sz )
	return false;
    
    for ( int idx=0; idx<=firstdefined; idx++ )
	output[idx] = input[firstdefined];
    
    if ( firstdefined==sz-1 )
	return true;
    
    int prevdefined = firstdefined;
    int nextdefined = -1;
    
    for ( int idx=firstdefined+1; idx<sz; )
    {
	if ( !mIsUdf(input[idx]) )
	{
	    prevdefined = idx;
	    output[idx] = input[idx];
	    idx++;
	    
	    continue;		
	}

	nextdefined = idx+1;
	while ( nextdefined<sz && mIsUdf(input[nextdefined]) )
	    nextdefined++;

	idx = nextdefined;

	if ( nextdefined==sz )
	{
	    for ( int posidx = prevdefined+1; posidx<sz; posidx++ )
		output[posidx] = input[prevdefined];

	    return true;
	}
	else
	{
	    const T diff = input[nextdefined] - input[prevdefined];
	    const T unit = diff / (float)(nextdefined-prevdefined);
	    for ( int posidx = prevdefined+1; posidx<=nextdefined; posidx++ )
		output[posidx] = input[prevdefined]+unit*(posidx-prevdefined);	

	    prevdefined = nextdefined;
	    nextdefined = -1;
	}
    }

    return true;
}

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef undefval_h
#define undefval_h
/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        A.H. Lammertink
 Date:          13/01/2005
 RCS:           $Id: undefval.h 29137 2013-04-08 03:48:17Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "commondefs.h"
#include "plftypes.h"

//! Undefined value. IEEE gives NaN but that's not exactly what we want
#define __mUndefDValue            1e30
#define __mUndefFValue            1e30f
//! Check on undefined. Also works when double converted to float and vv
#define __mIsUndefinedD(x)         (((x)>9.99999e29)&&((x)<1.00001e30))
#define __mIsUndefinedF(x)         (((x)>9.99999e29f)&&((x)<1.00001e30f))
//! Almost MAXINT so unlikely, but not MAXINT to avoid that
#define __mUndefIntVal            2109876543
//! Almost MAXINT64 therefore unlikely.
#define __mUndefIntVal64          9223344556677889900LL


#ifdef __cpp__


/*!  \brief Templatized undefined and initialisation (i.e. null) values.  

    Since these are all templates, they can be used much more generic
    than previous solutions with macros.

Use like:

  T x = mUdf(T);
  if ( mIsUdf(x) )
      mSetUdf(y);

*/

namespace Values
{

/*!
\brief Templatized undefined values.
*/

template<class T>
mClass(Basic) Undef
{
public:
    static T		val();
    static bool		hasUdf();
    static bool		isUdf(T);
    void		setUdf(T&);
};


/*!
\brief Undefined od_int16.
*/

template<>
mClass(Basic) Undef<od_int16>
{
public:
    static od_int16	val()			{ return -32767; }
    static bool		hasUdf()		{ return false; }
    static bool		isUdf( od_int32 i )	{ return i == -32767; }
    static void		setUdf( od_int32& i )	{ i = -32767; }
};


/*!
\brief Undefined od_uint16.
*/

template<>
mClass(Basic) Undef<od_uint16>
{
public:
    static od_uint16	val()			{ return 65534; }
    static bool		hasUdf()		{ return false; }
    static bool		isUdf( od_uint32 i )	{ return i == 65534; }
    static void		setUdf( od_uint32& i )	{ i = 65534; }
};


/*!
\brief Undefined od_int32.
*/

template<>
mClass(Basic) Undef<od_int32>
{
public:
    static od_int32	val()			{ return __mUndefIntVal; }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( od_int32 i )	{ return i == __mUndefIntVal; }
    static void		setUdf( od_int32& i )	{ i = __mUndefIntVal; }
};


/*!
\brief Undefined od_uint32.
*/

template<>
mClass(Basic) Undef<od_uint32>
{
public:
    static od_uint32	val()			{ return __mUndefIntVal; }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( od_uint32 i )	{ return i == __mUndefIntVal; }
    static void		setUdf( od_uint32& i )	{ i = __mUndefIntVal; }
};


/*!
\brief Undefined od_int64.
*/

template<>
mClass(Basic) Undef<od_int64>
{
public:
    static od_int64	val()			{ return __mUndefIntVal64; }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( od_int64 i )	{ return i == __mUndefIntVal64;}
    static void		setUdf( od_int64& i )	{ i = __mUndefIntVal64; }
};


/*!
\brief Undefined od_uint64.
*/

template<>
mClass(Basic) Undef<od_uint64>
{
public:
    static od_uint64	val()			{ return __mUndefIntVal64; }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( od_uint64 i )	{ return i == __mUndefIntVal64;}
    static void		setUdf( od_uint64& i )	{ i = __mUndefIntVal64; }
};


/*!
\brief Undefined bool.
*/

template<>
mClass(Basic) Undef<bool>
{
public:
    static bool		val()			{ return false; }
    static bool		hasUdf()		{ return false; }
    static bool		isUdf( bool b )		{ return false; }
    static void		setUdf( bool& b )	{ b = false; }
};


/*!
\brief Undefined float.
*/

template<>
mClass(Basic) Undef<float>
{
public:
    static float	val()			{ return __mUndefFValue; }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( float f )	{ return __mIsUndefinedF(f); }
    static void		setUdf( float& f )	{ f = __mUndefFValue; }
};


/*!
\brief Undefined double.
*/

template<>
mClass(Basic) Undef<double>
{
public:
    static double	val()			{ return __mUndefDValue; }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( double d )	{ return __mIsUndefinedD(d); }
    static void		setUdf( double& d )	{ d = __mUndefDValue; }
};


/*!
\brief Undefined const char*.
*/

template<>
mClass(Basic) Undef<const char*>
{
public:
    static const char*	val()			{ return ""; }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( const char* s )	{ return !s || !*s; }
    static void		setUdf( const char*& )	{}
};


/*!
\brief Undefined char*.
*/

template<>
mClass(Basic) Undef<char*>
{
public:
    static const char*	val()			{ return ""; }
    static bool		hasUdf()		{ return true; }
    static bool		isUdf( const char* s )	{ return !s || !*s; }
    static void		setUdf( char*& s )	{ if ( s ) *s = '\0'; }
};


template <class T> inline
bool isUdf( const T& t )
{ 
    return Undef<T>::isUdf(t);  
}

template <class T> inline
const T& udfVal( const T& t )
{ 
    static T u = Undef<T>::val();
    return u;
}

template <class T> inline
bool hasUdf()
{ 
    return Undef<T>::hasUdf();  
}

template <class T> inline
T& setUdf( T& u )
{
    Undef<T>::setUdf( u );
    return u; 
}

}


//! Use this macro to get the undefined for simple types
#define mUdf(type) Values::Undef<type>::val()
//! Use this macro to set simple types to undefined
#define mSetUdf(val) Values::setUdf(val)


template <class T>
inline bool dbgIsUdf( T val )
    { return Values::isUdf( val ); }
mGlobal(Basic) bool dbgIsUdf(float);
mGlobal(Basic) bool dbgIsUdf(double);

#ifdef __debug__
# define mIsUdf(val) dbgIsUdf(val)
#else
//! Use mIsUdf to check for undefinedness of simple types
# define mIsUdf(val) Values::isUdf(val)
#endif


#else

/* for C, fallback to old style macro's. Do not provide mUdf and mIsUdf to
   ensure explicit thinking about the situation. */

# define scUndefValue		 "1e30"
# define mcUndefValue             __mUndefDValue
# define mcIsUndefined(x)         __mIsUndefinedD(x)


#endif 


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef undo_h
#define undo_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Kristofer Tingdahl
 Date:		4-11-2002
 RCS:		$Id: undo.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________


-*/

#include "basicmod.h"
#include "bufstringset.h"
#include "callback.h"

class UndoEvent;
class BinID;

/*!
\brief Class to handle undo/redo information. Events that can be undone/redone
are added to the Undo. One user operation may involve thousands of changes
added to the history, but the user does not want to press undo a thousand times.This is managed by setting a UserInteractionEnd flag on the last event in a
chain that the user started. When doing undo, one undo step is consists of all
events from the current event until the next event with the UserInteraction
flag set. 

  This means that after all user-driven events, the UserInteractionEnd should
  be set:
  \code
  void MyClass::userPushedAButtonCB( CallBacker* )
  {
      doSomethingsThatAddThingsOnTheHistory();
      history.setUserInteractionEnd( currentEventID() );
  }
  \endcode
*/

mExpClass(Basic) Undo : public CallBacker
{
public:
	    			Undo();
    virtual			~Undo();

    void			removeAll();
    int				maxLength() const;
    				/*!<Returns maximum number of userevents.
				    \note The actual number of events may
				          be considerably higher since many
				 	  events may be part of one single
				 	  user event. */
    void			setMaxLength(int);
    int				addEvent(UndoEvent* event,
	    				 const char* description=0);
    				/*!<\param event The new event (becomes mine).
				    \return the event id. */
    int				currentEventID() const;
    int				firstEventID() const;
    int				lastEventID() const;

    void			removeAllAfterCurrentEvent();
    void			removeAllBeforeCurrentEvent();

    bool			isUserInteractionEnd(int eventid) const;
    void			setUserInteractionEnd(int eventid,bool=true);
    int				getNextUserInteractionEnd(int start) const;

    BufferString		getDesc(int eventid) const;
    void			setDesc(int eventid,const char* d);
    BufferString		unDoDesc() const;
    BufferString		reDoDesc() const;
    				/*!\note takes redodesc with userinteraction */

    bool			canUnDo() const;
    bool			unDo(int nrtimes=1,bool userinteraction=true);

    bool			canReDo() const;
    bool			reDo(int nrtimes=1,bool userinteraction=true);

    Notifier<Undo>		changenotifier; //Any change
    Notifier<Undo>		undoredochange; //can**Do() or **DoDesc() change

protected:
    int				indexOf(int eventid) const;

    void			removeOldEvents();
    void			removeStartToAndIncluding(int);
    int				currenteventid_; 
    int				firsteventid_;
    int				maxsize_;

    ObjectSet<UndoEvent>	events_;
    int				userendscount_;
};


/*!
\brief Holds the information on how to undo/redo something.
*/

mExpClass(Basic) UndoEvent
{
public:
    				UndoEvent();
    virtual			~UndoEvent();

    BufferString		getDesc() const;
    void			setDesc(const char*);

    void			setUserInteractionEnd(bool=true);
    bool			isUserInteractionEnd() const;

    virtual const char*		getStandardDesc() const	 	= 0;
    virtual bool		unDo()				= 0;
    virtual bool		reDo()				= 0;

protected:
    BufferString*		desc_;
    bool			isuserinteractionend_;
};


/*!
\brief BinID UndoEvent.
*/

mExpClass(Basic) BinIDUndoEvent : public UndoEvent
{
public:
    virtual const BinID&	getBinID() const;
};

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef valseries_h
#define valseries_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Bert Bril & Kris Tingdahl
 Date:          Mar 2005
 RCS:           $Id: valseries.h 32371 2013-11-12 07:38:50Z arnaud.huck@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "gendefs.h"
#include "errh.h"
#include "odmemory.h"

#ifdef __debug__
#include "debug.h"
#endif


/*!
\brief Interface to a series of values.

  If the values are in contiguous memory, arr() should return non-null. 
*/

template <class T>
mClass(Basic) ValueSeries
{
public:

    virtual		~ValueSeries()		{}

    void		getValues(ValueSeries<T>&,od_int64 nrvals) const;
    void		getValues(T*,od_int64 nrvals) const;

    virtual ValueSeries<T>* clone() const			= 0;
    virtual bool	isOK() const			{ return true; }

    virtual T		value(od_int64) const		= 0;
    virtual bool	writable() const		{ return false; }
    virtual void	setValue(od_int64,T)		{}

    virtual bool	canSetAll() const		{ return false; }
    virtual void	setAll(T)			{}

    virtual bool	selfSufficient() const		{ return false; }
    			/*!<\returns true if not depending on other objects */
    virtual bool	reSizeable() const		{ return false; }
    virtual bool	setSize(od_int64) 		{ return false; }

    virtual T*		arr()				{ return 0; }
    virtual const T*	arr() const			{ return 0; }

    virtual char	bytesPerItem() const		{ return sizeof(T); }

    inline T		operator[](od_int64 idx) const	{ return value(idx); }
};


/*!
\brief ValueSeries of offsets.
*/

template <class T>
mClass(Basic) OffsetValueSeries : public ValueSeries<T>
{
public:
    inline		OffsetValueSeries( ValueSeries<T>& src, od_int64 off );
    inline		OffsetValueSeries( const ValueSeries<T>& src,
	    				   od_int64 off);
    inline ValueSeries<T>* clone() const;

    inline T		value( od_int64 idx ) const;
    inline void		setValue( od_int64 idx, T v );
    inline T*		arr();
    inline const T*	arr() const;
    inline bool		writable() const;
    inline bool		canSetAll() const;
    inline void		setAll(T);

    inline od_int64	getOffset() const;
    inline void		setOffset(od_int64 no);

    const ValueSeries<T>&	source() const { return src_; }

protected:
    ValueSeries<T>&	src_;
    od_int64		off_;
    bool		writable_;
};


#define mImplArr \
{ return typeid(RT)==typeid(AT) ? (RT*) ptr_ : (RT*) 0;}

/*!
\brief Series of values from a pointer to some kind of array.
  If a more advanced conversion between the return type and the array type is
  wanted, use ConvValueSeries instead.
*/

template <class RT, class AT>
mClass(Basic) ArrayValueSeries : public ValueSeries<RT>
{
public:

    		ArrayValueSeries( AT* ptr, bool memmine, od_int64 sz=-1 );
    		ArrayValueSeries( od_int64 sz );
    		~ArrayValueSeries()		{ if ( mine_ ) delete [] ptr_; }

    ValueSeries<RT>*	clone() const;

    bool	isOK() const			{ return ptr_; }

    RT		value( od_int64 idx ) const;
    bool	writable() const		{ return true; }
    void	setValue( od_int64 idx, RT v );

    bool	canSetAll() const		{ return writable(); }
    void	setAll(RT);

    const RT*	arr() const			mImplArr;
    RT*		arr()				mImplArr;

    bool	selfSufficient() const		{ return mine_; }
    bool	reSizeable() const		{ return mine_; }
    inline bool	setSize(od_int64);
    od_int64	size() const			{ return cursize_; }
    char	bytesPerItem() const		{ return sizeof(AT); }

protected:

    AT*		ptr_;
    bool	mine_;
    od_int64	cursize_;
};

#undef mImplArr

#define mChunkSize	0x20000000


/*!
\brief Valueseries that allocates its data in smaller chunks (default is 512MB).By doing this, it performs better in environments where the memory is fragmented(i.e. windows 32 bit).
*/

template <class RT, class AT>
mClass(Basic) MultiArrayValueSeries : public ValueSeries<RT>
{
public:
    		MultiArrayValueSeries(od_int64);
    		MultiArrayValueSeries(const MultiArrayValueSeries<RT, AT>&);
    		~MultiArrayValueSeries();

    ValueSeries<RT>*	clone() const;

    bool	isOK() const			{ return cursize_>=0; }

    RT		value( od_int64 idx ) const;
    bool	writable() const		{ return true; }
    void	setValue(od_int64 idx, RT v);

    bool	canSetAll() const		{ return writable(); }
    void	setAll(RT);

    const RT*	arr() const;
    RT*		arr();

    bool	selfSufficient() const		{ return true; }
    bool	reSizeable() const		{ return true; }
    inline bool	setSize(od_int64);
    od_int64	size() const			{ return cursize_; }
    char	bytesPerItem() const		{ return sizeof(AT); }

protected:
    ObjectSet<AT>	ptrs_;
    od_int64		cursize_;
    const unsigned int	chunksize_;
};


/*!
\brief Gets ValueSeries.
*/

template <class T>
mClass(Basic) ValueSeriesGetAll : public ParallelTask
{
public:
		ValueSeriesGetAll(const ValueSeries<T>& from,
				  ValueSeries<T>& to, od_int64 nriterations )
		    : from_( from )
		    , to_( &to )
		    , toptr_( 0 )
		    , nriterations_( nriterations )
		{}

		ValueSeriesGetAll(const ValueSeries<T>& from, T* to,
				  od_int64 nriterations	)
		    : from_( from )
		    , toptr_( to )
		    , to_( 0 )
		    , nriterations_( nriterations )
		{}

od_int64	nrIterations() const { return nriterations_; }
bool		doWork( od_int64 start, od_int64 stop, int )
		{
		    od_int64 nrleft = stop-start+1;
		    const T* fromarr = from_.arr();
		    T* toarr = toptr_ ? toptr_ : to_->arr(); 
		    if ( toarr && fromarr )
		    {
			memcpy( toarr+start, fromarr+start,
			        (size_t) (nrleft*from_.bytesPerItem()) );
		    }
		    else if ( toarr )
		    {
			toarr += start;
			for ( od_int64 idx=start; idx<=stop; idx++, toarr++ )
			    *toarr = from_.value( idx );
		    }
		    else if ( fromarr )
		    {
			fromarr += start;
			for ( od_int64 idx=start; idx<=stop; idx++, fromarr++ )
			    to_->setValue(idx, *fromarr );
		    }
		    else
		    {
			for ( od_int64 idx=start; idx<=stop; idx++ )
			    to_->setValue(idx,from_.value(idx));
		    }

		    return true;
		}

protected:
od_int64		nriterations_;
const ValueSeries<T>&	from_;
ValueSeries<T>*		to_;
T*			toptr_;
};


template <class T> inline
void ValueSeries<T>::getValues( ValueSeries<T>& to, od_int64 nrvals ) const
{
    ValueSeriesGetAll<T> setter( *this, to, nrvals );
    setter.execute();
}


template <class T> inline
void ValueSeries<T>::getValues( T* to, od_int64 nrvals ) const
{
    ValueSeriesGetAll<T> setter( *this, to, nrvals );
    setter.execute();
}


template <class RT, class AT> inline
ValueSeries<RT>* MultiArrayValueSeries<RT,AT>::clone() const
{ return new MultiArrayValueSeries<RT,AT>( *this ); }


template <class T> inline
OffsetValueSeries<T>::OffsetValueSeries( ValueSeries<T>& src, od_int64 off )
    : src_( src ), off_( off ), writable_(true) 
{}


template <class T> inline
OffsetValueSeries<T>::OffsetValueSeries(const ValueSeries<T>& src,od_int64 off)
    : src_( const_cast<ValueSeries<T>& >(src) ), off_( off ), writable_(false) 
{}


template <class T> inline
ValueSeries<T>* OffsetValueSeries<T>::clone() const
{ return new OffsetValueSeries( src_, off_ ); }


template <class T> inline
T OffsetValueSeries<T>::value( od_int64 idx ) const
{ return src_.value(idx+off_); }

template <class T> inline
void OffsetValueSeries<T>::setValue( od_int64 idx, T v )
{
    if ( writable_ )
	src_.setValue(idx+off_,v);
    else
	pErrMsg("Attempting to write to write-protected array");
}


template <class T> inline
void OffsetValueSeries<T>::setAll( T v )
{
    if ( writable_ )
	src_.setAll( v );
    else
	pErrMsg("Attempting to write to write-protected array");
}



template <class T> inline
bool OffsetValueSeries<T>::canSetAll() const
{ return writable_ && src_.canSetAll(); }


template <class T> inline
T* OffsetValueSeries<T>::arr()
{ T* p = src_.arr(); return p ? p+off_ : 0; }


template <class T> inline
const T* OffsetValueSeries<T>::arr() const
{ T* p = src_.arr(); return p ? p+off_ : 0; }


template <class T> inline
od_int64 OffsetValueSeries<T>::getOffset() const
{ return off_; }


template <class T> inline
void OffsetValueSeries<T>::setOffset(od_int64 no)
{ off_ = no; }


template <class T> inline
bool OffsetValueSeries<T>::writable() const
{ return writable_; }


template <class RT, class AT>
ArrayValueSeries<RT,AT>::ArrayValueSeries(AT* ptr, bool memmine,od_int64 cursz )
    : ptr_(ptr), mine_(memmine), cursize_( cursz )
{}


template <class RT, class AT>
ArrayValueSeries<RT,AT>::ArrayValueSeries( od_int64 sz )
    : ptr_( 0 ), mine_(true), cursize_( -1 )
{
    setSize( sz );
}


template <class RT, class AT>
ValueSeries<RT>* ArrayValueSeries<RT,AT>::clone() const
{
    AT* ptr = ptr_;
    if ( mine_ && cursize_>0 )
    {
	ptr = new AT[cursize_];
	memcpy( ptr, ptr_, sizeof(AT)*cursize_ );
    }

    return new ArrayValueSeries( ptr, mine_, cursize_ );
}


template <class RT, class AT>
RT ArrayValueSeries<RT,AT>::value( od_int64 idx ) const
{
#ifdef __debug__
    if ( idx<0 || (cursize_>=0 && idx>=cursize_ ) )
    {
	pErrMsg("Invalid access");
	DBG::forceCrash(true);
    }
#endif

    return (RT) ptr_[idx];
}


template <class RT, class AT>
void ArrayValueSeries<RT,AT>::setValue( od_int64 idx, RT v )
{
#ifdef __debug__
    if ( idx<0 || (cursize_>=0 && idx>=cursize_ ) )
    {
	pErrMsg("Invalid access");
	DBG::forceCrash(true);
    }
#endif

    ptr_[idx] = (AT) v;
}


template <class RT, class AT>
void ArrayValueSeries<RT,AT>::setAll( RT val )
{
    if ( cursize_<=0 )
	return;

    MemSetter<AT> setter( ptr_, (AT) val, cursize_ );
    setter.execute();
}


template <class RT,class AT> inline
bool ArrayValueSeries<RT,AT>::setSize( od_int64 sz )
{
    if ( cursize_!=-1 && cursize_==sz && ptr_ ) return true;
    if ( !mine_ ) return false;

    AT* oldptr = ptr_;
    if ( sz )
    {
	mTryAlloc( ptr_, AT[sz] );
    }
    else
	ptr_ = 0;

    const od_int64 copysize = mMIN(sz,cursize_);
    cursize_ = ptr_ ? sz : -1;
    if ( ptr_ && copysize>0 )
	memcpy( ptr_, oldptr, (size_t) (copysize*sizeof(AT)) );
    
    delete [] oldptr;
    return ptr_;
}


template <class RT, class AT> inline
MultiArrayValueSeries<RT,AT>::MultiArrayValueSeries( od_int64 sz )
    : cursize_( -1 )
    , chunksize_( mChunkSize/sizeof(AT) )
{
    ptrs_.allowNull( true );
    setSize( sz );
}


template <class RT, class AT> inline
MultiArrayValueSeries<RT, AT>::MultiArrayValueSeries( 
				const MultiArrayValueSeries<RT, AT>& mavs )
    : ValueSeries<RT>( mavs )
    , cursize_( -1 )
    , chunksize_( mavs.chunksize_ )
{
    ptrs_.allowNull( true );
    if ( setSize( mavs.cursize_ ) && ptrs_.size() == mavs.ptrs_.size() )
    {
	MemCopier<AT> cpier;
	for ( int idx=0; idx<ptrs_.size(); idx++ )
	{
	    const od_int64 nextstart = ((od_int64) idx+1)*chunksize_;
	    od_int64 curchunksize = chunksize_;
	    if ( nextstart>cursize_ )
	    {
		od_int64 diff = nextstart-cursize_;
		curchunksize -= diff;
	    }

	    cpier.setInput( mavs.ptrs_[idx] );
	    cpier.setOutput( ptrs_[idx] );
	    cpier.setSize( curchunksize );
	    cpier.execute();
	}
    }
}


template <class RT, class AT> inline
MultiArrayValueSeries<RT,AT>::~MultiArrayValueSeries()
{
    deepEraseArr( ptrs_ );
}


template <class RT, class AT> inline
RT MultiArrayValueSeries<RT,AT>::value( od_int64 idx ) const
{
#ifdef __debug__
    if ( idx<0 || idx>=cursize_ )
    {
	pErrMsg("Invalid access");
	DBG::forceCrash(true);
    }
#endif
    const od_int64 arridx = idx/chunksize_;
    if ( arridx>=ptrs_.size() )
	return RT();

    idx -= arridx*chunksize_;
    return  ptrs_[mCast(int,arridx)][idx];
}


template <class RT, class AT> inline
void MultiArrayValueSeries<RT,AT>::setValue( od_int64 idx, RT v )
{
#ifdef __debug__
    if ( idx<0 || idx>=cursize_ )
    {
	pErrMsg("Invalid access");
	DBG::forceCrash(true);
    }
#endif
    const od_int64 arridx = idx/chunksize_;
    if ( arridx>=ptrs_.size() )
	return;

    idx -= arridx*chunksize_;
    ptrs_[mCast(int,arridx)][idx] = v;
}


template <class RT, class AT> inline
void MultiArrayValueSeries<RT,AT>::setAll( RT val )
{
    if ( cursize_<=0 )
	return;

    MemSetter<AT> memsetter;
    memsetter.setValue( (AT)val );

    for ( int idx=ptrs_.size()-1; idx>=0; idx-- )
    {
	const od_int64 nextstart = ((od_int64) idx+1)*chunksize_;
	od_int64 curchunksize = chunksize_;
	if ( nextstart>cursize_ )
	{
	    od_int64 diff = nextstart-cursize_;
	    curchunksize -= diff;
	}

	memsetter.setTarget( ptrs_[idx] );
	memsetter.setSize( curchunksize );
	memsetter.execute();
    }
}


template <class RT, class AT> inline
RT* MultiArrayValueSeries<RT,AT>::arr()
{
    return cursize_>0 && cursize_<=chunksize_ && typeid(RT)==typeid(AT)
	? (RT*) ptrs_[0] : (RT*) 0;
}


template <class RT, class AT> inline
const RT* MultiArrayValueSeries<RT,AT>::arr() const
{ return const_cast<MultiArrayValueSeries<RT,AT>*>( this )->arr(); }


template <class RT, class AT> inline
bool MultiArrayValueSeries<RT,AT>::setSize( od_int64 sz )
{
    if ( cursize_==sz )
	return true;

    od_uint64 lefttoalloc = sz > 0 ? (od_uint64)sz : 0;
    deepEraseArr( ptrs_ );

    while ( lefttoalloc )
    {
	const unsigned int allocsize = lefttoalloc>=chunksize_
	    ? (unsigned int)chunksize_ : (unsigned int)lefttoalloc;

	AT* ptr;
	mTryAlloc( ptr, AT[allocsize] );
	if ( !ptr )
	{
	    cursize_ = -1;
	    deepEraseArr( ptrs_ );
	    return false;
	}

	ptrs_ += ptr;

	if ( lefttoalloc > allocsize )
	    lefttoalloc -= allocsize;
	else
	    lefttoalloc = 0;
    }

    cursize_ = sz;
    return true;
}

#undef mChunkSize

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef valwitherror_h
#define valwitherror_h

/*@+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Kristofer Tingdahl
 Date:          07-10-1999
 RCS:           $Id: valwitherror.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

@$*/

#include <math.h>
#include "gendefs.h"


/*!
\brief ValWithError is a value with a known error (variance) and that knows how the error propagates in the four basic operations +,-,*,/ ValWithError can be
instantiated with float & double. It's probable that it will work on complex
data, although not tested.
*/

template <class A>
mClass(Basic) ValWithError
{
public:
    					ValWithError(A val__ = 0, A var__ = 0)
					    : val_(val__), variance_(var__) {}

    					operator A () { return val_; }

    template<class B> ValWithError<A>& 	operator += (const ValWithError<B>& b)
					{ *this = *this + b; return *this; }
    template<class B> ValWithError<A>& 	operator -= (const ValWithError<B>& b)
					{ *this = *this - b; return *this; }
    template<class B> ValWithError<A>& 	operator *= (const ValWithError<B>& b)
					{ *this = *this * b; return *this; }
    template<class B> ValWithError<A>& 	operator /= (const ValWithError<B>& b)
					{ *this = *this / b; return *this; }

    template<class B> void    		operator += (B b) { val_ += b; }
    template<class B> void     		operator -= (B b) { val_ -= b; }
    template<class B> void     		operator *= (B b) 
					{ val_ *= b; variance_ *= fabs(b);}
    template<class B> void     		operator /= (B b) 
					{ val_ /= b; variance_ /= fabs(b);} 

    A					stDev() const 
    					{ return Math::Sqrt(variance_);}
    A					var() const { return variance_; }
    A	        			val() const { return val_; }

    void				setVal(A val__) { val_ = val__; }
    void				setVar(A var__) { variance_ = var__; }

protected:	     		
    A		val_;
    A		variance_;
};

template <class A, class B> 
inline ValWithError<A> operator + (const ValWithError<A>& a, 
				   const ValWithError<B>& b) 
{
  return ValWithError<A> (a.val() + b.val(), a.var() + b.var());
}

template <class A, class B> 
inline ValWithError<A> operator + (const ValWithError<A>& a, B b)
{
  return ValWithError<A> (a.val() + b, a.var());
}

template <class A, class B> 
inline ValWithError<A> operator - (const ValWithError<A>& a, 
				   const ValWithError<B>& b) 
{
  return ValWithError<A> (a.val() - b.val(), a.var() + b.var());
}

template <class A, class B> 
inline ValWithError<A> operator - (const ValWithError<A>& a, B b)
{
  return ValWithError<A> (a.val() - b, a.var());
}

#define mSQ(val) ((val)*(val))
template <class A, class B> 
inline ValWithError<A> operator * (const ValWithError<A>& a, 
				   const ValWithError<B>& b) 
{
    A product = a.val() * b.val();
    return ValWithError<A> ( product, 
		mSQ(product) * (a.var()/mSQ(a.val() + b.var()/mSQ(b.val())))); 
}

template <class A, class B> 
inline ValWithError<A> operator * (const ValWithError<A>& a, B b)
{
  return ValWithError<A> (a.val() * b, a.var() * fabs(b));
}


template <class A, class B> 
inline ValWithError<A> operator / (const ValWithError<A>& a, 
				   const ValWithError<B>& b) 
{
    A div = a.val() / b.val();
    return ValWithError<A> ( div, 
		mSQ(div) * (a.var()/mSQ(a.val() + b.var()/mSQ(b.val())))); 
}

template <class A, class B> 
inline ValWithError<A> operator / (const ValWithError<A>& a, B b)
{
  return ValWithError<A> (a.val() / b, a.var() / fabs(b));
}


template <class A>
inline ValWithError<A> operator + (const ValWithError<A>& x) 
{ return x; }

template <class A> 
inline ValWithError<A> operator - (const ValWithError<A>& x)
{
  return ValWithError<A> (-x.val(), x.var());
}

template <class A> inline bool
operator == (const ValWithError<A>& x, const ValWithError<A>& y) 
{
  return mIsEqual(x.val(),y.val(),mDefEps) && mIsEqual(x.var(),y.var(),mDefEps);
}

template <class A> inline bool
operator == (A x, const ValWithError<A>& y)
{
  return mIsEqual(x,y.val(),mDefEps);
}

template <class A> inline bool
operator == (const ValWithError<A>& x, A y)
{
  return mIsEqual(x.val(),y,mDefEps);
}

template <class A> inline bool
operator != (const ValWithError<A>& x, const ValWithError<A>& y) 
{
  return !(x == y);
} 

template <class A> inline bool
operator != (A x, const ValWithError<A>& y)
{
  return !(x == y);
}

template <class A> inline bool
operator != (const ValWithError<A>& x, A y)
{
  return !(x == y);
}

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef varlenarray_h
#define varlenarray_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Nanne Hemstra
 Date:		September 2007
 RCS:		$Id: varlenarray.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#ifdef __msvc__
# define __varlenwithptr__
#endif

#ifdef __mac__
# define __varlenwithptr__
#endif

#ifdef __varlenwithptr__ 
# include "ptrman.h"

# define mAllocVarLenArr( type, varnm, __size ) \
  ArrPtrMan<type> varnm; \
  if ( __size ) \
      mTryAllocPtrMan( varnm, type [__size] );

# define mVarLenArr(varnm)	varnm.ptr()
# define mIsVarLenArrOK(varnm)	((bool)varnm.ptr())

#else

# define mAllocVarLenArr( type, varnm, __size ) \
  type varnm[__size];
# define mVarLenArr(varnm)	varnm
# define mIsVarLenArrOK(varnm)	(true)

#endif


#define mAllocVarLenIdxArr(tp,var,sz) \
    mAllocVarLenArr(tp,var,sz) \
    if ( mIsVarLenArrOK(var) ) \
	for ( tp idx=sz-1; idx>=0; idx-- ) \
	    var[idx] = idx;
	

#undef __varlenwithptr__

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef vectoraccess_h
#define vectoraccess_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H.Bril
 Date:		Mar 2002
 Contents:	Access to STL vector class with extensions
 RCS:		$Id: vectoraccess.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "commondefs.h"
#include "general.h"
#include <algorithm>
#include <vector>
#include <stdexcept>

/*!
\brief Simple vector-based container simplifying index-based work.

  This class is an implementation detail of the 'sets.h' and 'sortedlist.h'
  classes. Thus, this class is not meant to be used anywhere else in OpendTect!
  Use TypeSet, ObjectSet or SortedList instead. If you need to have the
  std::vector to pass to an external C++ object, use the TypeSet::vec() or
  SortedList::vec().
  
  NOTE: because this class is based directly upon the STL vector, we have a
  problem for the bool type. In STL, they have made the vector<bool> implemented
  in terms of the bit_vector. That really sucks because we cannot return a
  reference to T! This is why there is a 'BoolTypeSet'. 
*/

template <class T,class I>
mClass(Basic) VectorAccess
{
public:

    inline		VectorAccess()			{}
    inline		VectorAccess( I n ) : v_(n)	{}
    inline		VectorAccess( I n, const T& t )
				: v_(n,t)		{}
    inline		VectorAccess( const VectorAccess& v2 )
				: v_(v2.v_)		{}
    inline std::vector<T>&	 vec()			{ return v_; }
    inline const std::vector<T>& vec() const		{ return v_; }

    inline T&		operator[](I idx);
    inline const T&	operator[](I idx) const;
    inline T&		first()				{ return v_.front(); }
    inline const T&	first() const			{ return v_.front(); }
    inline T&		last()				{ return v_.back(); }
    inline const T&	last() const			{ return v_.back(); }
    inline I		size() const			{ return (I)v_.size(); }
    inline bool		setCapacity(I sz);
    			/*!<Allocates mem for sz, does not change size.*/
    inline void		getCapacity() const		{ return v_.capacity();}
    			/*!<\returns max size without reallocation.*/
    inline bool		setSize(I sz,T val);
    
    inline bool		validIdx(I idx) const { return idx>=0 && idx<size(); }
    inline I		indexOf(const T&,bool forward,I start=-1) const;
    inline I		count(const T&) const;
    inline bool		isPresent(const T&) const;

    inline VectorAccess& operator =( const VectorAccess& v2 )
			{ v_ = v2.v_; return *this; }
    inline bool		push_back( const T& t );
    inline T		pop_back();
    inline void		insert( I pos, const T& val )
			{ v_.insert(v_.begin() + pos,val); }
    inline void		erase()
    			{ v_.clear(); }
    inline void		erase( const T& t )
			{
			    for ( I idx=size()-1; idx!=-1; idx-- )
				{ if ( v_[idx] == t ) { remove(idx); return; } }
			}
    inline void		remove( I idx )
			{
			    if ( idx < size() )
				v_.erase( v_.begin() + idx );
			}
    inline void		remove( I i1, I i2 )
			{
			    if ( i1 == i2 ) { remove( i1 ); return; }
			    if ( i1 > i2 ) std::swap( i1, i2 );
			    const I sz = size();
			    if ( i1 >= sz ) return;

			    if ( i2 >= sz-1 ) i2 = sz-1;
			    v_.erase( v_.begin()+i1, v_.begin()+i2+1 );
			}
    inline void		swap( I i, I j )
			{ std::swap( v_[i], v_[j] ); }

    inline void		fillWith( const T& val )
			{ std::fill( v_.begin(), v_.end(), val ); }

    void moveAfter( const T& t, const T& aft )
    {
	if ( t == aft || size() < 2 ) return;
	I tidx = -1; I aftidx = -1;
	for ( I idx=size()-1; idx!=-1; idx-- )
	{
	    if ( v_[idx] == t )
		{ tidx = idx; if ( aftidx != -1 ) break; }
	    if ( v_[idx] == aft )
		{ aftidx = idx; if ( tidx != -1 ) break; }
	}
	if ( tidx == -1 || aftidx == -1 || tidx == aftidx ) return;
	if ( aftidx > tidx )
	    for ( I idx=tidx; idx<aftidx; idx++ )
		swap( idx, idx+1 );
	else
	    for ( I idx=tidx; idx>aftidx+1; idx-- )
		swap( idx, idx-1 );
    }

    void moveToStart( const T& t )
    {
	if ( size() < 2 ) return;
	I tidx = -1;
	for ( I idx=size()-1; idx!=-1; idx-- )
	    if ( v_[idx] == t ) { tidx = idx; break; }
	for ( I idx=tidx; idx>0; idx-- )
	    swap( idx, idx-1 );
    }

protected:

    std::vector<T>	v_;

};


template<class T,class I> inline
bool VectorAccess<T,I>::setCapacity( I sz )
{
    try { v_.reserve(sz); }
    catch ( std::bad_alloc )
    { return false; }
    catch ( std::length_error )
    { return false; }

    return true;
}


template<class T,class I> inline
bool VectorAccess<T,I>::push_back( const T& t )
{
    try
	{ v_.push_back(t); }
    catch ( std::bad_alloc )
	{ return false; }

    return true;
}


template<class T,class I> inline
T VectorAccess<T,I>::pop_back()
{
    const T lastelem = v_.back();
    v_.pop_back();
    return lastelem;
}


template<class T,class I> inline
bool VectorAccess<T,I>::setSize( I sz, T val )
{
    try { v_.resize(sz,val); }
    catch ( std::bad_alloc )
    { return false; }

    return true;
}

#ifdef __debug__
#define mImplOperator \
    return v_.at(idx); \
    //throws exception
#else
#define mImplOperator \
    return v_[(typename std::vector<T>::size_type)idx]
#endif


template<class T,class I> inline
T& VectorAccess<T,I>::operator[]( I idx )
{
    mImplOperator;
}


template<class T,class I> inline
const T& VectorAccess<T,I>::operator[]( I idx ) const
{
    mImplOperator;
}

#undef mImplOperator


template<class T,class I> inline
I VectorAccess<T,I>::indexOf( const T& t, bool forward, I start ) const
{
    if ( forward )
    {
	typename std::vector<T>::const_iterator begin = v_.begin();
	const typename std::vector<T>::const_iterator end = v_.end();
	if ( start>0 )
	    begin += start;
	
	const typename std::vector<T>::const_iterator res =
						    std::find( begin, end, t );
	if ( res==end )
	    return -1;
	
	return mCast(I,res-v_.begin());
    }

    typename std::vector<T>::const_reverse_iterator begin = v_.rbegin();
    const typename std::vector<T>::const_reverse_iterator end = v_.rend();
    if ( start>0 )
    {
	const I nrskipped = size()-1-start;
	begin += nrskipped;
    }
    
    const typename std::vector<T>::const_reverse_iterator res =
						    std::find( begin, end, t );
    if ( res==end )
	return -1;
    
    return mCast(I,end-res)-1;
}
    

template<class T,class I> inline
I VectorAccess<T,I>::count( const T& t ) const
{
    return mCast(I,std::count(v_.begin(),v_.end(),t));
}


template<class T,class I> inline
bool VectorAccess<T,I>::isPresent( const T& t ) const
{
    const typename std::vector<T>::const_iterator end = v_.end();
    return std::find( v_.begin(), end, t )!=end;
}

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef veldesc_h
#define veldesc_h

/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	K. Tingdahl
 Date:		September 2007
 RCS:		$Id: veldesc.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#include "basicmod.h"
#include "enums.h"
#include "multiid.h"
#include "staticsdesc.h"


/*!
\brief Specifies velocity type and statics for a velocity.
*/

mExpClass(Basic) VelocityDesc
{
public:
    enum Type		{ Unknown, Interval, RMS, Avg, Delta, Epsilon, Eta };
    			DeclareEnumUtils(Type);
    
			VelocityDesc();
			VelocityDesc(Type);

    Type		type_;
    StaticsDesc		statics_;

    bool		operator==(const VelocityDesc&) const;
    bool		operator!=(const VelocityDesc&) const;

    static bool		isVelocity(Type);
			//!<\returns true if not unknown or a Thomsen parameter
    bool		isVelocity() const;
			//!<\returns true if not unknown or a Thomsen parameter
    static bool		isThomsen(Type);
			//!<\returns true if not unknown or a Velocity
    bool		isThomsen() const;
			//!<\returns true if not unknown or a Velocity

    static void		removePars(IOPar&);
    void		fillPar(IOPar&) const;
    bool		usePar(const IOPar&);

    static const char*	sKeyVelocityType();
    static const char*	sKeyIsFeetPerSecond();
    static const char*	sKeyIsVelocity();

    static const char*	getVelUnit(bool withparens=true);
};


#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef winmain_h
#define winmain_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:        Ranojay Sen
 Date:          March 2009
 RCS:		$Id: winmain.h 30766 2013-07-17 06:00:13Z kristofer.tingdahl@dgbes.com $
_______________________________________________________________________

-*/


#include <windows.h>

int main( int argc, char** argv );

int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		      LPTSTR lpCmdLine, int nCmdShow )
{
    return main( __argc, __argv ); // __argc and __argv defined in windows.h
}

#endif
	

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef winstreambuf_h
#define winstreambuf_h
/*
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Bert
 Date:		Feb 2009
 RCS:		$Id: winstreambuf.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

*/

#define private protected
#include <fstream>
#undef private
#ifdef __win32__
# define fpos_t od_int64
#endif

namespace std
{

/*!
\brief Adapter to seek in filebuffers on win64.

  Usage like:

  std::winfilebuf fb;
  std::istream strm( &fb );

  After C:\Program Files (x86)\Microsoft Visual Studio 8\VC\include\fstream
  Only change is: feek -> _fseeki64
*/

mClass(Basic) winfilebuf : public filebuf
{
public:
winfilebuf( const char* fnm, ios_base::openmode om )
    : realpos_(0)
{
    isok_ = open( fnm, om );
}

bool		isOK() const	{ return isok_; }
od_int64    	getRealPos() const	{ return realpos_; }
protected:

#define defom (ios_base::openmode)(ios_base::in | ios_base::out)

virtual pos_type seekoff( off_type _Off, ios_base::seekdir _Way,
			  ios_base::openmode = defom )
{
    fpos_t _Fileposition;

    if ( _Mysb::gptr() == &_Mychar && _Way == ios_base::cur && _Pcvt == 0 )
	_Off -= (off_type)sizeof (char);

    if ( _Myfile==0 || !_Endwrite() || (_Off!=0 || _Way!=ios_base::cur) &&
	 _fseeki64(_Myfile,_Off,_Way) != 0 ||
	 fgetpos(_Myfile,&_Fileposition) != 0 )
	return (pos_type(_BADOFF));

    if ( _Mysb::gptr() == &_Mychar )
	_Mysb::setg( &_Mychar, &_Mychar+1, &_Mychar+1 );

    realpos_ = (od_int64)_Fileposition;
    return (_POS_TYPE_FROM_STATE(pos_type,_State,_Fileposition));
}


virtual pos_type seekpos( pos_type _Pos, ios_base::openmode = defom )

{
    fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);
    off_type _Off = (off_type)_Pos - _FPOSOFF(_Fileposition);

    if ( _Myfile == 0 || !_Endwrite()
	 || fsetpos(_Myfile, &_Fileposition) != 0
	 || _Off != 0 && _fseeki64(_Myfile, _Off, SEEK_CUR) != 0
	 || fgetpos(_Myfile, &_Fileposition) != 0)
	return (pos_type(_BADOFF));

    _State = _POS_TYPE_TO_STATE(_Pos);

    if ( _Mysb::gptr() == &_Mychar)
	 _Mysb::setg( &_Mychar, &_Mychar+1, &_Mychar+1 );

    realpos_ = (od_int64)_Fileposition;
    return (_POS_TYPE_FROM_STATE(pos_type,_State,_Fileposition));
}

bool	    isok_;
od_int64    realpos_;
};


/*!
\brief Adapter for input streams on win64.
*/

mClass(Basic) winifstream : public istream
{
public:

winifstream( const char* fnm, ios_base::openmode om )
    : istream(0)
{
    fb_ = new winfilebuf( fnm, om );
    rdbuf( fb_ );

    if ( fb_->isOK() )
	clear();
    else
	setstate( ios_base::failbit );
}

~winifstream()
{
    if ( !fb_->close() )
	setstate( ios_base::failbit );
}

bool is_open()
{ return fb_->is_open(); }

    winfilebuf*	fb_;
};


/*!
\brief Adapter for output streams on win64.
*/

mClass(Basic) winofstream : public ostream
{
public:

winofstream( const char* fnm, ios_base::openmode om )
    : ostream(0)
{
    fb_ = new winfilebuf( fnm, om );
    rdbuf( fb_ );

    if ( fb_->isOK() )
	clear();
    else
	setstate( ios_base::failbit );
}

~winofstream()
{
    if ( !fb_->close() )
	setstate( ios_base::failbit );
}

bool is_open()
{ return fb_->is_open(); }

    winfilebuf*	fb_;
};


} // namespace std


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef winterminate_h
#define winterminate_h
/*+
 * AUTHOR   : Arend Lammertink
 * DATE     : Aug 2003
 * SOURCE   : http://support.microsoft.com/kb/178893
 * RCS      : $Id: winterminate.h 30292 2013-06-12 07:08:46Z kristofer.tingdahl@dgbes.com $
-*/

#include <windows.h>

#define TA_FAILED 0
#define TA_SUCCESS_CLEAN 1
#define TA_SUCCESS_KILL 2

DWORD WINAPI TerminateApp( DWORD dwPID, DWORD dwTimeout );

#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef winutils_h
#define winutils_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	A.H. Lammertink
 Date:		09-10-2003
 Contents:	Utilities for win32 support
 RCS:		$Id: winutils.h 32202 2013-10-31 09:24:41Z aneesh.tiwari@dgbes.com $
________________________________________________________________________


-*/


#include "basicmod.h"
#include "gendefs.h"

#ifdef __win__
#include "shlobj.h"
#endif

#ifdef __cpp__
extern "C" 
{
#endif
    mGlobal(Basic) const char*	getCleanUnxPath( const char* path );
    mGlobal(Basic) const char* getCleanWinPath( const char* path );
    mGlobal(Basic) const char* GetSpecialFolderLocation(int csidl);
#ifdef __cpp__
 } //extern "C"
#endif

#ifdef __win__

#ifdef __cpp__
mGlobal(Basic)	bool		winCopy(const char* from,const char* to,
				bool isfile, bool ismove=false);
mGlobal(Basic)	bool		winRemoveDir( const char* dirnm );


mGlobal(Basic) bool		executeWinProg(const char* comm,const char* parm,
					const char* runin=0);
mGlobal(Basic)	unsigned int	getWinVersion();
mGlobal(Basic)	const char*	getFullWinVersion();
mGlobal(Basic)	bool		execShellCmd(const char* comm,const char* parm,
					const char* runin );
mGlobal(Basic) bool		execProc(const char* comm,bool inconsole,bool inbg,
				    const char* runin );
#endif

mGlobal(Basic) const char*	getCygDir();



/*
For documentation of the CSIDL values, see: 

http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp


				CSIDL
     _________________________________________________________________

   CSIDL values provide a unique system-independent way to identify
   special folders used frequently by applications, but which may not
   have the same name or location on any given system. For example, the
   system folder may be "C:\Windows" on one system and "C:\Winnt" on
   another.

   Constants

   CSIDL_FLAG_CREATE (0x8000)
          Version 5.0. Combine this CSIDL with any of the following
          CSIDLs to force the creation of the associated folder.

   CSIDL_ADMINTOOLS (0x0030)
          Version 5.0. The file system directory that is used to store
          administrative tools for an individual user. The Microsoft
          Management Console (MMC) will save customized consoles to this
          directory, and it will roam with the user.

   CSIDL_ALTSTARTUP (0x001d)
          The file system directory that corresponds to the user's
          nonlocalized Startup program group.

   CSIDL_APPDATA (0x001a)
          Version 4.71. The file system directory that serves as a common
          repository for application-specific data. A typical path is
          C:\Documents and Settings\username\Application Data. This CSIDL
          is supported by the redistributable Shfolder.dll for systems
          that do not have the Microsoft Internet Explorer 4.0
          integrated Shell installed.

   CSIDL_BITBUCKET (0x000a)
          The virtual folder containing the objects in the user's Recycle
          Bin.

   CSIDL_CDBURN_AREA (0x003b)
          Version 6.0. The file system directory acting as a staging area
          for files waiting to be written to CD. A typical path is
          C:\Documents and Settings\username\Local Settings\Application
          Data\Microsoft\CD Burning.

   CSIDL_COMMON_ADMINTOOLS (0x002f)
          Version 5.0. The file system directory containing
          administrative tools for all users of the computer.

   CSIDL_COMMON_ALTSTARTUP (0x001e)
          The file system directory that corresponds to the nonlocalized
          Startup program group for all users. Valid only for Microsoft
          Windows NT systems.

   CSIDL_COMMON_APPDATA (0x0023)
          Version 5.0. The file system directory containing application
          data for all users. A typical path is C:\Documents and
          Settings\All Users\Application Data.

   CSIDL_COMMON_DESKTOPDIRECTORY (0x0019)
          The file system directory that contains files and folders that
          appear on the desktop for all users. A typical path is
          C:\Documents and Settings\All Users\Desktop. Valid only for
          Windows NT systems.

   CSIDL_COMMON_DOCUMENTS (0x002e)
          The file system directory that contains documents that are
          common to all users. A typical paths is C:\Documents and
          Settings\All Users\Documents. Valid for Windows NT systems and
          Microsoft Windows 95 and Windows 98 systems with Shfolder.dll
          installed.

   CSIDL_COMMON_FAVORITES (0x001f)
          The file system directory that serves as a common repository
          for favorite items common to all users. Valid only for Windows
          NT systems.

   CSIDL_COMMON_MUSIC (0x0035)
          Version 6.0. The file system directory that serves as a
          repository for music files common to all users. A typical path
          is C:\Documents and Settings\All Users\Documents\My Music.

   CSIDL_COMMON_PICTURES (0x0036)
          Version 6.0. The file system directory that serves as a
          repository for image files common to all users. A typical path
          is C:\Documents and Settings\All Users\Documents\My Pictures.

   CSIDL_COMMON_PROGRAMS (0x0017)
          The file system directory that contains the directories for the
          common program groups that appear on the Start menu for all
          users. A typical path is C:\Documents and Settings\All
          Users\Start Menu\Programs. Valid only for Windows NT systems.

   CSIDL_COMMON_STARTMENU (0x0016)
          The file system directory that contains the programs and
          folders that appear on the Start menu for all users. A typical
          path is C:\Documents and Settings\All Users\Start Menu. Valid
          only for Windows NT systems.

   CSIDL_COMMON_STARTUP (0x0018)
          The file system directory that contains the programs that
          appear in the Startup folder for all users. A typical path is
          C:\Documents and Settings\All Users\Start
          Menu\Programs\Startup. Valid only for Windows NT systems.

   CSIDL_COMMON_TEMPLATES (0x002d)
          The file system directory that contains the templates that are
          available to all users. A typical path is C:\Documents and
          Settings\All Users\Templates. Valid only for Windows NT
          systems.

   CSIDL_COMMON_VIDEO (0x0037)
          Version 6.0. The file system directory that serves as a
          repository for video files common to all users. A typical path
          is C:\Documents and Settings\All Users\Documents\My Videos.

   CSIDL_CONTROLS (0x0003)
          The virtual folder containing icons for the Control Panel
          applications.

   CSIDL_COOKIES (0x0021)
          The file system directory that serves as a common repository
          for Internet cookies. A typical path is C:\Documents and
          Settings\username\Cookies.

   CSIDL_DESKTOP (0x0000)
          The virtual folder representing the Windows desktop, the root
          of the namespace.

   CSIDL_DESKTOPDIRECTORY (0x0010)
          The file system directory used to physically store file objects
          on the desktop (not to be confused with the desktop folder
          itself). A typical path is C:\Documents and
          Settings\username\Desktop.

   CSIDL_DRIVES (0x0011)
          The virtual folder representing My Computer, containing
          everything on the local computer: storage devices, printers,
          and Control Panel. The folder may also contain mapped network
          drives.

   CSIDL_FAVORITES (0x0006)
          The file system directory that serves as a common repository
          for the user's favorite items. A typical path is C:\Documents
          and Settings\username\Favorites.

   CSIDL_FONTS (0x0014)
          A virtual folder containing fonts. A typical path is
          C:\Windows\Fonts.

   CSIDL_HISTORY (0x0022)
          The file system directory that serves as a common repository
          for Internet history items.

   CSIDL_INTERNET (0x0001)
          A virtual folder representing the Internet.

   CSIDL_INTERNET_CACHE (0x0020)
          Version 4.72. The file system directory that serves as a common
          repository for temporary Internet files. A typical path is
          C:\Documents and Settings\username\Local Settings\Temporary
          Internet Files.

   CSIDL_LOCAL_APPDATA (0x001c)
          Version 5.0. The file system directory that serves as a data
          repository for local (nonroaming) applications. A typical path
          is C:\Documents and Settings\username\Local
          Settings\Application Data.

   CSIDL_MYDOCUMENTS (0x000c)
          Version 6.0. The virtual folder representing the My Documents
          desktop item.

   CSIDL_MYMUSIC (0x000d)
          The file system directory that serves as a common repository
          for music files. A typical path is C:\Documents and
          Settings\User\My Documents\My Music.

   CSIDL_MYPICTURES (0x0027)
          Version 5.0. The file system directory that serves as a common
          repository for image files. A typical path is C:\Documents and
          Settings\username\My Documents\My Pictures.

   CSIDL_MYVIDEO (0x000e)
          Version 6.0. The file system directory that serves as a common
          repository for video files. A typical path is C:\Documents and
          Settings\username\My Documents\My Videos.

   CSIDL_NETHOOD (0x0013)
          A file system directory containing the link objects that may
          exist in the My Network Places virtual folder. It is not the
          same as CSIDL_NETWORK, which represents the network namespace
          root. A typical path is C:\Documents and
          Settings\username\NetHood.

   CSIDL_NETWORK (0x0012)
          A virtual folder representing Network Neighborhood, the root of
          the network namespace hierarchy.

   CSIDL_PERSONAL (0x0005)
          Version 6.0. The virtual folder representing the My Documents
          desktop item. This is equivalent to CSIDL_MYDOCUMENTS.

          Previous to Version 6.0. The file system directory used to
          physically store a user's common repository of documents. A
          typical path is C:\Documents and Settings\username\My
          Documents. This should be distinguished from the virtual My
          Documents folder in the namespace. To access that virtual
          folder, use SHGetFolderLocation, which returns the ITEMIDLIST
          for the virtual location, or refer to the technique described
          in Managing the File System.

   CSIDL_PRINTERS (0x0004)
          The virtual folder containing installed printers.

   CSIDL_PRINTHOOD (0x001b)
          The file system directory that contains the link objects that
          can exist in the Printers virtual folder. A typical path is
          C:\Documents and Settings\username\PrintHood.

   CSIDL_PROFILE (0x0028)
          Version 5.0. The user's profile folder. A typical path is
          C:\Documents and Settings\username. Applications should not
          create files or folders at this level; they should put their
          data under the locations referred to by CSIDL_APPDATA or
          CSIDL_LOCAL_APPDATA.

   CSIDL_PROFILES (0x003e)
          Version 6.0. The file system directory containing user profile
          folders. A typical path is C:\Documents and Settings.

   CSIDL_PROGRAM_FILES (0x0026)
          Version 5.0. The Program Files folder. A typical path is
          C:\Program Files.

   CSIDL_PROGRAM_FILES_COMMON (0x002b)
          Version 5.0. A folder for components that are shared across
          applications. A typical path is C:\Program Files\Common. Valid
          only for Windows NT, Windows 2000, and Windows XP systems. Not
          valid for Windows Millennium Edition (Windows Me).

   CSIDL_PROGRAMS (0x0002)
          The file system directory that contains the user's program
          groups (which are themselves file system directories). A
          typical path is C:\Documents and Settings\username\Start
          Menu\Programs.

   CSIDL_RECENT (0x0008)
          The file system directory that contains shortcuts to the user's
          most recently used documents. A typical path is C:\Documents
          and Settings\username\My Recent Documents. To create a shortcut
          in this folder, use SHAddToRecentDocs. In addition to creating
          the shortcut, this function updates the Shell's list of recent
          documents and adds the shortcut to the My Recent Documents
          submenu of the Start menu.

   CSIDL_SENDTO (0x0009)
          The file system directory that contains Send To menu items. A
          typical path is C:\Documents and Settings\username\SendTo.

   CSIDL_STARTMENU (0x000b)
          The file system directory containing Start menu items. A
          typical path is C:\Documents and Settings\username\Start Menu.

   CSIDL_STARTUP (0x0007)
          The file system directory that corresponds to the user's
          Startup program group. The system starts these programs
          whenever any user logs onto Windows NT or starts Windows 95. A
          typical path is C:\Documents and Settings\username\Start
          Menu\Programs\Startup.

   CSIDL_SYSTEM (0x0025)
          Version 5.0. The Windows System folder. A typical path is
          C:\Windows\System32.

   CSIDL_TEMPLATES (0x0015)
          The file system directory that serves as a common repository
          for document templates. A typical path is C:\Documents and
          Settings\username\Templates.

   CSIDL_WINDOWS (0x0024)
          Version 5.0. The Windows directory or SYSROOT. This corresponds
          to the %windir% or %SYSTEMROOT% environment variables. A
          typical path is C:\Windows.

   Remarks

     These values supersede the use of environment variables for this
     purpose.

     A CSIDL is used in conjunction with one of four Shell functions,
     SHGetFolderLocation, SHGetFolderPath, SHGetSpecialFolderLocation,
     and SHGetSpecialFolderPath, to retrieve a special folder's path or
     pointer to an item identifier list (PIDL).

     Combine CSIDL_FLAG_CREATE with any of the other CSIDLs to force the
     creation of the associated folder. The remaining CSIDLs correspond
     to either file system folders or virtual folders. Where the CSIDL
     identifies a file system folder, a commonly used path is given as
     an example. Other paths may be used. Some CSIDLs can be mapped to
     an equivalent %VariableName% environment variable. CSIDLs are more
     reliable, however, and should be used if possible.

*/

#endif /* __win__ */

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef zdomain_h
#define zdomain_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Nanne Hemstra & K. Tingdahl
 Date:		April 2009 / Aug 2010
 RCS:		$Id: zdomain.h 28682 2013-03-02 21:12:38Z kristofer.tingdahl@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstring.h"
class IOPar;


namespace ZDomain
{

class Def;

mGlobal(Basic) const Def&	SI();
mGlobal(Basic) const Def&	Depth();
mGlobal(Basic) const Def&	Time();

mGlobal(Basic) bool		isSI(const IOPar&);
mGlobal(Basic) bool		isDepth(const IOPar&);
mGlobal(Basic) bool		isTime(const IOPar&);
mGlobal(Basic) void		setSI(IOPar&);
mGlobal(Basic) void		setDepth(IOPar&);
mGlobal(Basic) void		setTime(IOPar&);


/*!
\brief Definition of z-domain.
*/

mExpClass(Basic) Def
{
public:

    static const Def&	get(const char*);
    static const Def&	get(const IOPar&);
    void		set(IOPar&) const;	//!< Only key

    const char*		key() const		{ return key_; }
    const char*		userName() const	{ return usrnm_; }
    int			userFactor() const	{ return usrfac_; }

    const char*		unitStr(bool withparens=false) const;
    			//In case of depth, ft or m will come from SurvInfo

    bool		isSI() const;
    bool		isTime() const;
    bool		isDepth() const;
    
    const char*		entityStr() const { return isTime() ? "t" : "d"; }

    bool		operator ==( const Def& def ) const
			{ return key_ == def.key_; }

    // For plugins:
    			Def( const char* ky, const char* usrnm,
				const char* defun, int usrfac=1 )
			    : key_(ky), usrnm_(usrnm)
			    , defunit_(defun), usrfac_(usrfac)	{}
    static bool		add(Def*);

protected:

    BufferString	key_;
    BufferString	usrnm_;
    BufferString	defunit_;
    int			usrfac_; // usually 1 or 1000, not FeetFac
};


/*!
\brief Information of z-domain.
*/

mExpClass(Basic) Info
{
public:
    			Info(const Def&);
    			Info(const Info&);
    			Info(const IOPar&);
    			~Info();

    const Def&		def_;
    IOPar&		pars_;

    bool		hasID() const;
    const char*		getID() const;
    void		setID(const char*);

    bool		isCompatibleWith(const IOPar&) const;

    // Convenience
    const char*		key() const		{ return def_.key(); }
    const char*		userName() const	{ return def_.userName(); }
    const char*		unitStr(bool wp=false) const
    						{ return def_.unitStr(wp); }
    int			userFactor() const	{ return def_.userFactor(); }

};

mGlobal(Basic) const char*	sKey();
mGlobal(Basic) const char*	sKeyTime();
mGlobal(Basic) const char*	sKeyDepth();

} // namespace ZDomain

#endif


/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef ziparchiveinfo_h
#define ziparchiveinfo_h

/*+
________________________________________________________________________

(C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
Author:	Salil Agarwal
Date:		27 August 2012
RCS:		$Id: ziparchiveinfo.h 29279 2013-04-16 12:27:40Z salil.agarwal@dgbes.com $
________________________________________________________________________

-*/

#include "objectset.h"
#include "basicmod.h"

class BufferStringSet;
class ZipFileInfo;


/*!
\brief Gives information of zip archives.
*/

mExpClass(Basic) ZipArchiveInfo
{
public:

				ZipArchiveInfo(const char* fnm);
				~ZipArchiveInfo();

    bool			isOK() const { return isok_; }
    const char*			errorMsg() const;

    bool			getAllFnms(BufferStringSet&) const;

    //!< All sizes in Bytes
    od_int64			getFileCompSize(const char* fnm) const;
    od_int64			getFileCompSize(int) const;
    od_int64			getFileUnCompSize(const char* fnm) const;
    od_int64			getFileUnCompSize(int) const;

    od_int64			getLocalHeaderOffset(const char* fnm) const;
    od_int64			getLocalHeaderOffset(int) const;

protected:

    bool			readZipArchive(const char* fnm);

    ObjectSet<ZipFileInfo>	fileinfo_;
    mutable BufferString	errormsg_;
    bool			isok_;

};


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/

#ifndef ziphandler_h
#define ziphandler_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Salil Agarwal
 Date:		30 August 2012
 RCS:		$Id: ziphandler.h 31287 2013-08-29 05:44:37Z salil.agarwal@dgbes.com $
________________________________________________________________________

-*/

#include "basicmod.h"
#include "bufstringset.h"
#include "strmprov.h"
#include "typeset.h"


class ZipArchiveInfo;

/*!
\brief Zip file information.
*/

mExpClass(Basic) ZipFileInfo
{
    
public:

				ZipFileInfo(const char* fnm, 
				    od_int64 compsize, 
				    od_int64 uncompsize,
				    od_int64 offset)
				: fnm_(fnm)
				, compsize_(compsize) 
				, uncompsize_(uncompsize)
				, localheaderoffset_(offset)	    {}

    BufferString		fnm_;
    od_int64			compsize_;
    od_int64			uncompsize_;
    od_int64			localheaderoffset_;

};


/*!
\brief Handles zipping and unzipping of files.
*/

mExpClass(Basic) ZipHandler
{
public:

    friend class		ZipUtils;
    friend class		Zipper;
    friend class		UnZipper;

    enum CompLevel		{ NoComp=0, SuperFast=1, Fast=3, Normal=6,
								Maximum=9 };

				ZipHandler()
				: initialfilecount_(0)
				, uncompfilesize_(0)
				, compfilesize_(0)
				, offsetofcentraldir_(0)
				, curinputidx_(0)
				, curfileidx_(0)
				, totalsize_(0)
				, nrdonesize_(0)		{}

				~ZipHandler();

    const char*			errorMsg()const;

    bool			getArchiveInfo(const char*,
						ObjectSet<ZipFileInfo>&);

    bool			getFileList(const char*,BufferStringSet&);

    od_uint16			dateInDosFormat(const char*) const;
    od_uint16			timeInDosFormat(const char*) const;
    bool			setTimeDateModified(const char*,od_uint16,
						    od_uint16)const;

    bool			getBitValue(const unsigned char byte,
							int bitposition) const;
    void			setBitValue(unsigned char& byte, int 
						bitposition, bool value) const;


protected:

    bool			initUnZipArchive(const char*,const char*);
    bool			unZipFile(const char* srcfnm,const char* fnm,
					  const char* path);

    bool			extractNextFile();
    int				readLocalFileHeader();
    bool			openStreamToWrite();

    bool			doZUnCompress();
    bool			readEndOfCentralDirHeader();
    bool			readCentralDirHeader(ObjectSet<ZipFileInfo>* 
						     zfileinfo=0);
    bool			readZIP64EndOfCentralDirLocator();
    bool			readZIP64EndOfCentralDirRecord();
    bool			readXtraFldForZIP64(const char*,int);
    bool                        readAndSetFileAttr();

    bool			initMakeZip(const char*,BufferStringSet);
    bool			initAppend(const char*,const char*);

    bool			compressNextFile();
    bool			doZCompress();
    int				openStrmToRead(const char* src); 
    bool			setLocalFileHeader();
    bool			setLocalFileHeaderForDir();
    bool			setLocalFileHeaderForLink();
    bool			setZIP64Header();
    bool			setEndOfArchiveHeaders();
    bool			setCentralDirHeader();
    bool			setEndOfCentralDirHeader(od_int64,od_uint32);
    bool			setZIP64EndOfDirRecord(od_int64);
    bool			setZIP64EndOfDirLocator(od_int64);
    od_uint32                   setExtFileAttr(od_uint32);

    const BufferStringSet&	getAllFileNames() { return allfilenames_; }
    od_int64			getCumulativeFileCount() const 
					{ return cumulativefilecounts_.last(); }
    int				getCumulativeFileCount(int) const;
    void			setCompLevel(CompLevel);

    od_int64			getTotalSize()const  { return totalsize_; }
    od_int64			getNrDoneSize()const  { return nrdonesize_; }

    BufferString		errormsg_;
    BufferStringSet		allfilenames_;
    
    BufferString		srcfile_ ;
    od_uint16			srcfnmsize_;

    BufferString		destbasepath_;
    BufferString		destfile_;

    od_int64			compfilesize_;
    od_int64			uncompfilesize_;

    od_uint16			compmethod_;
    CompLevel			complevel_;
    
    int				curnrlevels_;

    int				curinputidx_;
    int				curfileidx_;
    od_int64			initialfilecount_;
    TypeSet<od_int64>		cumulativefilecounts_;
    
    od_uint16			lastmodtime_;
    od_uint16			lastmoddate_;

    od_uint32			crc_;

    od_int64			offsetofcentraldir_;
    od_int64			offsetoflocalheader_;

    od_int64			totalsize_;
    od_int64			nrdonesize_;

    StreamData			osd_;
    StreamData			isd_;
    
};


#endif

/*Copyright (C) 2002-2010 dGB Beheer B.V. All rights reserved.

This file is part of OpendTect and may be used either under the terms of:

1. The GNU General Public License version 3 or higher, as published by
the Free Software Foundation, or
2. The OpendTect Commercial License version 1 or higher, as published by
dGB Beheer B.V., or
3. The OpendTect Academic License version 1 or higher, as published by
dGB Beheer B.V.

For help to determine which license to use, please visit
http://opendtect.org/index.php/licensing.html

This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*/


#ifndef ziputils_h
#define ziputils_h

/*+
________________________________________________________________________

 (C) dGB Beheer B.V.; (LICENSE) http://opendtect.org/OpendTect_license.txt
 Author:	Ranojay Sen
 Date:		December  2011
 RCS:		$Id: ziputils.h 30571 2013-07-05 09:27:10Z salil.agarwal@dgbes.com $
________________________________________________________________________

-*/
#include "basicmod.h"
#include "bufstringset.h"
#include "executor.h"
#include "ziphandler.h"


/*!
\brief Zip Utilities
*/

mExpClass(Basic) ZipUtils
{
public:
				ZipUtils(const char* filelistnm=0);
				~ZipUtils();
   
    bool			Zip(const char* src,const char* dest);
    bool			UnZip(const char* scr, const char* dest);
    const char*			errorMsg() const{ return errmsg_.buf();}
    void			makeFileList(const char* zipfile);
    const BufferStringSet&	getFileList() const	{ return filelist_; }

    static bool			unZipArchive(const char* src,const char* dest,
	    				     BufferString& errmsg,
					     TaskRunner* tr=0);
    static bool			unZipArchives(const BufferStringSet& archvs,
					      const char* dest,
	    				      BufferString& errmsg,
					      TaskRunner* tr=0);
    static bool			unZipFile(const char* ziparchive,
					  const char* fnm,const char* path,
					  BufferString& errmsg);

    static bool			makeZip(const char* zipfilenm,
					const BufferStringSet&,
				        BufferString& errmsg,	
					TaskRunner* tr=0,
					ZipHandler::CompLevel c=
					ZipHandler::Normal);
    static bool			makeZip(const char* zipfilenm,
					const char* tozip,
					BufferString& errmsg,
					TaskRunner* tr=0,
					ZipHandler::CompLevel c=
					ZipHandler::Normal);
    static bool			appendToArchive(const char* zipfile,
						const char* toappend,
						BufferString& errmsg,
						TaskRunner* tr=0,
						ZipHandler::CompLevel c=
						ZipHandler::Normal);

protected:

    bool			doZip(const char* src,const char* dest);
    bool			doUnZip(const char* src,const char* dest);
   
    BufferString		errmsg_;
    BufferStringSet		filelist_;
    BufferString		filelistname_;
    bool			needfilelist_ ;

};


/*!
\brief It is an Executor class which compresses files into zip format but user
should not use it directly instead use ZipUtils::makeZip.
*/

mExpClass(Basic) Zipper : public Executor
{
public:
				Zipper(const char*,const BufferStringSet&, 
                                       ZipHandler::CompLevel);

                                Zipper(const char*,const char*, 
                                       ZipHandler::CompLevel);

    const char*			message() const;
    od_int64			nrDone() const;
    const char*			nrDoneText() const;
    od_int64			totalNr() const;
    bool                        isOk() const { return isok_; }

protected:

    int				nextStep();
    ZipHandler			ziphd_;
    int				nrdone_;
    bool                        isok_;
};


/*!
\brief It is an Executor class which uncompresses files of zip format but user
should instead use ZipUtils::UnZipArchive() to unzip complete archive or
ZipUtils::UnZipFile() to take one file out of zip archive.
*/

mExpClass(Basic) UnZipper : public Executor
{
public:
				UnZipper(const char*,const char*);

    const char*			message() const;
    od_int64			nrDone() const;
    const char*			nrDoneText() const;
    od_int64			totalNr() const;
    bool                        isOk() const { return isok_; }

protected:

    int				nextStep();
    ZipHandler			ziphd_;
    int				nrdone_;
    bool                        isok_;
};


#endif

