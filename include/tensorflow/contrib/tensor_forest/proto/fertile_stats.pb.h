// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fertile_stats.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fertile_5fstats_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fertile_5fstats_2eproto

#include <limits>
#include <string>

#include "protobuf/port_def.inc"
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include "protobuf/port_undef.inc"
#include "protobuf/io/coded_stream.h"
#include "protobuf/arena.h"
#include "protobuf/arenastring.h"
#include "protobuf/generated_message_table_driven.h"
#include "protobuf/generated_message_util.h"
#include "protobuf/inlined_string_field.h"
#include "protobuf/metadata.h"
#include "protobuf/generated_message_reflection.h"
#include "protobuf/message.h"
#include "protobuf/repeated_field.h"  // IWYU pragma: export
#include "protobuf/extension_set.h"  // IWYU pragma: export
#include "protobuf/unknown_field_set.h"
#include "generic_tree_model.pb.h"
// @@protoc_insertion_point(includes)
#include "protobuf/port_def.inc"
#define PROTOBUF_INTERNAL_EXPORT_fertile_5fstats_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fertile_5fstats_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_fertile_5fstats_2eproto;
namespace tensorflow {
namespace tensorforest {
class FertileSlot;
class FertileSlotDefaultTypeInternal;
extern FertileSlotDefaultTypeInternal _FertileSlot_default_instance_;
class FertileStats;
class FertileStatsDefaultTypeInternal;
extern FertileStatsDefaultTypeInternal _FertileStats_default_instance_;
class GiniStats;
class GiniStatsDefaultTypeInternal;
extern GiniStatsDefaultTypeInternal _GiniStats_default_instance_;
class LeafStat;
class LeafStatDefaultTypeInternal;
extern LeafStatDefaultTypeInternal _LeafStat_default_instance_;
class LeafStat_GiniImpurityClassificationStats;
class LeafStat_GiniImpurityClassificationStatsDefaultTypeInternal;
extern LeafStat_GiniImpurityClassificationStatsDefaultTypeInternal _LeafStat_GiniImpurityClassificationStats_default_instance_;
class LeafStat_LeastSquaresRegressionStats;
class LeafStat_LeastSquaresRegressionStatsDefaultTypeInternal;
extern LeafStat_LeastSquaresRegressionStatsDefaultTypeInternal _LeafStat_LeastSquaresRegressionStats_default_instance_;
class SplitCandidate;
class SplitCandidateDefaultTypeInternal;
extern SplitCandidateDefaultTypeInternal _SplitCandidate_default_instance_;
class TreePath;
class TreePathDefaultTypeInternal;
extern TreePathDefaultTypeInternal _TreePath_default_instance_;
}  // namespace tensorforest
}  // namespace tensorflow
PROTOBUF_NAMESPACE_OPEN
template<> ::tensorflow::tensorforest::FertileSlot* Arena::CreateMaybeMessage<::tensorflow::tensorforest::FertileSlot>(Arena*);
template<> ::tensorflow::tensorforest::FertileStats* Arena::CreateMaybeMessage<::tensorflow::tensorforest::FertileStats>(Arena*);
template<> ::tensorflow::tensorforest::GiniStats* Arena::CreateMaybeMessage<::tensorflow::tensorforest::GiniStats>(Arena*);
template<> ::tensorflow::tensorforest::LeafStat* Arena::CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(Arena*);
template<> ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* Arena::CreateMaybeMessage<::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats>(Arena*);
template<> ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* Arena::CreateMaybeMessage<::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats>(Arena*);
template<> ::tensorflow::tensorforest::SplitCandidate* Arena::CreateMaybeMessage<::tensorflow::tensorforest::SplitCandidate>(Arena*);
template<> ::tensorflow::tensorforest::TreePath* Arena::CreateMaybeMessage<::tensorflow::tensorforest::TreePath>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tensorflow {
namespace tensorforest {

// ===================================================================

class FertileStats :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.FertileStats) */ {
 public:
  FertileStats();
  virtual ~FertileStats();

  FertileStats(const FertileStats& from);
  FertileStats(FertileStats&& from) noexcept
    : FertileStats() {
    *this = ::std::move(from);
  }

  inline FertileStats& operator=(const FertileStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline FertileStats& operator=(FertileStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FertileStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FertileStats* internal_default_instance() {
    return reinterpret_cast<const FertileStats*>(
               &_FertileStats_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    0;

  friend void swap(FertileStats& a, FertileStats& b) {
    a.Swap(&b);
  }
  inline void Swap(FertileStats* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FertileStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FertileStats* New() const final {
    return CreateMaybeMessage<FertileStats>(nullptr);
  }

  FertileStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FertileStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FertileStats& from);
  void MergeFrom(const FertileStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FertileStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.tensorforest.FertileStats";
  }
  protected:
  explicit FertileStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fertile_5fstats_2eproto);
    return ::descriptor_table_fertile_5fstats_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeToSlotFieldNumber = 1,
  };
  // repeated .tensorflow.tensorforest.FertileSlot node_to_slot = 1;
  int node_to_slot_size() const;
  void clear_node_to_slot();
  ::tensorflow::tensorforest::FertileSlot* mutable_node_to_slot(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot >*
      mutable_node_to_slot();
  const ::tensorflow::tensorforest::FertileSlot& node_to_slot(int index) const;
  ::tensorflow::tensorforest::FertileSlot* add_node_to_slot();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot >&
      node_to_slot() const;

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.FertileStats)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot > node_to_slot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fertile_5fstats_2eproto;
};
// -------------------------------------------------------------------

class GiniStats :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.GiniStats) */ {
 public:
  GiniStats();
  virtual ~GiniStats();

  GiniStats(const GiniStats& from);
  GiniStats(GiniStats&& from) noexcept
    : GiniStats() {
    *this = ::std::move(from);
  }

  inline GiniStats& operator=(const GiniStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline GiniStats& operator=(GiniStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GiniStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GiniStats* internal_default_instance() {
    return reinterpret_cast<const GiniStats*>(
               &_GiniStats_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    1;

  friend void swap(GiniStats& a, GiniStats& b) {
    a.Swap(&b);
  }
  inline void Swap(GiniStats* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GiniStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GiniStats* New() const final {
    return CreateMaybeMessage<GiniStats>(nullptr);
  }

  GiniStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GiniStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GiniStats& from);
  void MergeFrom(const GiniStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GiniStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.tensorforest.GiniStats";
  }
  protected:
  explicit GiniStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fertile_5fstats_2eproto);
    return ::descriptor_table_fertile_5fstats_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSquareFieldNumber = 2,
  };
  // float square = 2;
  void clear_square();
  float square() const;
  void set_square(float value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.GiniStats)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float square_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fertile_5fstats_2eproto;
};
// -------------------------------------------------------------------

class LeafStat_GiniImpurityClassificationStats :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats) */ {
 public:
  LeafStat_GiniImpurityClassificationStats();
  virtual ~LeafStat_GiniImpurityClassificationStats();

  LeafStat_GiniImpurityClassificationStats(const LeafStat_GiniImpurityClassificationStats& from);
  LeafStat_GiniImpurityClassificationStats(LeafStat_GiniImpurityClassificationStats&& from) noexcept
    : LeafStat_GiniImpurityClassificationStats() {
    *this = ::std::move(from);
  }

  inline LeafStat_GiniImpurityClassificationStats& operator=(const LeafStat_GiniImpurityClassificationStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeafStat_GiniImpurityClassificationStats& operator=(LeafStat_GiniImpurityClassificationStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeafStat_GiniImpurityClassificationStats& default_instance();

  enum CountsCase {
    kDenseCounts = 1,
    kSparseCounts = 2,
    COUNTS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeafStat_GiniImpurityClassificationStats* internal_default_instance() {
    return reinterpret_cast<const LeafStat_GiniImpurityClassificationStats*>(
               &_LeafStat_GiniImpurityClassificationStats_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    2;

  friend void swap(LeafStat_GiniImpurityClassificationStats& a, LeafStat_GiniImpurityClassificationStats& b) {
    a.Swap(&b);
  }
  inline void Swap(LeafStat_GiniImpurityClassificationStats* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeafStat_GiniImpurityClassificationStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeafStat_GiniImpurityClassificationStats* New() const final {
    return CreateMaybeMessage<LeafStat_GiniImpurityClassificationStats>(nullptr);
  }

  LeafStat_GiniImpurityClassificationStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeafStat_GiniImpurityClassificationStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeafStat_GiniImpurityClassificationStats& from);
  void MergeFrom(const LeafStat_GiniImpurityClassificationStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeafStat_GiniImpurityClassificationStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats";
  }
  protected:
  explicit LeafStat_GiniImpurityClassificationStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fertile_5fstats_2eproto);
    return ::descriptor_table_fertile_5fstats_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGiniFieldNumber = 3,
    kDenseCountsFieldNumber = 1,
    kSparseCountsFieldNumber = 2,
  };
  // .tensorflow.tensorforest.GiniStats gini = 3;
  bool has_gini() const;
  void clear_gini();
  const ::tensorflow::tensorforest::GiniStats& gini() const;
  ::tensorflow::tensorforest::GiniStats* release_gini();
  ::tensorflow::tensorforest::GiniStats* mutable_gini();
  void set_allocated_gini(::tensorflow::tensorforest::GiniStats* gini);
  void unsafe_arena_set_allocated_gini(
      ::tensorflow::tensorforest::GiniStats* gini);
  ::tensorflow::tensorforest::GiniStats* unsafe_arena_release_gini();

  // .tensorflow.decision_trees.Vector dense_counts = 1;
  bool has_dense_counts() const;
  void clear_dense_counts();
  const ::tensorflow::decision_trees::Vector& dense_counts() const;
  ::tensorflow::decision_trees::Vector* release_dense_counts();
  ::tensorflow::decision_trees::Vector* mutable_dense_counts();
  void set_allocated_dense_counts(::tensorflow::decision_trees::Vector* dense_counts);
  void unsafe_arena_set_allocated_dense_counts(
      ::tensorflow::decision_trees::Vector* dense_counts);
  ::tensorflow::decision_trees::Vector* unsafe_arena_release_dense_counts();

  // .tensorflow.decision_trees.SparseVector sparse_counts = 2;
  bool has_sparse_counts() const;
  void clear_sparse_counts();
  const ::tensorflow::decision_trees::SparseVector& sparse_counts() const;
  ::tensorflow::decision_trees::SparseVector* release_sparse_counts();
  ::tensorflow::decision_trees::SparseVector* mutable_sparse_counts();
  void set_allocated_sparse_counts(::tensorflow::decision_trees::SparseVector* sparse_counts);
  void unsafe_arena_set_allocated_sparse_counts(
      ::tensorflow::decision_trees::SparseVector* sparse_counts);
  ::tensorflow::decision_trees::SparseVector* unsafe_arena_release_sparse_counts();

  void clear_counts();
  CountsCase counts_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats)
 private:
  class _Internal;
  void set_has_dense_counts();
  void set_has_sparse_counts();

  inline bool has_counts() const;
  inline void clear_has_counts();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::tensorforest::GiniStats* gini_;
  union CountsUnion {
    CountsUnion() {}
    ::tensorflow::decision_trees::Vector* dense_counts_;
    ::tensorflow::decision_trees::SparseVector* sparse_counts_;
  } counts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_fertile_5fstats_2eproto;
};
// -------------------------------------------------------------------

class LeafStat_LeastSquaresRegressionStats :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats) */ {
 public:
  LeafStat_LeastSquaresRegressionStats();
  virtual ~LeafStat_LeastSquaresRegressionStats();

  LeafStat_LeastSquaresRegressionStats(const LeafStat_LeastSquaresRegressionStats& from);
  LeafStat_LeastSquaresRegressionStats(LeafStat_LeastSquaresRegressionStats&& from) noexcept
    : LeafStat_LeastSquaresRegressionStats() {
    *this = ::std::move(from);
  }

  inline LeafStat_LeastSquaresRegressionStats& operator=(const LeafStat_LeastSquaresRegressionStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeafStat_LeastSquaresRegressionStats& operator=(LeafStat_LeastSquaresRegressionStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeafStat_LeastSquaresRegressionStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeafStat_LeastSquaresRegressionStats* internal_default_instance() {
    return reinterpret_cast<const LeafStat_LeastSquaresRegressionStats*>(
               &_LeafStat_LeastSquaresRegressionStats_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    3;

  friend void swap(LeafStat_LeastSquaresRegressionStats& a, LeafStat_LeastSquaresRegressionStats& b) {
    a.Swap(&b);
  }
  inline void Swap(LeafStat_LeastSquaresRegressionStats* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeafStat_LeastSquaresRegressionStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeafStat_LeastSquaresRegressionStats* New() const final {
    return CreateMaybeMessage<LeafStat_LeastSquaresRegressionStats>(nullptr);
  }

  LeafStat_LeastSquaresRegressionStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeafStat_LeastSquaresRegressionStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeafStat_LeastSquaresRegressionStats& from);
  void MergeFrom(const LeafStat_LeastSquaresRegressionStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeafStat_LeastSquaresRegressionStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats";
  }
  protected:
  explicit LeafStat_LeastSquaresRegressionStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fertile_5fstats_2eproto);
    return ::descriptor_table_fertile_5fstats_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeanOutputFieldNumber = 1,
    kMeanOutputSquaresFieldNumber = 2,
  };
  // .tensorflow.decision_trees.Vector mean_output = 1;
  bool has_mean_output() const;
  void clear_mean_output();
  const ::tensorflow::decision_trees::Vector& mean_output() const;
  ::tensorflow::decision_trees::Vector* release_mean_output();
  ::tensorflow::decision_trees::Vector* mutable_mean_output();
  void set_allocated_mean_output(::tensorflow::decision_trees::Vector* mean_output);
  void unsafe_arena_set_allocated_mean_output(
      ::tensorflow::decision_trees::Vector* mean_output);
  ::tensorflow::decision_trees::Vector* unsafe_arena_release_mean_output();

  // .tensorflow.decision_trees.Vector mean_output_squares = 2;
  bool has_mean_output_squares() const;
  void clear_mean_output_squares();
  const ::tensorflow::decision_trees::Vector& mean_output_squares() const;
  ::tensorflow::decision_trees::Vector* release_mean_output_squares();
  ::tensorflow::decision_trees::Vector* mutable_mean_output_squares();
  void set_allocated_mean_output_squares(::tensorflow::decision_trees::Vector* mean_output_squares);
  void unsafe_arena_set_allocated_mean_output_squares(
      ::tensorflow::decision_trees::Vector* mean_output_squares);
  ::tensorflow::decision_trees::Vector* unsafe_arena_release_mean_output_squares();

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::decision_trees::Vector* mean_output_;
  ::tensorflow::decision_trees::Vector* mean_output_squares_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fertile_5fstats_2eproto;
};
// -------------------------------------------------------------------

class LeafStat :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.LeafStat) */ {
 public:
  LeafStat();
  virtual ~LeafStat();

  LeafStat(const LeafStat& from);
  LeafStat(LeafStat&& from) noexcept
    : LeafStat() {
    *this = ::std::move(from);
  }

  inline LeafStat& operator=(const LeafStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeafStat& operator=(LeafStat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeafStat& default_instance();

  enum LeafStatCase {
    kClassification = 1,
    kRegression = 2,
    LEAF_STAT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeafStat* internal_default_instance() {
    return reinterpret_cast<const LeafStat*>(
               &_LeafStat_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    4;

  friend void swap(LeafStat& a, LeafStat& b) {
    a.Swap(&b);
  }
  inline void Swap(LeafStat* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeafStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeafStat* New() const final {
    return CreateMaybeMessage<LeafStat>(nullptr);
  }

  LeafStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeafStat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeafStat& from);
  void MergeFrom(const LeafStat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeafStat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.tensorforest.LeafStat";
  }
  protected:
  explicit LeafStat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fertile_5fstats_2eproto);
    return ::descriptor_table_fertile_5fstats_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LeafStat_GiniImpurityClassificationStats GiniImpurityClassificationStats;
  typedef LeafStat_LeastSquaresRegressionStats LeastSquaresRegressionStats;

  // accessors -------------------------------------------------------

  enum : int {
    kWeightSumFieldNumber = 3,
    kClassificationFieldNumber = 1,
    kRegressionFieldNumber = 2,
  };
  // float weight_sum = 3;
  void clear_weight_sum();
  float weight_sum() const;
  void set_weight_sum(float value);

  // .tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats classification = 1;
  bool has_classification() const;
  void clear_classification();
  const ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats& classification() const;
  ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* release_classification();
  ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* mutable_classification();
  void set_allocated_classification(::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* classification);
  void unsafe_arena_set_allocated_classification(
      ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* classification);
  ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* unsafe_arena_release_classification();

  // .tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats regression = 2;
  bool has_regression() const;
  void clear_regression();
  const ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats& regression() const;
  ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* release_regression();
  ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* mutable_regression();
  void set_allocated_regression(::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* regression);
  void unsafe_arena_set_allocated_regression(
      ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* regression);
  ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* unsafe_arena_release_regression();

  void clear_leaf_stat();
  LeafStatCase leaf_stat_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.LeafStat)
 private:
  class _Internal;
  void set_has_classification();
  void set_has_regression();

  inline bool has_leaf_stat() const;
  inline void clear_has_leaf_stat();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float weight_sum_;
  union LeafStatUnion {
    LeafStatUnion() {}
    ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* classification_;
    ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* regression_;
  } leaf_stat_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_fertile_5fstats_2eproto;
};
// -------------------------------------------------------------------

class FertileSlot :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.FertileSlot) */ {
 public:
  FertileSlot();
  virtual ~FertileSlot();

  FertileSlot(const FertileSlot& from);
  FertileSlot(FertileSlot&& from) noexcept
    : FertileSlot() {
    *this = ::std::move(from);
  }

  inline FertileSlot& operator=(const FertileSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline FertileSlot& operator=(FertileSlot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FertileSlot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FertileSlot* internal_default_instance() {
    return reinterpret_cast<const FertileSlot*>(
               &_FertileSlot_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    5;

  friend void swap(FertileSlot& a, FertileSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(FertileSlot* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FertileSlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FertileSlot* New() const final {
    return CreateMaybeMessage<FertileSlot>(nullptr);
  }

  FertileSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FertileSlot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FertileSlot& from);
  void MergeFrom(const FertileSlot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FertileSlot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.tensorforest.FertileSlot";
  }
  protected:
  explicit FertileSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fertile_5fstats_2eproto);
    return ::descriptor_table_fertile_5fstats_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidatesFieldNumber = 1,
    kLeafStatsFieldNumber = 4,
    kPostInitLeafStatsFieldNumber = 6,
    kNodeIdFieldNumber = 5,
    kDepthFieldNumber = 7,
  };
  // repeated .tensorflow.tensorforest.SplitCandidate candidates = 1;
  int candidates_size() const;
  void clear_candidates();
  ::tensorflow::tensorforest::SplitCandidate* mutable_candidates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate >*
      mutable_candidates();
  const ::tensorflow::tensorforest::SplitCandidate& candidates(int index) const;
  ::tensorflow::tensorforest::SplitCandidate* add_candidates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate >&
      candidates() const;

  // .tensorflow.tensorforest.LeafStat leaf_stats = 4;
  bool has_leaf_stats() const;
  void clear_leaf_stats();
  const ::tensorflow::tensorforest::LeafStat& leaf_stats() const;
  ::tensorflow::tensorforest::LeafStat* release_leaf_stats();
  ::tensorflow::tensorforest::LeafStat* mutable_leaf_stats();
  void set_allocated_leaf_stats(::tensorflow::tensorforest::LeafStat* leaf_stats);
  void unsafe_arena_set_allocated_leaf_stats(
      ::tensorflow::tensorforest::LeafStat* leaf_stats);
  ::tensorflow::tensorforest::LeafStat* unsafe_arena_release_leaf_stats();

  // .tensorflow.tensorforest.LeafStat post_init_leaf_stats = 6;
  bool has_post_init_leaf_stats() const;
  void clear_post_init_leaf_stats();
  const ::tensorflow::tensorforest::LeafStat& post_init_leaf_stats() const;
  ::tensorflow::tensorforest::LeafStat* release_post_init_leaf_stats();
  ::tensorflow::tensorforest::LeafStat* mutable_post_init_leaf_stats();
  void set_allocated_post_init_leaf_stats(::tensorflow::tensorforest::LeafStat* post_init_leaf_stats);
  void unsafe_arena_set_allocated_post_init_leaf_stats(
      ::tensorflow::tensorforest::LeafStat* post_init_leaf_stats);
  ::tensorflow::tensorforest::LeafStat* unsafe_arena_release_post_init_leaf_stats();

  // int32 node_id = 5;
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 depth = 7;
  void clear_depth();
  ::PROTOBUF_NAMESPACE_ID::int32 depth() const;
  void set_depth(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.FertileSlot)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate > candidates_;
  ::tensorflow::tensorforest::LeafStat* leaf_stats_;
  ::tensorflow::tensorforest::LeafStat* post_init_leaf_stats_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 depth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fertile_5fstats_2eproto;
};
// -------------------------------------------------------------------

class SplitCandidate :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.SplitCandidate) */ {
 public:
  SplitCandidate();
  virtual ~SplitCandidate();

  SplitCandidate(const SplitCandidate& from);
  SplitCandidate(SplitCandidate&& from) noexcept
    : SplitCandidate() {
    *this = ::std::move(from);
  }

  inline SplitCandidate& operator=(const SplitCandidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SplitCandidate& operator=(SplitCandidate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SplitCandidate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitCandidate* internal_default_instance() {
    return reinterpret_cast<const SplitCandidate*>(
               &_SplitCandidate_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    6;

  friend void swap(SplitCandidate& a, SplitCandidate& b) {
    a.Swap(&b);
  }
  inline void Swap(SplitCandidate* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SplitCandidate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SplitCandidate* New() const final {
    return CreateMaybeMessage<SplitCandidate>(nullptr);
  }

  SplitCandidate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SplitCandidate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SplitCandidate& from);
  void MergeFrom(const SplitCandidate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplitCandidate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.tensorforest.SplitCandidate";
  }
  protected:
  explicit SplitCandidate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fertile_5fstats_2eproto);
    return ::descriptor_table_fertile_5fstats_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueIdFieldNumber = 6,
    kSplitFieldNumber = 1,
    kLeftStatsFieldNumber = 4,
    kRightStatsFieldNumber = 5,
  };
  // string unique_id = 6;
  void clear_unique_id();
  const std::string& unique_id() const;
  void set_unique_id(const std::string& value);
  void set_unique_id(std::string&& value);
  void set_unique_id(const char* value);
  void set_unique_id(const char* value, size_t size);
  std::string* mutable_unique_id();
  std::string* release_unique_id();
  void set_allocated_unique_id(std::string* unique_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_unique_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_unique_id(
      std::string* unique_id);

  // .tensorflow.decision_trees.BinaryNode split = 1;
  bool has_split() const;
  void clear_split();
  const ::tensorflow::decision_trees::BinaryNode& split() const;
  ::tensorflow::decision_trees::BinaryNode* release_split();
  ::tensorflow::decision_trees::BinaryNode* mutable_split();
  void set_allocated_split(::tensorflow::decision_trees::BinaryNode* split);
  void unsafe_arena_set_allocated_split(
      ::tensorflow::decision_trees::BinaryNode* split);
  ::tensorflow::decision_trees::BinaryNode* unsafe_arena_release_split();

  // .tensorflow.tensorforest.LeafStat left_stats = 4;
  bool has_left_stats() const;
  void clear_left_stats();
  const ::tensorflow::tensorforest::LeafStat& left_stats() const;
  ::tensorflow::tensorforest::LeafStat* release_left_stats();
  ::tensorflow::tensorforest::LeafStat* mutable_left_stats();
  void set_allocated_left_stats(::tensorflow::tensorforest::LeafStat* left_stats);
  void unsafe_arena_set_allocated_left_stats(
      ::tensorflow::tensorforest::LeafStat* left_stats);
  ::tensorflow::tensorforest::LeafStat* unsafe_arena_release_left_stats();

  // .tensorflow.tensorforest.LeafStat right_stats = 5;
  bool has_right_stats() const;
  void clear_right_stats();
  const ::tensorflow::tensorforest::LeafStat& right_stats() const;
  ::tensorflow::tensorforest::LeafStat* release_right_stats();
  ::tensorflow::tensorforest::LeafStat* mutable_right_stats();
  void set_allocated_right_stats(::tensorflow::tensorforest::LeafStat* right_stats);
  void unsafe_arena_set_allocated_right_stats(
      ::tensorflow::tensorforest::LeafStat* right_stats);
  ::tensorflow::tensorforest::LeafStat* unsafe_arena_release_right_stats();

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.SplitCandidate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_id_;
  ::tensorflow::decision_trees::BinaryNode* split_;
  ::tensorflow::tensorforest::LeafStat* left_stats_;
  ::tensorflow::tensorforest::LeafStat* right_stats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fertile_5fstats_2eproto;
};
// -------------------------------------------------------------------

class TreePath :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.tensorforest.TreePath) */ {
 public:
  TreePath();
  virtual ~TreePath();

  TreePath(const TreePath& from);
  TreePath(TreePath&& from) noexcept
    : TreePath() {
    *this = ::std::move(from);
  }

  inline TreePath& operator=(const TreePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreePath& operator=(TreePath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TreePath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreePath* internal_default_instance() {
    return reinterpret_cast<const TreePath*>(
               &_TreePath_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    7;

  friend void swap(TreePath& a, TreePath& b) {
    a.Swap(&b);
  }
  inline void Swap(TreePath* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TreePath* New() const final {
    return CreateMaybeMessage<TreePath>(nullptr);
  }

  TreePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TreePath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TreePath& from);
  void MergeFrom(const TreePath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreePath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.tensorforest.TreePath";
  }
  protected:
  explicit TreePath(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_fertile_5fstats_2eproto);
    return ::descriptor_table_fertile_5fstats_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesVisitedFieldNumber = 1,
  };
  // repeated .tensorflow.decision_trees.TreeNode nodes_visited = 1;
  int nodes_visited_size() const;
  void clear_nodes_visited();
  ::tensorflow::decision_trees::TreeNode* mutable_nodes_visited(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >*
      mutable_nodes_visited();
  const ::tensorflow::decision_trees::TreeNode& nodes_visited(int index) const;
  ::tensorflow::decision_trees::TreeNode* add_nodes_visited();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >&
      nodes_visited() const;

  // @@protoc_insertion_point(class_scope:tensorflow.tensorforest.TreePath)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode > nodes_visited_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_fertile_5fstats_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FertileStats

// repeated .tensorflow.tensorforest.FertileSlot node_to_slot = 1;
inline int FertileStats::node_to_slot_size() const {
  return node_to_slot_.size();
}
inline void FertileStats::clear_node_to_slot() {
  node_to_slot_.Clear();
}
inline ::tensorflow::tensorforest::FertileSlot* FertileStats::mutable_node_to_slot(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.FertileStats.node_to_slot)
  return node_to_slot_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot >*
FertileStats::mutable_node_to_slot() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.tensorforest.FertileStats.node_to_slot)
  return &node_to_slot_;
}
inline const ::tensorflow::tensorforest::FertileSlot& FertileStats::node_to_slot(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileStats.node_to_slot)
  return node_to_slot_.Get(index);
}
inline ::tensorflow::tensorforest::FertileSlot* FertileStats::add_node_to_slot() {
  // @@protoc_insertion_point(field_add:tensorflow.tensorforest.FertileStats.node_to_slot)
  return node_to_slot_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::FertileSlot >&
FertileStats::node_to_slot() const {
  // @@protoc_insertion_point(field_list:tensorflow.tensorforest.FertileStats.node_to_slot)
  return node_to_slot_;
}

// -------------------------------------------------------------------

// GiniStats

// float square = 2;
inline void GiniStats::clear_square() {
  square_ = 0;
}
inline float GiniStats::square() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.GiniStats.square)
  return square_;
}
inline void GiniStats::set_square(float value) {
  
  square_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.GiniStats.square)
}

// -------------------------------------------------------------------

// LeafStat_GiniImpurityClassificationStats

// .tensorflow.decision_trees.Vector dense_counts = 1;
inline bool LeafStat_GiniImpurityClassificationStats::has_dense_counts() const {
  return counts_case() == kDenseCounts;
}
inline void LeafStat_GiniImpurityClassificationStats::set_has_dense_counts() {
  _oneof_case_[0] = kDenseCounts;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_GiniImpurityClassificationStats::release_dense_counts() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
  if (has_dense_counts()) {
    clear_has_counts();
      ::tensorflow::decision_trees::Vector* temp = counts_.dense_counts_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    counts_.dense_counts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::Vector& LeafStat_GiniImpurityClassificationStats::dense_counts() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
  return has_dense_counts()
      ? *counts_.dense_counts_
      : *reinterpret_cast< ::tensorflow::decision_trees::Vector*>(&::tensorflow::decision_trees::_Vector_default_instance_);
}
inline ::tensorflow::decision_trees::Vector* LeafStat_GiniImpurityClassificationStats::unsafe_arena_release_dense_counts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
  if (has_dense_counts()) {
    clear_has_counts();
    ::tensorflow::decision_trees::Vector* temp = counts_.dense_counts_;
    counts_.dense_counts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LeafStat_GiniImpurityClassificationStats::unsafe_arena_set_allocated_dense_counts(::tensorflow::decision_trees::Vector* dense_counts) {
  clear_counts();
  if (dense_counts) {
    set_has_dense_counts();
    counts_.dense_counts_ = dense_counts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
}
inline ::tensorflow::decision_trees::Vector* LeafStat_GiniImpurityClassificationStats::mutable_dense_counts() {
  if (!has_dense_counts()) {
    clear_counts();
    set_has_dense_counts();
    counts_.dense_counts_ = CreateMaybeMessage< ::tensorflow::decision_trees::Vector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.dense_counts)
  return counts_.dense_counts_;
}

// .tensorflow.decision_trees.SparseVector sparse_counts = 2;
inline bool LeafStat_GiniImpurityClassificationStats::has_sparse_counts() const {
  return counts_case() == kSparseCounts;
}
inline void LeafStat_GiniImpurityClassificationStats::set_has_sparse_counts() {
  _oneof_case_[0] = kSparseCounts;
}
inline ::tensorflow::decision_trees::SparseVector* LeafStat_GiniImpurityClassificationStats::release_sparse_counts() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
  if (has_sparse_counts()) {
    clear_has_counts();
      ::tensorflow::decision_trees::SparseVector* temp = counts_.sparse_counts_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    counts_.sparse_counts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::SparseVector& LeafStat_GiniImpurityClassificationStats::sparse_counts() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
  return has_sparse_counts()
      ? *counts_.sparse_counts_
      : *reinterpret_cast< ::tensorflow::decision_trees::SparseVector*>(&::tensorflow::decision_trees::_SparseVector_default_instance_);
}
inline ::tensorflow::decision_trees::SparseVector* LeafStat_GiniImpurityClassificationStats::unsafe_arena_release_sparse_counts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
  if (has_sparse_counts()) {
    clear_has_counts();
    ::tensorflow::decision_trees::SparseVector* temp = counts_.sparse_counts_;
    counts_.sparse_counts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LeafStat_GiniImpurityClassificationStats::unsafe_arena_set_allocated_sparse_counts(::tensorflow::decision_trees::SparseVector* sparse_counts) {
  clear_counts();
  if (sparse_counts) {
    set_has_sparse_counts();
    counts_.sparse_counts_ = sparse_counts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
}
inline ::tensorflow::decision_trees::SparseVector* LeafStat_GiniImpurityClassificationStats::mutable_sparse_counts() {
  if (!has_sparse_counts()) {
    clear_counts();
    set_has_sparse_counts();
    counts_.sparse_counts_ = CreateMaybeMessage< ::tensorflow::decision_trees::SparseVector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.sparse_counts)
  return counts_.sparse_counts_;
}

// .tensorflow.tensorforest.GiniStats gini = 3;
inline bool LeafStat_GiniImpurityClassificationStats::has_gini() const {
  return this != internal_default_instance() && gini_ != nullptr;
}
inline void LeafStat_GiniImpurityClassificationStats::clear_gini() {
  if (GetArenaNoVirtual() == nullptr && gini_ != nullptr) {
    delete gini_;
  }
  gini_ = nullptr;
}
inline const ::tensorflow::tensorforest::GiniStats& LeafStat_GiniImpurityClassificationStats::gini() const {
  const ::tensorflow::tensorforest::GiniStats* p = gini_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::GiniStats*>(
      &::tensorflow::tensorforest::_GiniStats_default_instance_);
}
inline ::tensorflow::tensorforest::GiniStats* LeafStat_GiniImpurityClassificationStats::release_gini() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
  
  ::tensorflow::tensorforest::GiniStats* temp = gini_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  gini_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::GiniStats* LeafStat_GiniImpurityClassificationStats::unsafe_arena_release_gini() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
  
  ::tensorflow::tensorforest::GiniStats* temp = gini_;
  gini_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::GiniStats* LeafStat_GiniImpurityClassificationStats::mutable_gini() {
  
  if (gini_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::GiniStats>(GetArenaNoVirtual());
    gini_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
  return gini_;
}
inline void LeafStat_GiniImpurityClassificationStats::set_allocated_gini(::tensorflow::tensorforest::GiniStats* gini) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gini_;
  }
  if (gini) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gini);
    if (message_arena != submessage_arena) {
      gini = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gini, submessage_arena);
    }
    
  } else {
    
  }
  gini_ = gini;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats.gini)
}

inline bool LeafStat_GiniImpurityClassificationStats::has_counts() const {
  return counts_case() != COUNTS_NOT_SET;
}
inline void LeafStat_GiniImpurityClassificationStats::clear_has_counts() {
  _oneof_case_[0] = COUNTS_NOT_SET;
}
inline LeafStat_GiniImpurityClassificationStats::CountsCase LeafStat_GiniImpurityClassificationStats::counts_case() const {
  return LeafStat_GiniImpurityClassificationStats::CountsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LeafStat_LeastSquaresRegressionStats

// .tensorflow.decision_trees.Vector mean_output = 1;
inline bool LeafStat_LeastSquaresRegressionStats::has_mean_output() const {
  return this != internal_default_instance() && mean_output_ != nullptr;
}
inline const ::tensorflow::decision_trees::Vector& LeafStat_LeastSquaresRegressionStats::mean_output() const {
  const ::tensorflow::decision_trees::Vector* p = mean_output_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::Vector*>(
      &::tensorflow::decision_trees::_Vector_default_instance_);
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::release_mean_output() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
  
  ::tensorflow::decision_trees::Vector* temp = mean_output_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  mean_output_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::unsafe_arena_release_mean_output() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
  
  ::tensorflow::decision_trees::Vector* temp = mean_output_;
  mean_output_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::mutable_mean_output() {
  
  if (mean_output_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::Vector>(GetArenaNoVirtual());
    mean_output_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
  return mean_output_;
}
inline void LeafStat_LeastSquaresRegressionStats::set_allocated_mean_output(::tensorflow::decision_trees::Vector* mean_output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mean_output_);
  }
  if (mean_output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mean_output)->GetArena();
    if (message_arena != submessage_arena) {
      mean_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mean_output, submessage_arena);
    }
    
  } else {
    
  }
  mean_output_ = mean_output;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output)
}

// .tensorflow.decision_trees.Vector mean_output_squares = 2;
inline bool LeafStat_LeastSquaresRegressionStats::has_mean_output_squares() const {
  return this != internal_default_instance() && mean_output_squares_ != nullptr;
}
inline const ::tensorflow::decision_trees::Vector& LeafStat_LeastSquaresRegressionStats::mean_output_squares() const {
  const ::tensorflow::decision_trees::Vector* p = mean_output_squares_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::Vector*>(
      &::tensorflow::decision_trees::_Vector_default_instance_);
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::release_mean_output_squares() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
  
  ::tensorflow::decision_trees::Vector* temp = mean_output_squares_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  mean_output_squares_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::unsafe_arena_release_mean_output_squares() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
  
  ::tensorflow::decision_trees::Vector* temp = mean_output_squares_;
  mean_output_squares_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Vector* LeafStat_LeastSquaresRegressionStats::mutable_mean_output_squares() {
  
  if (mean_output_squares_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::Vector>(GetArenaNoVirtual());
    mean_output_squares_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
  return mean_output_squares_;
}
inline void LeafStat_LeastSquaresRegressionStats::set_allocated_mean_output_squares(::tensorflow::decision_trees::Vector* mean_output_squares) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mean_output_squares_);
  }
  if (mean_output_squares) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mean_output_squares)->GetArena();
    if (message_arena != submessage_arena) {
      mean_output_squares = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mean_output_squares, submessage_arena);
    }
    
  } else {
    
  }
  mean_output_squares_ = mean_output_squares;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats.mean_output_squares)
}

// -------------------------------------------------------------------

// LeafStat

// float weight_sum = 3;
inline void LeafStat::clear_weight_sum() {
  weight_sum_ = 0;
}
inline float LeafStat::weight_sum() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.weight_sum)
  return weight_sum_;
}
inline void LeafStat::set_weight_sum(float value) {
  
  weight_sum_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.LeafStat.weight_sum)
}

// .tensorflow.tensorforest.LeafStat.GiniImpurityClassificationStats classification = 1;
inline bool LeafStat::has_classification() const {
  return leaf_stat_case() == kClassification;
}
inline void LeafStat::set_has_classification() {
  _oneof_case_[0] = kClassification;
}
inline void LeafStat::clear_classification() {
  if (has_classification()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete leaf_stat_.classification_;
    }
    clear_has_leaf_stat();
  }
}
inline ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* LeafStat::release_classification() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.classification)
  if (has_classification()) {
    clear_has_leaf_stat();
      ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* temp = leaf_stat_.classification_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    leaf_stat_.classification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats& LeafStat::classification() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.classification)
  return has_classification()
      ? *leaf_stat_.classification_
      : *reinterpret_cast< ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats*>(&::tensorflow::tensorforest::_LeafStat_GiniImpurityClassificationStats_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* LeafStat::unsafe_arena_release_classification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.classification)
  if (has_classification()) {
    clear_has_leaf_stat();
    ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* temp = leaf_stat_.classification_;
    leaf_stat_.classification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LeafStat::unsafe_arena_set_allocated_classification(::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* classification) {
  clear_leaf_stat();
  if (classification) {
    set_has_classification();
    leaf_stat_.classification_ = classification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.LeafStat.classification)
}
inline ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats* LeafStat::mutable_classification() {
  if (!has_classification()) {
    clear_leaf_stat();
    set_has_classification();
    leaf_stat_.classification_ = CreateMaybeMessage< ::tensorflow::tensorforest::LeafStat_GiniImpurityClassificationStats >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.classification)
  return leaf_stat_.classification_;
}

// .tensorflow.tensorforest.LeafStat.LeastSquaresRegressionStats regression = 2;
inline bool LeafStat::has_regression() const {
  return leaf_stat_case() == kRegression;
}
inline void LeafStat::set_has_regression() {
  _oneof_case_[0] = kRegression;
}
inline void LeafStat::clear_regression() {
  if (has_regression()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete leaf_stat_.regression_;
    }
    clear_has_leaf_stat();
  }
}
inline ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* LeafStat::release_regression() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.LeafStat.regression)
  if (has_regression()) {
    clear_has_leaf_stat();
      ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* temp = leaf_stat_.regression_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    leaf_stat_.regression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats& LeafStat::regression() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.LeafStat.regression)
  return has_regression()
      ? *leaf_stat_.regression_
      : *reinterpret_cast< ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats*>(&::tensorflow::tensorforest::_LeafStat_LeastSquaresRegressionStats_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* LeafStat::unsafe_arena_release_regression() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.LeafStat.regression)
  if (has_regression()) {
    clear_has_leaf_stat();
    ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* temp = leaf_stat_.regression_;
    leaf_stat_.regression_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LeafStat::unsafe_arena_set_allocated_regression(::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* regression) {
  clear_leaf_stat();
  if (regression) {
    set_has_regression();
    leaf_stat_.regression_ = regression;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.LeafStat.regression)
}
inline ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats* LeafStat::mutable_regression() {
  if (!has_regression()) {
    clear_leaf_stat();
    set_has_regression();
    leaf_stat_.regression_ = CreateMaybeMessage< ::tensorflow::tensorforest::LeafStat_LeastSquaresRegressionStats >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.LeafStat.regression)
  return leaf_stat_.regression_;
}

inline bool LeafStat::has_leaf_stat() const {
  return leaf_stat_case() != LEAF_STAT_NOT_SET;
}
inline void LeafStat::clear_has_leaf_stat() {
  _oneof_case_[0] = LEAF_STAT_NOT_SET;
}
inline LeafStat::LeafStatCase LeafStat::leaf_stat_case() const {
  return LeafStat::LeafStatCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FertileSlot

// .tensorflow.tensorforest.LeafStat leaf_stats = 4;
inline bool FertileSlot::has_leaf_stats() const {
  return this != internal_default_instance() && leaf_stats_ != nullptr;
}
inline void FertileSlot::clear_leaf_stats() {
  if (GetArenaNoVirtual() == nullptr && leaf_stats_ != nullptr) {
    delete leaf_stats_;
  }
  leaf_stats_ = nullptr;
}
inline const ::tensorflow::tensorforest::LeafStat& FertileSlot::leaf_stats() const {
  const ::tensorflow::tensorforest::LeafStat* p = leaf_stats_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.leaf_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::LeafStat*>(
      &::tensorflow::tensorforest::_LeafStat_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::release_leaf_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.FertileSlot.leaf_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = leaf_stats_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  leaf_stats_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::unsafe_arena_release_leaf_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.FertileSlot.leaf_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = leaf_stats_;
  leaf_stats_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::mutable_leaf_stats() {
  
  if (leaf_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(GetArenaNoVirtual());
    leaf_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.FertileSlot.leaf_stats)
  return leaf_stats_;
}
inline void FertileSlot::set_allocated_leaf_stats(::tensorflow::tensorforest::LeafStat* leaf_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete leaf_stats_;
  }
  if (leaf_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(leaf_stats);
    if (message_arena != submessage_arena) {
      leaf_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, leaf_stats, submessage_arena);
    }
    
  } else {
    
  }
  leaf_stats_ = leaf_stats;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.FertileSlot.leaf_stats)
}

// repeated .tensorflow.tensorforest.SplitCandidate candidates = 1;
inline int FertileSlot::candidates_size() const {
  return candidates_.size();
}
inline void FertileSlot::clear_candidates() {
  candidates_.Clear();
}
inline ::tensorflow::tensorforest::SplitCandidate* FertileSlot::mutable_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.FertileSlot.candidates)
  return candidates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate >*
FertileSlot::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.tensorforest.FertileSlot.candidates)
  return &candidates_;
}
inline const ::tensorflow::tensorforest::SplitCandidate& FertileSlot::candidates(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.candidates)
  return candidates_.Get(index);
}
inline ::tensorflow::tensorforest::SplitCandidate* FertileSlot::add_candidates() {
  // @@protoc_insertion_point(field_add:tensorflow.tensorforest.FertileSlot.candidates)
  return candidates_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::tensorforest::SplitCandidate >&
FertileSlot::candidates() const {
  // @@protoc_insertion_point(field_list:tensorflow.tensorforest.FertileSlot.candidates)
  return candidates_;
}

// .tensorflow.tensorforest.LeafStat post_init_leaf_stats = 6;
inline bool FertileSlot::has_post_init_leaf_stats() const {
  return this != internal_default_instance() && post_init_leaf_stats_ != nullptr;
}
inline void FertileSlot::clear_post_init_leaf_stats() {
  if (GetArenaNoVirtual() == nullptr && post_init_leaf_stats_ != nullptr) {
    delete post_init_leaf_stats_;
  }
  post_init_leaf_stats_ = nullptr;
}
inline const ::tensorflow::tensorforest::LeafStat& FertileSlot::post_init_leaf_stats() const {
  const ::tensorflow::tensorforest::LeafStat* p = post_init_leaf_stats_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::LeafStat*>(
      &::tensorflow::tensorforest::_LeafStat_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::release_post_init_leaf_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = post_init_leaf_stats_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  post_init_leaf_stats_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::unsafe_arena_release_post_init_leaf_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = post_init_leaf_stats_;
  post_init_leaf_stats_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* FertileSlot::mutable_post_init_leaf_stats() {
  
  if (post_init_leaf_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(GetArenaNoVirtual());
    post_init_leaf_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
  return post_init_leaf_stats_;
}
inline void FertileSlot::set_allocated_post_init_leaf_stats(::tensorflow::tensorforest::LeafStat* post_init_leaf_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete post_init_leaf_stats_;
  }
  if (post_init_leaf_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(post_init_leaf_stats);
    if (message_arena != submessage_arena) {
      post_init_leaf_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, post_init_leaf_stats, submessage_arena);
    }
    
  } else {
    
  }
  post_init_leaf_stats_ = post_init_leaf_stats;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.FertileSlot.post_init_leaf_stats)
}

// int32 node_id = 5;
inline void FertileSlot::clear_node_id() {
  node_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FertileSlot::node_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.node_id)
  return node_id_;
}
inline void FertileSlot::set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  node_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.FertileSlot.node_id)
}

// int32 depth = 7;
inline void FertileSlot::clear_depth() {
  depth_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FertileSlot::depth() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.FertileSlot.depth)
  return depth_;
}
inline void FertileSlot::set_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  depth_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.FertileSlot.depth)
}

// -------------------------------------------------------------------

// SplitCandidate

// .tensorflow.decision_trees.BinaryNode split = 1;
inline bool SplitCandidate::has_split() const {
  return this != internal_default_instance() && split_ != nullptr;
}
inline const ::tensorflow::decision_trees::BinaryNode& SplitCandidate::split() const {
  const ::tensorflow::decision_trees::BinaryNode* p = split_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitCandidate.split)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::BinaryNode*>(
      &::tensorflow::decision_trees::_BinaryNode_default_instance_);
}
inline ::tensorflow::decision_trees::BinaryNode* SplitCandidate::release_split() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitCandidate.split)
  
  ::tensorflow::decision_trees::BinaryNode* temp = split_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  split_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::BinaryNode* SplitCandidate::unsafe_arena_release_split() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.SplitCandidate.split)
  
  ::tensorflow::decision_trees::BinaryNode* temp = split_;
  split_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::BinaryNode* SplitCandidate::mutable_split() {
  
  if (split_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::BinaryNode>(GetArenaNoVirtual());
    split_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitCandidate.split)
  return split_;
}
inline void SplitCandidate::set_allocated_split(::tensorflow::decision_trees::BinaryNode* split) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(split_);
  }
  if (split) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(split)->GetArena();
    if (message_arena != submessage_arena) {
      split = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, split, submessage_arena);
    }
    
  } else {
    
  }
  split_ = split;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitCandidate.split)
}

// .tensorflow.tensorforest.LeafStat left_stats = 4;
inline bool SplitCandidate::has_left_stats() const {
  return this != internal_default_instance() && left_stats_ != nullptr;
}
inline void SplitCandidate::clear_left_stats() {
  if (GetArenaNoVirtual() == nullptr && left_stats_ != nullptr) {
    delete left_stats_;
  }
  left_stats_ = nullptr;
}
inline const ::tensorflow::tensorforest::LeafStat& SplitCandidate::left_stats() const {
  const ::tensorflow::tensorforest::LeafStat* p = left_stats_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitCandidate.left_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::LeafStat*>(
      &::tensorflow::tensorforest::_LeafStat_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::release_left_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitCandidate.left_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = left_stats_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  left_stats_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::unsafe_arena_release_left_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.SplitCandidate.left_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = left_stats_;
  left_stats_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::mutable_left_stats() {
  
  if (left_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(GetArenaNoVirtual());
    left_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitCandidate.left_stats)
  return left_stats_;
}
inline void SplitCandidate::set_allocated_left_stats(::tensorflow::tensorforest::LeafStat* left_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_stats_;
  }
  if (left_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(left_stats);
    if (message_arena != submessage_arena) {
      left_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_stats, submessage_arena);
    }
    
  } else {
    
  }
  left_stats_ = left_stats;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitCandidate.left_stats)
}

// .tensorflow.tensorforest.LeafStat right_stats = 5;
inline bool SplitCandidate::has_right_stats() const {
  return this != internal_default_instance() && right_stats_ != nullptr;
}
inline void SplitCandidate::clear_right_stats() {
  if (GetArenaNoVirtual() == nullptr && right_stats_ != nullptr) {
    delete right_stats_;
  }
  right_stats_ = nullptr;
}
inline const ::tensorflow::tensorforest::LeafStat& SplitCandidate::right_stats() const {
  const ::tensorflow::tensorforest::LeafStat* p = right_stats_;
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitCandidate.right_stats)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::tensorforest::LeafStat*>(
      &::tensorflow::tensorforest::_LeafStat_default_instance_);
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::release_right_stats() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitCandidate.right_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = right_stats_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  right_stats_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::unsafe_arena_release_right_stats() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.SplitCandidate.right_stats)
  
  ::tensorflow::tensorforest::LeafStat* temp = right_stats_;
  right_stats_ = nullptr;
  return temp;
}
inline ::tensorflow::tensorforest::LeafStat* SplitCandidate::mutable_right_stats() {
  
  if (right_stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::tensorforest::LeafStat>(GetArenaNoVirtual());
    right_stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitCandidate.right_stats)
  return right_stats_;
}
inline void SplitCandidate::set_allocated_right_stats(::tensorflow::tensorforest::LeafStat* right_stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_stats_;
  }
  if (right_stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(right_stats);
    if (message_arena != submessage_arena) {
      right_stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_stats, submessage_arena);
    }
    
  } else {
    
  }
  right_stats_ = right_stats;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitCandidate.right_stats)
}

// string unique_id = 6;
inline void SplitCandidate::clear_unique_id() {
  unique_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const std::string& SplitCandidate::unique_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.SplitCandidate.unique_id)
  return unique_id_.Get();
}
inline void SplitCandidate::set_unique_id(const std::string& value) {
  
  unique_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:tensorflow.tensorforest.SplitCandidate.unique_id)
}
inline void SplitCandidate::set_unique_id(std::string&& value) {
  
  unique_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.tensorforest.SplitCandidate.unique_id)
}
inline void SplitCandidate::set_unique_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  unique_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:tensorflow.tensorforest.SplitCandidate.unique_id)
}
inline void SplitCandidate::set_unique_id(const char* value,
    size_t size) {
  
  unique_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:tensorflow.tensorforest.SplitCandidate.unique_id)
}
inline std::string* SplitCandidate::mutable_unique_id() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.SplitCandidate.unique_id)
  return unique_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline std::string* SplitCandidate::release_unique_id() {
  // @@protoc_insertion_point(field_release:tensorflow.tensorforest.SplitCandidate.unique_id)
  
  return unique_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void SplitCandidate::set_allocated_unique_id(std::string* unique_id) {
  if (unique_id != nullptr) {
    
  } else {
    
  }
  unique_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_id,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:tensorflow.tensorforest.SplitCandidate.unique_id)
}
inline std::string* SplitCandidate::unsafe_arena_release_unique_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.tensorforest.SplitCandidate.unique_id)
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  
  return unique_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void SplitCandidate::unsafe_arena_set_allocated_unique_id(
    std::string* unique_id) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != nullptr);
  if (unique_id != nullptr) {
    
  } else {
    
  }
  unique_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      unique_id, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.tensorforest.SplitCandidate.unique_id)
}

// -------------------------------------------------------------------

// TreePath

// repeated .tensorflow.decision_trees.TreeNode nodes_visited = 1;
inline int TreePath::nodes_visited_size() const {
  return nodes_visited_.size();
}
inline ::tensorflow::decision_trees::TreeNode* TreePath::mutable_nodes_visited(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.tensorforest.TreePath.nodes_visited)
  return nodes_visited_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >*
TreePath::mutable_nodes_visited() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.tensorforest.TreePath.nodes_visited)
  return &nodes_visited_;
}
inline const ::tensorflow::decision_trees::TreeNode& TreePath::nodes_visited(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.tensorforest.TreePath.nodes_visited)
  return nodes_visited_.Get(index);
}
inline ::tensorflow::decision_trees::TreeNode* TreePath::add_nodes_visited() {
  // @@protoc_insertion_point(field_add:tensorflow.tensorforest.TreePath.nodes_visited)
  return nodes_visited_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >&
TreePath::nodes_visited() const {
  // @@protoc_insertion_point(field_list:tensorflow.tensorforest.TreePath.nodes_visited)
  return nodes_visited_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorforest
}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#include "protobuf/port_undef.inc"
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fertile_5fstats_2eproto
