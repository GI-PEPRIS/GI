/*!
 * The AnyBase package of PetroCOVERY Solution is a collection of native C++ classes that 
 * implement the fundamental algorithms & operations required to 
 * satisfy COMMON DEMANDS of other packages.
 *
 * Copyright (C) 2015 XIUJIE SHENG
 *
 * This library isn't a free software, so you cann't take the source code without author's permit.
 * Of course, there is NO ANY WARRANTY that this library will not harm your computer or ongoing 
 * business if you illegally got it. 
 *
 * NOTE: 
 * AUTHOR WOULD ALWAYS RESERVE LEGAL RIGHT TO PROTECT WHAT HE HAVE DONE ACCORDING TO
 * LOCAL OR INTERNATIONAL COPYRIGHT OR RELATIVE LAW(S).
 *
 * For more information, contact:
 *
 * China University of Geoseciences(Wuhan)
 * Resource Faculty
 *
 * Xiujie Sheng
 * herman.sheng@gmail.com
 */
#ifndef __ANYBASE_FILEBASIC_H__
#define __ANYBASE_FILEBASIC_H__

// Refer to Export and Import macroes
#include "anybase.h"

// Refer to utility functions encapsulated by <code> CAnyDirBasic </code>
#include "anydirbasic.h"

// UeBase
namespace AnyBase
{
	/**
	* Basic and different kinds of operations when accessing one file and it is also the set of utility .
	*
	* This class supports different ways to access one file including std C, native functions relative one OS etc, 
	* different modes for CRUD etc. Of course, those plain file also should include URL etc. But this class shouldn't
	* support special file kind like COM etc as it need more parameters-depedent.
	*
	* There is an obvious advantage that when facing port issues, we only have to focus here but not every where. However,
	* it should cause little performance penality when opening or writing one file since there are some decision conditions
	* before really playing.
	*
	* Note:
	* The default data stream here is always binary stream not text
	*/
	class ANYBASE_CLASS CAnyFileBasic
	{
	public:
		/**
		* Different file libraries
		*/
		enum UtilityLib
		{
			UL_Unknown = 0,	// Not specified yet
			UL_Stand,		// Refer to standard C libraries
			UL_STL,			// Refer to STL
			UL_Native,		// Limited to one concrete os
			UL_Posix		// Native C
		};

		/**
		* Encapsulate different file open mode
		*/
#if __STDC__
		const static int ANY_SEEK_BEGIN = SEEK_SET;
		const static int ANY_SEEK_CUR = SEEK_CUR;
		const static int ANY_SEEK_END = SEEK_END;
#endif

#if (WIN32)
		// Open modes
		const static int ANY_FILE_APPEND	= 0; // This macro shouldn't play role when using Windows APIs
		const static int ANY_FILE_WRITE = GENERIC_WRITE;
		const static int ANY_FILE_READ = GENERIC_READ;
		const static int ANY_FILE_EXECUTE = GENERIC_EXECUTE;
		const static int ANY_FILE_ALL = GENERIC_ALL;
#elif
		// TODO:
		#pragma message("Here lack defintions!")
#endif

	private:
		//
		// Constructors & deconstructor: this class shouldn't occur in any sence except for as one singleton
		//
		/**
		* Default constructor.
		*
		* Since it needs at least one construcotor to resolve its member refer to which, but there should make caution
		* about the initialization order of <code> CAnyDirBasic </code> and <code> CAnyFileBasic </code> considering issues
		* about static variable initialization
		*/
		CAnyFileBasic() : m_pathBasic(CAnyDirBasic::Get())
		{
		}

		/**
		* Deconstructor.
		*
		* Occuring accompany the constructor definition not decalaration: since this class can occur, it must have its
		* dctr implementation.
		*/
		~CAnyFileBasic()
		{
		}

		/**
		* Copy constructor & operator =.
		*
		* No any secenes to let this class occur except for the initialization of static variable.
		*/
		CAnyFileBasic(const CAnyFileBasic &other);
		const CAnyFileBasic &operator=(const CAnyFileBasic &other);

	public:
		//
		// File access operations
		//
		// Note: Since we are reluctant to declare any member variables in this class for the reason of singletion,
		// we have to pass extra parameters in order to indicate some statuses while impose stronger pre-condition
		// before using below functions as they should follow the same status, for example, follow the same utility
		// lib.
		//
		/**
		*	Check validity of one file handle according to different <code> UtilityLib </code> definition.
		*
		* @param fileHandle the file handle generated by <code> OpenFile </code>
		*/
		bool IsValidHandle(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;

		/**
		* Get defintion of valid handle against different I/O APIs
		*/
		void *GetValidHandle(UtilityLib ioLib = UL_Stand) const;

		/**
		* Open a file accoring to specified utility library.
		*
		* @param fileName which file be opened
		* @param mode all access mode in string way
		* @return the maximum generality of different data types and it can be converted into
		* counterparts: HANDLE for FL_Native, FILE for FL_Stand etc.
		*/
		void *OpenFile(const anystring &fileName, int mode = ANY_FILE_ALL, UtilityLib ioLib = UL_Stand) const;
		void SetFileBuffer(void *fileHandle, int bufsize,UtilityLib ioLib = UL_Stand) const;

		/**
		* Move current reader pointer.
		*
		* Note: this function currently is limited to UL_Stand lib.
		*/
		bool SeekFile(void *const fileHandle, long long offset, int whence = ANY_SEEK_BEGIN, UtilityLib ioLib = UL_Stand) const;

		/**
		* Read File.
		*
		* Note:
		* Here no any constness semantic definition for parameter buf since it maybe null and need to be allocated then filled
		* in this function side.
		* But when passing the pointer to pointer to one stack variable, should be careful:
		* STRUCT str[10];
		* STRUCT *strPointer = &str;
		* ReadFile(,,(void **)(&strPointer))
		*
		* @param fileHandle the file handle
		* @param buf the pointer to pointer to one memory in order to support memory allocation by this function.
		* @param size the data size for read
		* @param count the number of data unit in specified size while indicating how many it read
		* @param ioLib delegate to which utility libraries
		* @return whether successifully do once read action even if it only read part
		*/
		bool ReadFile(void *const fileHandle, void **buf, int size, int &count, UtilityLib ioLib = UL_Stand) const;

		/**
		* Write file.
		*
		*/
		bool WriteFile(void *const fileHandle, const void *const buf, int size, int count, UtilityLib ioLib = UL_Stand) const;

		/**
		* Write those content not stored into disk file yet.
		*
		* Note: this function currently is limited to UL_Stand lib.
		*/
		bool FlushFile(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;

		/**
		*
		*/
		long long GetFileSize(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;

		/**
		*
		*/
		long long TellFilePos(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;

		/**
		* Close file handle.
		*/
		void CloseFile(void *const fileHandle, UtilityLib ioLib = UL_Stand) const;

		/*!
		*
		**/
		char *GetLine(char *buffer, int maximum, void *fileHandle) const;

		//
		// Memory mapping mechansim
		// Note: the mapped memory just be shared in readable not writable way.
		//
		/**
		* Directly map the file into the memory address.
		*
		* The defintion of this function is simply defined by those MS APIs related to file mapping mechansim, so some
		* parameters maybe play nothing when porting to other OS variaties. The advantage of this function is at least obvious that
		* no more than one code peices scattered every where, just here:)
		*
		* @param oneFile the file needed to be mapped
		* @param fileHandle the handle when opening this file
		* @param memoryHandle the mapped handle related to OS MMU, namely, memory management unit.
		* @param ioLib use which mapping mechansim which limited to one OS generally
		* @return the pointer to the first position of memory block just mapped
		*/
		bool CreateMemoryMapping(const anystring &oneFile, void **fileHandle, void **memoryHandle, void **memoryData, UtilityLib ioLib = UL_Stand) const;

		/**
		* Release memory kinds for mapping mechanism: file handle, mapping handle, virtual memory mapped
		* Note:
		* Here still pass two dimensions of pointers in order to assign correct value after release action according to
		* different I/O libraries
		*
		*/
		bool ReleaseMemoryMapping(void **fileHandle, void **memoryHandle, void **memoryData, UtilityLib ioLib = UL_Stand) const;

		// 
		// Singletion function
		//
		/**
		* Extra work is to initialize the static variable when the first time to call this function
		*/
		static const CAnyFileBasic &Get();

	private:
		// Refer to utility functions for path operations
		const CAnyDirBasic &m_pathBasic;
	};
}
#endif