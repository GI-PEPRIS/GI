// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: generic_tree_model.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_generic_5ftree_5fmodel_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_generic_5ftree_5fmodel_2eproto

#include <limits>
#include <string>

#include "protobuf/port_def.inc"
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include "protobuf/port_undef.inc"
#include "protobuf/io/coded_stream.h"
#include "protobuf/arena.h"
#include "protobuf/arenastring.h"
#include "protobuf/generated_message_table_driven.h"
#include "protobuf/generated_message_util.h"
#include "protobuf/inlined_string_field.h"
#include "protobuf/metadata.h"
#include "protobuf/generated_message_reflection.h"
#include "protobuf/message.h"
#include "protobuf/repeated_field.h"  // IWYU pragma: export
#include "protobuf/extension_set.h"  // IWYU pragma: export
#include "protobuf/map.h"  // IWYU pragma: export
#include "protobuf/map_entry.h"
#include "protobuf/map_field_inl.h"
#include "protobuf/generated_enum_reflection.h"
#include "protobuf/unknown_field_set.h"
#include "protobuf/any.pb.h"
#include "protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)
#include "protobuf/port_def.inc"
#define PROTOBUF_INTERNAL_EXPORT_generic_5ftree_5fmodel_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_generic_5ftree_5fmodel_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_generic_5ftree_5fmodel_2eproto;
namespace tensorflow {
namespace decision_trees {
class Averaging;
class AveragingDefaultTypeInternal;
extern AveragingDefaultTypeInternal _Averaging_default_instance_;
class BinaryNode;
class BinaryNodeDefaultTypeInternal;
extern BinaryNodeDefaultTypeInternal _BinaryNode_default_instance_;
class DecisionTree;
class DecisionTreeDefaultTypeInternal;
extern DecisionTreeDefaultTypeInternal _DecisionTree_default_instance_;
class Ensemble;
class EnsembleDefaultTypeInternal;
extern EnsembleDefaultTypeInternal _Ensemble_default_instance_;
class Ensemble_Member;
class Ensemble_MemberDefaultTypeInternal;
extern Ensemble_MemberDefaultTypeInternal _Ensemble_Member_default_instance_;
class FeatureId;
class FeatureIdDefaultTypeInternal;
extern FeatureIdDefaultTypeInternal _FeatureId_default_instance_;
class InequalityTest;
class InequalityTestDefaultTypeInternal;
extern InequalityTestDefaultTypeInternal _InequalityTest_default_instance_;
class Leaf;
class LeafDefaultTypeInternal;
extern LeafDefaultTypeInternal _Leaf_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelAndFeatures;
class ModelAndFeaturesDefaultTypeInternal;
extern ModelAndFeaturesDefaultTypeInternal _ModelAndFeatures_default_instance_;
class ModelAndFeatures_Feature;
class ModelAndFeatures_FeatureDefaultTypeInternal;
extern ModelAndFeatures_FeatureDefaultTypeInternal _ModelAndFeatures_Feature_default_instance_;
class ModelAndFeatures_FeaturesEntry_DoNotUse;
class ModelAndFeatures_FeaturesEntry_DoNotUseDefaultTypeInternal;
extern ModelAndFeatures_FeaturesEntry_DoNotUseDefaultTypeInternal _ModelAndFeatures_FeaturesEntry_DoNotUse_default_instance_;
class ObliqueFeatures;
class ObliqueFeaturesDefaultTypeInternal;
extern ObliqueFeaturesDefaultTypeInternal _ObliqueFeatures_default_instance_;
class SparseVector;
class SparseVectorDefaultTypeInternal;
extern SparseVectorDefaultTypeInternal _SparseVector_default_instance_;
class SparseVector_SparseValueEntry_DoNotUse;
class SparseVector_SparseValueEntry_DoNotUseDefaultTypeInternal;
extern SparseVector_SparseValueEntry_DoNotUseDefaultTypeInternal _SparseVector_SparseValueEntry_DoNotUse_default_instance_;
class Summation;
class SummationDefaultTypeInternal;
extern SummationDefaultTypeInternal _Summation_default_instance_;
class TreeNode;
class TreeNodeDefaultTypeInternal;
extern TreeNodeDefaultTypeInternal _TreeNode_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class Vector;
class VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
}  // namespace decision_trees
}  // namespace tensorflow
PROTOBUF_NAMESPACE_OPEN
template<> ::tensorflow::decision_trees::Averaging* Arena::CreateMaybeMessage<::tensorflow::decision_trees::Averaging>(Arena*);
template<> ::tensorflow::decision_trees::BinaryNode* Arena::CreateMaybeMessage<::tensorflow::decision_trees::BinaryNode>(Arena*);
template<> ::tensorflow::decision_trees::DecisionTree* Arena::CreateMaybeMessage<::tensorflow::decision_trees::DecisionTree>(Arena*);
template<> ::tensorflow::decision_trees::Ensemble* Arena::CreateMaybeMessage<::tensorflow::decision_trees::Ensemble>(Arena*);
template<> ::tensorflow::decision_trees::Ensemble_Member* Arena::CreateMaybeMessage<::tensorflow::decision_trees::Ensemble_Member>(Arena*);
template<> ::tensorflow::decision_trees::FeatureId* Arena::CreateMaybeMessage<::tensorflow::decision_trees::FeatureId>(Arena*);
template<> ::tensorflow::decision_trees::InequalityTest* Arena::CreateMaybeMessage<::tensorflow::decision_trees::InequalityTest>(Arena*);
template<> ::tensorflow::decision_trees::Leaf* Arena::CreateMaybeMessage<::tensorflow::decision_trees::Leaf>(Arena*);
template<> ::tensorflow::decision_trees::Model* Arena::CreateMaybeMessage<::tensorflow::decision_trees::Model>(Arena*);
template<> ::tensorflow::decision_trees::ModelAndFeatures* Arena::CreateMaybeMessage<::tensorflow::decision_trees::ModelAndFeatures>(Arena*);
template<> ::tensorflow::decision_trees::ModelAndFeatures_Feature* Arena::CreateMaybeMessage<::tensorflow::decision_trees::ModelAndFeatures_Feature>(Arena*);
template<> ::tensorflow::decision_trees::ModelAndFeatures_FeaturesEntry_DoNotUse* Arena::CreateMaybeMessage<::tensorflow::decision_trees::ModelAndFeatures_FeaturesEntry_DoNotUse>(Arena*);
template<> ::tensorflow::decision_trees::ObliqueFeatures* Arena::CreateMaybeMessage<::tensorflow::decision_trees::ObliqueFeatures>(Arena*);
template<> ::tensorflow::decision_trees::SparseVector* Arena::CreateMaybeMessage<::tensorflow::decision_trees::SparseVector>(Arena*);
template<> ::tensorflow::decision_trees::SparseVector_SparseValueEntry_DoNotUse* Arena::CreateMaybeMessage<::tensorflow::decision_trees::SparseVector_SparseValueEntry_DoNotUse>(Arena*);
template<> ::tensorflow::decision_trees::Summation* Arena::CreateMaybeMessage<::tensorflow::decision_trees::Summation>(Arena*);
template<> ::tensorflow::decision_trees::TreeNode* Arena::CreateMaybeMessage<::tensorflow::decision_trees::TreeNode>(Arena*);
template<> ::tensorflow::decision_trees::Value* Arena::CreateMaybeMessage<::tensorflow::decision_trees::Value>(Arena*);
template<> ::tensorflow::decision_trees::Vector* Arena::CreateMaybeMessage<::tensorflow::decision_trees::Vector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tensorflow {
namespace decision_trees {

enum BinaryNode_Direction : int {
  BinaryNode_Direction_LEFT = 0,
  BinaryNode_Direction_RIGHT = 1,
  BinaryNode_Direction_BinaryNode_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BinaryNode_Direction_BinaryNode_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BinaryNode_Direction_IsValid(int value);
constexpr BinaryNode_Direction BinaryNode_Direction_Direction_MIN = BinaryNode_Direction_LEFT;
constexpr BinaryNode_Direction BinaryNode_Direction_Direction_MAX = BinaryNode_Direction_RIGHT;
constexpr int BinaryNode_Direction_Direction_ARRAYSIZE = BinaryNode_Direction_Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BinaryNode_Direction_descriptor();
template<typename T>
inline const std::string& BinaryNode_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinaryNode_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinaryNode_Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BinaryNode_Direction_descriptor(), enum_t_value);
}
inline bool BinaryNode_Direction_Parse(
    const std::string& name, BinaryNode_Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BinaryNode_Direction>(
    BinaryNode_Direction_descriptor(), name, value);
}
enum InequalityTest_Type : int {
  InequalityTest_Type_LESS_OR_EQUAL = 0,
  InequalityTest_Type_LESS_THAN = 1,
  InequalityTest_Type_GREATER_OR_EQUAL = 2,
  InequalityTest_Type_GREATER_THAN = 3,
  InequalityTest_Type_InequalityTest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  InequalityTest_Type_InequalityTest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool InequalityTest_Type_IsValid(int value);
constexpr InequalityTest_Type InequalityTest_Type_Type_MIN = InequalityTest_Type_LESS_OR_EQUAL;
constexpr InequalityTest_Type InequalityTest_Type_Type_MAX = InequalityTest_Type_GREATER_THAN;
constexpr int InequalityTest_Type_Type_ARRAYSIZE = InequalityTest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InequalityTest_Type_descriptor();
template<typename T>
inline const std::string& InequalityTest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InequalityTest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InequalityTest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InequalityTest_Type_descriptor(), enum_t_value);
}
inline bool InequalityTest_Type_Parse(
    const std::string& name, InequalityTest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InequalityTest_Type>(
    InequalityTest_Type_descriptor(), name, value);
}
// ===================================================================

class Model :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Model& default_instance();

  enum ModelCase {
    kDecisionTree = 1,
    kEnsemble = 2,
    kCustomModel = 3,
    MODEL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    0;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  inline void Swap(Model* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(nullptr);
  }

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalDataFieldNumber = 4,
    kDecisionTreeFieldNumber = 1,
    kEnsembleFieldNumber = 2,
    kCustomModelFieldNumber = 3,
  };
  // repeated .google.protobuf.Any additional_data = 4;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // .tensorflow.decision_trees.DecisionTree decision_tree = 1;
  bool has_decision_tree() const;
  void clear_decision_tree();
  const ::tensorflow::decision_trees::DecisionTree& decision_tree() const;
  ::tensorflow::decision_trees::DecisionTree* release_decision_tree();
  ::tensorflow::decision_trees::DecisionTree* mutable_decision_tree();
  void set_allocated_decision_tree(::tensorflow::decision_trees::DecisionTree* decision_tree);
  void unsafe_arena_set_allocated_decision_tree(
      ::tensorflow::decision_trees::DecisionTree* decision_tree);
  ::tensorflow::decision_trees::DecisionTree* unsafe_arena_release_decision_tree();

  // .tensorflow.decision_trees.Ensemble ensemble = 2;
  bool has_ensemble() const;
  void clear_ensemble();
  const ::tensorflow::decision_trees::Ensemble& ensemble() const;
  ::tensorflow::decision_trees::Ensemble* release_ensemble();
  ::tensorflow::decision_trees::Ensemble* mutable_ensemble();
  void set_allocated_ensemble(::tensorflow::decision_trees::Ensemble* ensemble);
  void unsafe_arena_set_allocated_ensemble(
      ::tensorflow::decision_trees::Ensemble* ensemble);
  ::tensorflow::decision_trees::Ensemble* unsafe_arena_release_ensemble();

  // .google.protobuf.Any custom_model = 3;
  bool has_custom_model() const;
  void clear_custom_model();
  const ::google::protobuf::Any& custom_model() const;
  ::google::protobuf::Any* release_custom_model();
  ::google::protobuf::Any* mutable_custom_model();
  void set_allocated_custom_model(::google::protobuf::Any* custom_model);
  void unsafe_arena_set_allocated_custom_model(
      ::google::protobuf::Any* custom_model);
  ::google::protobuf::Any* unsafe_arena_release_custom_model();

  void clear_model();
  ModelCase model_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.Model)
 private:
  class _Internal;
  void set_has_decision_tree();
  void set_has_ensemble();
  void set_has_custom_model();

  inline bool has_model() const;
  inline void clear_has_model();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  union ModelUnion {
    ModelUnion() {}
    ::tensorflow::decision_trees::DecisionTree* decision_tree_;
    ::tensorflow::decision_trees::Ensemble* ensemble_;
    ::google::protobuf::Any* custom_model_;
  } model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class ModelAndFeatures_Feature :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.ModelAndFeatures.Feature) */ {
 public:
  ModelAndFeatures_Feature();
  virtual ~ModelAndFeatures_Feature();

  ModelAndFeatures_Feature(const ModelAndFeatures_Feature& from);
  ModelAndFeatures_Feature(ModelAndFeatures_Feature&& from) noexcept
    : ModelAndFeatures_Feature() {
    *this = ::std::move(from);
  }

  inline ModelAndFeatures_Feature& operator=(const ModelAndFeatures_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelAndFeatures_Feature& operator=(ModelAndFeatures_Feature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelAndFeatures_Feature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelAndFeatures_Feature* internal_default_instance() {
    return reinterpret_cast<const ModelAndFeatures_Feature*>(
               &_ModelAndFeatures_Feature_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    1;

  friend void swap(ModelAndFeatures_Feature& a, ModelAndFeatures_Feature& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelAndFeatures_Feature* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelAndFeatures_Feature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelAndFeatures_Feature* New() const final {
    return CreateMaybeMessage<ModelAndFeatures_Feature>(nullptr);
  }

  ModelAndFeatures_Feature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelAndFeatures_Feature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelAndFeatures_Feature& from);
  void MergeFrom(const ModelAndFeatures_Feature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelAndFeatures_Feature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.ModelAndFeatures.Feature";
  }
  protected:
  explicit ModelAndFeatures_Feature(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalDataFieldNumber = 2,
    kFeatureIdFieldNumber = 1,
  };
  // repeated .google.protobuf.Any additional_data = 2;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // .tensorflow.decision_trees.FeatureId feature_id = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_feature_id() const;
  PROTOBUF_DEPRECATED void clear_feature_id();
  PROTOBUF_DEPRECATED const ::tensorflow::decision_trees::FeatureId& feature_id() const;
  PROTOBUF_DEPRECATED ::tensorflow::decision_trees::FeatureId* release_feature_id();
  PROTOBUF_DEPRECATED ::tensorflow::decision_trees::FeatureId* mutable_feature_id();
  PROTOBUF_DEPRECATED void set_allocated_feature_id(::tensorflow::decision_trees::FeatureId* feature_id);
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_feature_id(
      ::tensorflow::decision_trees::FeatureId* feature_id);
  PROTOBUF_DEPRECATED ::tensorflow::decision_trees::FeatureId* unsafe_arena_release_feature_id();

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.ModelAndFeatures.Feature)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  ::tensorflow::decision_trees::FeatureId* feature_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class ModelAndFeatures_FeaturesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelAndFeatures_FeaturesEntry_DoNotUse, 
    std::string, ::tensorflow::decision_trees::ModelAndFeatures_Feature,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ModelAndFeatures_FeaturesEntry_DoNotUse, 
    std::string, ::tensorflow::decision_trees::ModelAndFeatures_Feature,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ModelAndFeatures_FeaturesEntry_DoNotUse();
  ModelAndFeatures_FeaturesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelAndFeatures_FeaturesEntry_DoNotUse& other);
  static const ModelAndFeatures_FeaturesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelAndFeatures_FeaturesEntry_DoNotUse*>(&_ModelAndFeatures_FeaturesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "tensorflow.decision_trees.ModelAndFeatures.FeaturesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[2];
  }

  public:
};

// -------------------------------------------------------------------

class ModelAndFeatures :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.ModelAndFeatures) */ {
 public:
  ModelAndFeatures();
  virtual ~ModelAndFeatures();

  ModelAndFeatures(const ModelAndFeatures& from);
  ModelAndFeatures(ModelAndFeatures&& from) noexcept
    : ModelAndFeatures() {
    *this = ::std::move(from);
  }

  inline ModelAndFeatures& operator=(const ModelAndFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelAndFeatures& operator=(ModelAndFeatures&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelAndFeatures& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelAndFeatures* internal_default_instance() {
    return reinterpret_cast<const ModelAndFeatures*>(
               &_ModelAndFeatures_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    3;

  friend void swap(ModelAndFeatures& a, ModelAndFeatures& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelAndFeatures* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelAndFeatures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelAndFeatures* New() const final {
    return CreateMaybeMessage<ModelAndFeatures>(nullptr);
  }

  ModelAndFeatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelAndFeatures>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelAndFeatures& from);
  void MergeFrom(const ModelAndFeatures& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelAndFeatures* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.ModelAndFeatures";
  }
  protected:
  explicit ModelAndFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ModelAndFeatures_Feature Feature;

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 1,
    kAdditionalDataFieldNumber = 3,
    kModelFieldNumber = 2,
  };
  // map<string, .tensorflow.decision_trees.ModelAndFeatures.Feature> features = 1;
  int features_size() const;
  void clear_features();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tensorflow::decision_trees::ModelAndFeatures_Feature >&
      features() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tensorflow::decision_trees::ModelAndFeatures_Feature >*
      mutable_features();

  // repeated .google.protobuf.Any additional_data = 3;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // .tensorflow.decision_trees.Model model = 2;
  bool has_model() const;
  void clear_model();
  const ::tensorflow::decision_trees::Model& model() const;
  ::tensorflow::decision_trees::Model* release_model();
  ::tensorflow::decision_trees::Model* mutable_model();
  void set_allocated_model(::tensorflow::decision_trees::Model* model);
  void unsafe_arena_set_allocated_model(
      ::tensorflow::decision_trees::Model* model);
  ::tensorflow::decision_trees::Model* unsafe_arena_release_model();

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.ModelAndFeatures)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ModelAndFeatures_FeaturesEntry_DoNotUse,
      std::string, ::tensorflow::decision_trees::ModelAndFeatures_Feature,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > features_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  ::tensorflow::decision_trees::Model* model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Ensemble_Member :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.Ensemble.Member) */ {
 public:
  Ensemble_Member();
  virtual ~Ensemble_Member();

  Ensemble_Member(const Ensemble_Member& from);
  Ensemble_Member(Ensemble_Member&& from) noexcept
    : Ensemble_Member() {
    *this = ::std::move(from);
  }

  inline Ensemble_Member& operator=(const Ensemble_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ensemble_Member& operator=(Ensemble_Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ensemble_Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ensemble_Member* internal_default_instance() {
    return reinterpret_cast<const Ensemble_Member*>(
               &_Ensemble_Member_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    4;

  friend void swap(Ensemble_Member& a, Ensemble_Member& b) {
    a.Swap(&b);
  }
  inline void Swap(Ensemble_Member* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ensemble_Member* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ensemble_Member* New() const final {
    return CreateMaybeMessage<Ensemble_Member>(nullptr);
  }

  Ensemble_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ensemble_Member>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ensemble_Member& from);
  void MergeFrom(const Ensemble_Member& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ensemble_Member* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.Ensemble.Member";
  }
  protected:
  explicit Ensemble_Member(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalDataFieldNumber = 3,
    kSubmodelFieldNumber = 1,
    kSubmodelIdFieldNumber = 2,
  };
  // repeated .google.protobuf.Any additional_data = 3;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // .tensorflow.decision_trees.Model submodel = 1;
  bool has_submodel() const;
  void clear_submodel();
  const ::tensorflow::decision_trees::Model& submodel() const;
  ::tensorflow::decision_trees::Model* release_submodel();
  ::tensorflow::decision_trees::Model* mutable_submodel();
  void set_allocated_submodel(::tensorflow::decision_trees::Model* submodel);
  void unsafe_arena_set_allocated_submodel(
      ::tensorflow::decision_trees::Model* submodel);
  ::tensorflow::decision_trees::Model* unsafe_arena_release_submodel();

  // .google.protobuf.Int32Value submodel_id = 2;
  bool has_submodel_id() const;
  void clear_submodel_id();
  const ::google::protobuf::Int32Value& submodel_id() const;
  ::google::protobuf::Int32Value* release_submodel_id();
  ::google::protobuf::Int32Value* mutable_submodel_id();
  void set_allocated_submodel_id(::google::protobuf::Int32Value* submodel_id);
  void unsafe_arena_set_allocated_submodel_id(
      ::google::protobuf::Int32Value* submodel_id);
  ::google::protobuf::Int32Value* unsafe_arena_release_submodel_id();

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.Ensemble.Member)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  ::tensorflow::decision_trees::Model* submodel_;
  ::google::protobuf::Int32Value* submodel_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Ensemble :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.Ensemble) */ {
 public:
  Ensemble();
  virtual ~Ensemble();

  Ensemble(const Ensemble& from);
  Ensemble(Ensemble&& from) noexcept
    : Ensemble() {
    *this = ::std::move(from);
  }

  inline Ensemble& operator=(const Ensemble& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ensemble& operator=(Ensemble&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ensemble& default_instance();

  enum CombinationTechniqueCase {
    kSummationCombinationTechnique = 1,
    kAveragingCombinationTechnique = 2,
    kCustomCombinationTechnique = 3,
    COMBINATION_TECHNIQUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ensemble* internal_default_instance() {
    return reinterpret_cast<const Ensemble*>(
               &_Ensemble_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    5;

  friend void swap(Ensemble& a, Ensemble& b) {
    a.Swap(&b);
  }
  inline void Swap(Ensemble* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ensemble* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ensemble* New() const final {
    return CreateMaybeMessage<Ensemble>(nullptr);
  }

  Ensemble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ensemble>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ensemble& from);
  void MergeFrom(const Ensemble& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ensemble* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.Ensemble";
  }
  protected:
  explicit Ensemble(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Ensemble_Member Member;

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalDataFieldNumber = 4,
    kMembersFieldNumber = 100,
    kSummationCombinationTechniqueFieldNumber = 1,
    kAveragingCombinationTechniqueFieldNumber = 2,
    kCustomCombinationTechniqueFieldNumber = 3,
  };
  // repeated .google.protobuf.Any additional_data = 4;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // repeated .tensorflow.decision_trees.Ensemble.Member members = 100;
  int members_size() const;
  void clear_members();
  ::tensorflow::decision_trees::Ensemble_Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Ensemble_Member >*
      mutable_members();
  const ::tensorflow::decision_trees::Ensemble_Member& members(int index) const;
  ::tensorflow::decision_trees::Ensemble_Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Ensemble_Member >&
      members() const;

  // .tensorflow.decision_trees.Summation summation_combination_technique = 1;
  bool has_summation_combination_technique() const;
  void clear_summation_combination_technique();
  const ::tensorflow::decision_trees::Summation& summation_combination_technique() const;
  ::tensorflow::decision_trees::Summation* release_summation_combination_technique();
  ::tensorflow::decision_trees::Summation* mutable_summation_combination_technique();
  void set_allocated_summation_combination_technique(::tensorflow::decision_trees::Summation* summation_combination_technique);
  void unsafe_arena_set_allocated_summation_combination_technique(
      ::tensorflow::decision_trees::Summation* summation_combination_technique);
  ::tensorflow::decision_trees::Summation* unsafe_arena_release_summation_combination_technique();

  // .tensorflow.decision_trees.Averaging averaging_combination_technique = 2;
  bool has_averaging_combination_technique() const;
  void clear_averaging_combination_technique();
  const ::tensorflow::decision_trees::Averaging& averaging_combination_technique() const;
  ::tensorflow::decision_trees::Averaging* release_averaging_combination_technique();
  ::tensorflow::decision_trees::Averaging* mutable_averaging_combination_technique();
  void set_allocated_averaging_combination_technique(::tensorflow::decision_trees::Averaging* averaging_combination_technique);
  void unsafe_arena_set_allocated_averaging_combination_technique(
      ::tensorflow::decision_trees::Averaging* averaging_combination_technique);
  ::tensorflow::decision_trees::Averaging* unsafe_arena_release_averaging_combination_technique();

  // .google.protobuf.Any custom_combination_technique = 3;
  bool has_custom_combination_technique() const;
  void clear_custom_combination_technique();
  const ::google::protobuf::Any& custom_combination_technique() const;
  ::google::protobuf::Any* release_custom_combination_technique();
  ::google::protobuf::Any* mutable_custom_combination_technique();
  void set_allocated_custom_combination_technique(::google::protobuf::Any* custom_combination_technique);
  void unsafe_arena_set_allocated_custom_combination_technique(
      ::google::protobuf::Any* custom_combination_technique);
  ::google::protobuf::Any* unsafe_arena_release_custom_combination_technique();

  void clear_combination_technique();
  CombinationTechniqueCase combination_technique_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.Ensemble)
 private:
  class _Internal;
  void set_has_summation_combination_technique();
  void set_has_averaging_combination_technique();
  void set_has_custom_combination_technique();

  inline bool has_combination_technique() const;
  inline void clear_has_combination_technique();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Ensemble_Member > members_;
  union CombinationTechniqueUnion {
    CombinationTechniqueUnion() {}
    ::tensorflow::decision_trees::Summation* summation_combination_technique_;
    ::tensorflow::decision_trees::Averaging* averaging_combination_technique_;
    ::google::protobuf::Any* custom_combination_technique_;
  } combination_technique_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Summation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.Summation) */ {
 public:
  Summation();
  virtual ~Summation();

  Summation(const Summation& from);
  Summation(Summation&& from) noexcept
    : Summation() {
    *this = ::std::move(from);
  }

  inline Summation& operator=(const Summation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Summation& operator=(Summation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Summation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Summation* internal_default_instance() {
    return reinterpret_cast<const Summation*>(
               &_Summation_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    6;

  friend void swap(Summation& a, Summation& b) {
    a.Swap(&b);
  }
  inline void Swap(Summation* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Summation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Summation* New() const final {
    return CreateMaybeMessage<Summation>(nullptr);
  }

  Summation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Summation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Summation& from);
  void MergeFrom(const Summation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Summation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.Summation";
  }
  protected:
  explicit Summation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalDataFieldNumber = 1,
  };
  // repeated .google.protobuf.Any additional_data = 1;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.Summation)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Averaging :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.Averaging) */ {
 public:
  Averaging();
  virtual ~Averaging();

  Averaging(const Averaging& from);
  Averaging(Averaging&& from) noexcept
    : Averaging() {
    *this = ::std::move(from);
  }

  inline Averaging& operator=(const Averaging& from) {
    CopyFrom(from);
    return *this;
  }
  inline Averaging& operator=(Averaging&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Averaging& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Averaging* internal_default_instance() {
    return reinterpret_cast<const Averaging*>(
               &_Averaging_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    7;

  friend void swap(Averaging& a, Averaging& b) {
    a.Swap(&b);
  }
  inline void Swap(Averaging* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Averaging* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Averaging* New() const final {
    return CreateMaybeMessage<Averaging>(nullptr);
  }

  Averaging* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Averaging>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Averaging& from);
  void MergeFrom(const Averaging& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Averaging* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.Averaging";
  }
  protected:
  explicit Averaging(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalDataFieldNumber = 1,
  };
  // repeated .google.protobuf.Any additional_data = 1;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.Averaging)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class DecisionTree :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.DecisionTree) */ {
 public:
  DecisionTree();
  virtual ~DecisionTree();

  DecisionTree(const DecisionTree& from);
  DecisionTree(DecisionTree&& from) noexcept
    : DecisionTree() {
    *this = ::std::move(from);
  }

  inline DecisionTree& operator=(const DecisionTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecisionTree& operator=(DecisionTree&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DecisionTree& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecisionTree* internal_default_instance() {
    return reinterpret_cast<const DecisionTree*>(
               &_DecisionTree_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    8;

  friend void swap(DecisionTree& a, DecisionTree& b) {
    a.Swap(&b);
  }
  inline void Swap(DecisionTree* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecisionTree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecisionTree* New() const final {
    return CreateMaybeMessage<DecisionTree>(nullptr);
  }

  DecisionTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecisionTree>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DecisionTree& from);
  void MergeFrom(const DecisionTree& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecisionTree* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.DecisionTree";
  }
  protected:
  explicit DecisionTree(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kAdditionalDataFieldNumber = 2,
  };
  // repeated .tensorflow.decision_trees.TreeNode nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  ::tensorflow::decision_trees::TreeNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >*
      mutable_nodes();
  const ::tensorflow::decision_trees::TreeNode& nodes(int index) const;
  ::tensorflow::decision_trees::TreeNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >&
      nodes() const;

  // repeated .google.protobuf.Any additional_data = 2;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.DecisionTree)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode > nodes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class TreeNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.TreeNode) */ {
 public:
  TreeNode();
  virtual ~TreeNode();

  TreeNode(const TreeNode& from);
  TreeNode(TreeNode&& from) noexcept
    : TreeNode() {
    *this = ::std::move(from);
  }

  inline TreeNode& operator=(const TreeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeNode& operator=(TreeNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TreeNode& default_instance();

  enum NodeTypeCase {
    kBinaryNode = 4,
    kLeaf = 5,
    kCustomNodeType = 6,
    NODE_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreeNode* internal_default_instance() {
    return reinterpret_cast<const TreeNode*>(
               &_TreeNode_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    9;

  friend void swap(TreeNode& a, TreeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TreeNode* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreeNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TreeNode* New() const final {
    return CreateMaybeMessage<TreeNode>(nullptr);
  }

  TreeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TreeNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TreeNode& from);
  void MergeFrom(const TreeNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.TreeNode";
  }
  protected:
  explicit TreeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalDataFieldNumber = 7,
    kNodeIdFieldNumber = 1,
    kDepthFieldNumber = 2,
    kSubtreeSizeFieldNumber = 3,
    kBinaryNodeFieldNumber = 4,
    kLeafFieldNumber = 5,
    kCustomNodeTypeFieldNumber = 6,
  };
  // repeated .google.protobuf.Any additional_data = 7;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // .google.protobuf.Int32Value node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  const ::google::protobuf::Int32Value& node_id() const;
  ::google::protobuf::Int32Value* release_node_id();
  ::google::protobuf::Int32Value* mutable_node_id();
  void set_allocated_node_id(::google::protobuf::Int32Value* node_id);
  void unsafe_arena_set_allocated_node_id(
      ::google::protobuf::Int32Value* node_id);
  ::google::protobuf::Int32Value* unsafe_arena_release_node_id();

  // .google.protobuf.Int32Value depth = 2;
  bool has_depth() const;
  void clear_depth();
  const ::google::protobuf::Int32Value& depth() const;
  ::google::protobuf::Int32Value* release_depth();
  ::google::protobuf::Int32Value* mutable_depth();
  void set_allocated_depth(::google::protobuf::Int32Value* depth);
  void unsafe_arena_set_allocated_depth(
      ::google::protobuf::Int32Value* depth);
  ::google::protobuf::Int32Value* unsafe_arena_release_depth();

  // .google.protobuf.Int32Value subtree_size = 3;
  bool has_subtree_size() const;
  void clear_subtree_size();
  const ::google::protobuf::Int32Value& subtree_size() const;
  ::google::protobuf::Int32Value* release_subtree_size();
  ::google::protobuf::Int32Value* mutable_subtree_size();
  void set_allocated_subtree_size(::google::protobuf::Int32Value* subtree_size);
  void unsafe_arena_set_allocated_subtree_size(
      ::google::protobuf::Int32Value* subtree_size);
  ::google::protobuf::Int32Value* unsafe_arena_release_subtree_size();

  // .tensorflow.decision_trees.BinaryNode binary_node = 4;
  bool has_binary_node() const;
  void clear_binary_node();
  const ::tensorflow::decision_trees::BinaryNode& binary_node() const;
  ::tensorflow::decision_trees::BinaryNode* release_binary_node();
  ::tensorflow::decision_trees::BinaryNode* mutable_binary_node();
  void set_allocated_binary_node(::tensorflow::decision_trees::BinaryNode* binary_node);
  void unsafe_arena_set_allocated_binary_node(
      ::tensorflow::decision_trees::BinaryNode* binary_node);
  ::tensorflow::decision_trees::BinaryNode* unsafe_arena_release_binary_node();

  // .tensorflow.decision_trees.Leaf leaf = 5;
  bool has_leaf() const;
  void clear_leaf();
  const ::tensorflow::decision_trees::Leaf& leaf() const;
  ::tensorflow::decision_trees::Leaf* release_leaf();
  ::tensorflow::decision_trees::Leaf* mutable_leaf();
  void set_allocated_leaf(::tensorflow::decision_trees::Leaf* leaf);
  void unsafe_arena_set_allocated_leaf(
      ::tensorflow::decision_trees::Leaf* leaf);
  ::tensorflow::decision_trees::Leaf* unsafe_arena_release_leaf();

  // .google.protobuf.Any custom_node_type = 6;
  bool has_custom_node_type() const;
  void clear_custom_node_type();
  const ::google::protobuf::Any& custom_node_type() const;
  ::google::protobuf::Any* release_custom_node_type();
  ::google::protobuf::Any* mutable_custom_node_type();
  void set_allocated_custom_node_type(::google::protobuf::Any* custom_node_type);
  void unsafe_arena_set_allocated_custom_node_type(
      ::google::protobuf::Any* custom_node_type);
  ::google::protobuf::Any* unsafe_arena_release_custom_node_type();

  void clear_node_type();
  NodeTypeCase node_type_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.TreeNode)
 private:
  class _Internal;
  void set_has_binary_node();
  void set_has_leaf();
  void set_has_custom_node_type();

  inline bool has_node_type() const;
  inline void clear_has_node_type();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  ::google::protobuf::Int32Value* node_id_;
  ::google::protobuf::Int32Value* depth_;
  ::google::protobuf::Int32Value* subtree_size_;
  union NodeTypeUnion {
    NodeTypeUnion() {}
    ::tensorflow::decision_trees::BinaryNode* binary_node_;
    ::tensorflow::decision_trees::Leaf* leaf_;
    ::google::protobuf::Any* custom_node_type_;
  } node_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class BinaryNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.BinaryNode) */ {
 public:
  BinaryNode();
  virtual ~BinaryNode();

  BinaryNode(const BinaryNode& from);
  BinaryNode(BinaryNode&& from) noexcept
    : BinaryNode() {
    *this = ::std::move(from);
  }

  inline BinaryNode& operator=(const BinaryNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryNode& operator=(BinaryNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryNode& default_instance();

  enum LeftChildTestCase {
    kInequalityLeftChildTest = 4,
    kCustomLeftChildTest = 5,
    LEFT_CHILD_TEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryNode* internal_default_instance() {
    return reinterpret_cast<const BinaryNode*>(
               &_BinaryNode_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    10;

  friend void swap(BinaryNode& a, BinaryNode& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryNode* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryNode* New() const final {
    return CreateMaybeMessage<BinaryNode>(nullptr);
  }

  BinaryNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryNode& from);
  void MergeFrom(const BinaryNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.BinaryNode";
  }
  protected:
  explicit BinaryNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BinaryNode_Direction Direction;
  static const /*constexpr*/ Direction LEFT =
    BinaryNode_Direction_LEFT;
  static const /*constexpr*/ Direction RIGHT =
    BinaryNode_Direction_RIGHT;
  static inline bool Direction_IsValid(int value) {
    return BinaryNode_Direction_IsValid(value);
  }
  static const /*constexpr*/ Direction Direction_MIN =
    BinaryNode_Direction_Direction_MIN;
  static const /*constexpr*/ Direction Direction_MAX =
    BinaryNode_Direction_Direction_MAX;
  static const /*constexpr*/ int Direction_ARRAYSIZE =
    BinaryNode_Direction_Direction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Direction_descriptor() {
    return BinaryNode_Direction_descriptor();
  }
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return BinaryNode_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(const std::string& name,
      Direction* value) {
    return BinaryNode_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeftChildIdFieldNumber = 1,
    kRightChildIdFieldNumber = 2,
    kDefaultDirectionFieldNumber = 3,
    kInequalityLeftChildTestFieldNumber = 4,
    kCustomLeftChildTestFieldNumber = 5,
  };
  // .google.protobuf.Int32Value left_child_id = 1;
  bool has_left_child_id() const;
  void clear_left_child_id();
  const ::google::protobuf::Int32Value& left_child_id() const;
  ::google::protobuf::Int32Value* release_left_child_id();
  ::google::protobuf::Int32Value* mutable_left_child_id();
  void set_allocated_left_child_id(::google::protobuf::Int32Value* left_child_id);
  void unsafe_arena_set_allocated_left_child_id(
      ::google::protobuf::Int32Value* left_child_id);
  ::google::protobuf::Int32Value* unsafe_arena_release_left_child_id();

  // .google.protobuf.Int32Value right_child_id = 2;
  bool has_right_child_id() const;
  void clear_right_child_id();
  const ::google::protobuf::Int32Value& right_child_id() const;
  ::google::protobuf::Int32Value* release_right_child_id();
  ::google::protobuf::Int32Value* mutable_right_child_id();
  void set_allocated_right_child_id(::google::protobuf::Int32Value* right_child_id);
  void unsafe_arena_set_allocated_right_child_id(
      ::google::protobuf::Int32Value* right_child_id);
  ::google::protobuf::Int32Value* unsafe_arena_release_right_child_id();

  // .tensorflow.decision_trees.BinaryNode.Direction default_direction = 3;
  void clear_default_direction();
  ::tensorflow::decision_trees::BinaryNode_Direction default_direction() const;
  void set_default_direction(::tensorflow::decision_trees::BinaryNode_Direction value);

  // .tensorflow.decision_trees.InequalityTest inequality_left_child_test = 4;
  bool has_inequality_left_child_test() const;
  void clear_inequality_left_child_test();
  const ::tensorflow::decision_trees::InequalityTest& inequality_left_child_test() const;
  ::tensorflow::decision_trees::InequalityTest* release_inequality_left_child_test();
  ::tensorflow::decision_trees::InequalityTest* mutable_inequality_left_child_test();
  void set_allocated_inequality_left_child_test(::tensorflow::decision_trees::InequalityTest* inequality_left_child_test);
  void unsafe_arena_set_allocated_inequality_left_child_test(
      ::tensorflow::decision_trees::InequalityTest* inequality_left_child_test);
  ::tensorflow::decision_trees::InequalityTest* unsafe_arena_release_inequality_left_child_test();

  // .google.protobuf.Any custom_left_child_test = 5;
  bool has_custom_left_child_test() const;
  void clear_custom_left_child_test();
  const ::google::protobuf::Any& custom_left_child_test() const;
  ::google::protobuf::Any* release_custom_left_child_test();
  ::google::protobuf::Any* mutable_custom_left_child_test();
  void set_allocated_custom_left_child_test(::google::protobuf::Any* custom_left_child_test);
  void unsafe_arena_set_allocated_custom_left_child_test(
      ::google::protobuf::Any* custom_left_child_test);
  ::google::protobuf::Any* unsafe_arena_release_custom_left_child_test();

  void clear_left_child_test();
  LeftChildTestCase left_child_test_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.BinaryNode)
 private:
  class _Internal;
  void set_has_inequality_left_child_test();
  void set_has_custom_left_child_test();

  inline bool has_left_child_test() const;
  inline void clear_has_left_child_test();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::Int32Value* left_child_id_;
  ::google::protobuf::Int32Value* right_child_id_;
  int default_direction_;
  union LeftChildTestUnion {
    LeftChildTestUnion() {}
    ::tensorflow::decision_trees::InequalityTest* inequality_left_child_test_;
    ::google::protobuf::Any* custom_left_child_test_;
  } left_child_test_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class SparseVector_SparseValueEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SparseVector_SparseValueEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, ::tensorflow::decision_trees::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SparseVector_SparseValueEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, ::tensorflow::decision_trees::Value,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  SparseVector_SparseValueEntry_DoNotUse();
  SparseVector_SparseValueEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SparseVector_SparseValueEntry_DoNotUse& other);
  static const SparseVector_SparseValueEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SparseVector_SparseValueEntry_DoNotUse*>(&_SparseVector_SparseValueEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[11];
  }

  public:
};

// -------------------------------------------------------------------

class SparseVector :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.SparseVector) */ {
 public:
  SparseVector();
  virtual ~SparseVector();

  SparseVector(const SparseVector& from);
  SparseVector(SparseVector&& from) noexcept
    : SparseVector() {
    *this = ::std::move(from);
  }

  inline SparseVector& operator=(const SparseVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline SparseVector& operator=(SparseVector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SparseVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SparseVector* internal_default_instance() {
    return reinterpret_cast<const SparseVector*>(
               &_SparseVector_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    12;

  friend void swap(SparseVector& a, SparseVector& b) {
    a.Swap(&b);
  }
  inline void Swap(SparseVector* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SparseVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SparseVector* New() const final {
    return CreateMaybeMessage<SparseVector>(nullptr);
  }

  SparseVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SparseVector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SparseVector& from);
  void MergeFrom(const SparseVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SparseVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.SparseVector";
  }
  protected:
  explicit SparseVector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSparseValueFieldNumber = 1,
  };
  // map<int64, .tensorflow.decision_trees.Value> sparse_value = 1;
  int sparse_value_size() const;
  void clear_sparse_value();
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::tensorflow::decision_trees::Value >&
      sparse_value() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::tensorflow::decision_trees::Value >*
      mutable_sparse_value();

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.SparseVector)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SparseVector_SparseValueEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int64, ::tensorflow::decision_trees::Value,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > sparse_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Vector :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.Vector) */ {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    13;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector* New() const final {
    return CreateMaybeMessage<Vector>(nullptr);
  }

  Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.Vector";
  }
  protected:
  explicit Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .tensorflow.decision_trees.Value value = 1;
  int value_size() const;
  void clear_value();
  ::tensorflow::decision_trees::Value* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Value >*
      mutable_value();
  const ::tensorflow::decision_trees::Value& value(int index) const;
  ::tensorflow::decision_trees::Value* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Value >&
      value() const;

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.Vector)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Value > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Leaf :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.Leaf) */ {
 public:
  Leaf();
  virtual ~Leaf();

  Leaf(const Leaf& from);
  Leaf(Leaf&& from) noexcept
    : Leaf() {
    *this = ::std::move(from);
  }

  inline Leaf& operator=(const Leaf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Leaf& operator=(Leaf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Leaf& default_instance();

  enum LeafCase {
    kVector = 1,
    kSparseVector = 2,
    LEAF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Leaf* internal_default_instance() {
    return reinterpret_cast<const Leaf*>(
               &_Leaf_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    14;

  friend void swap(Leaf& a, Leaf& b) {
    a.Swap(&b);
  }
  inline void Swap(Leaf* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Leaf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Leaf* New() const final {
    return CreateMaybeMessage<Leaf>(nullptr);
  }

  Leaf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Leaf>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Leaf& from);
  void MergeFrom(const Leaf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Leaf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.Leaf";
  }
  protected:
  explicit Leaf(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalDataFieldNumber = 3,
    kVectorFieldNumber = 1,
    kSparseVectorFieldNumber = 2,
  };
  // repeated .google.protobuf.Any additional_data = 3;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // .tensorflow.decision_trees.Vector vector = 1;
  bool has_vector() const;
  void clear_vector();
  const ::tensorflow::decision_trees::Vector& vector() const;
  ::tensorflow::decision_trees::Vector* release_vector();
  ::tensorflow::decision_trees::Vector* mutable_vector();
  void set_allocated_vector(::tensorflow::decision_trees::Vector* vector);
  void unsafe_arena_set_allocated_vector(
      ::tensorflow::decision_trees::Vector* vector);
  ::tensorflow::decision_trees::Vector* unsafe_arena_release_vector();

  // .tensorflow.decision_trees.SparseVector sparse_vector = 2;
  bool has_sparse_vector() const;
  void clear_sparse_vector();
  const ::tensorflow::decision_trees::SparseVector& sparse_vector() const;
  ::tensorflow::decision_trees::SparseVector* release_sparse_vector();
  ::tensorflow::decision_trees::SparseVector* mutable_sparse_vector();
  void set_allocated_sparse_vector(::tensorflow::decision_trees::SparseVector* sparse_vector);
  void unsafe_arena_set_allocated_sparse_vector(
      ::tensorflow::decision_trees::SparseVector* sparse_vector);
  ::tensorflow::decision_trees::SparseVector* unsafe_arena_release_sparse_vector();

  void clear_leaf();
  LeafCase leaf_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.Leaf)
 private:
  class _Internal;
  void set_has_vector();
  void set_has_sparse_vector();

  inline bool has_leaf() const;
  inline void clear_has_leaf();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  union LeafUnion {
    LeafUnion() {}
    ::tensorflow::decision_trees::Vector* vector_;
    ::tensorflow::decision_trees::SparseVector* sparse_vector_;
  } leaf_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class FeatureId :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.FeatureId) */ {
 public:
  FeatureId();
  virtual ~FeatureId();

  FeatureId(const FeatureId& from);
  FeatureId(FeatureId&& from) noexcept
    : FeatureId() {
    *this = ::std::move(from);
  }

  inline FeatureId& operator=(const FeatureId& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureId& operator=(FeatureId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeatureId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureId* internal_default_instance() {
    return reinterpret_cast<const FeatureId*>(
               &_FeatureId_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    15;

  friend void swap(FeatureId& a, FeatureId& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureId* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeatureId* New() const final {
    return CreateMaybeMessage<FeatureId>(nullptr);
  }

  FeatureId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeatureId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeatureId& from);
  void MergeFrom(const FeatureId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.FeatureId";
  }
  protected:
  explicit FeatureId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalDataFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .google.protobuf.Any additional_data = 2;
  int additional_data_size() const;
  void clear_additional_data();
  ::google::protobuf::Any* mutable_additional_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_additional_data();
  const ::google::protobuf::Any& additional_data(int index) const;
  ::google::protobuf::Any* add_additional_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
      additional_data() const;

  // .google.protobuf.StringValue id = 1;
  bool has_id() const;
  void clear_id();
  const ::google::protobuf::StringValue& id() const;
  ::google::protobuf::StringValue* release_id();
  ::google::protobuf::StringValue* mutable_id();
  void set_allocated_id(::google::protobuf::StringValue* id);
  void unsafe_arena_set_allocated_id(
      ::google::protobuf::StringValue* id);
  ::google::protobuf::StringValue* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.FeatureId)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any > additional_data_;
  ::google::protobuf::StringValue* id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class ObliqueFeatures :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.ObliqueFeatures) */ {
 public:
  ObliqueFeatures();
  virtual ~ObliqueFeatures();

  ObliqueFeatures(const ObliqueFeatures& from);
  ObliqueFeatures(ObliqueFeatures&& from) noexcept
    : ObliqueFeatures() {
    *this = ::std::move(from);
  }

  inline ObliqueFeatures& operator=(const ObliqueFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObliqueFeatures& operator=(ObliqueFeatures&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObliqueFeatures& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObliqueFeatures* internal_default_instance() {
    return reinterpret_cast<const ObliqueFeatures*>(
               &_ObliqueFeatures_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    16;

  friend void swap(ObliqueFeatures& a, ObliqueFeatures& b) {
    a.Swap(&b);
  }
  inline void Swap(ObliqueFeatures* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObliqueFeatures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObliqueFeatures* New() const final {
    return CreateMaybeMessage<ObliqueFeatures>(nullptr);
  }

  ObliqueFeatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObliqueFeatures>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObliqueFeatures& from);
  void MergeFrom(const ObliqueFeatures& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObliqueFeatures* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.ObliqueFeatures";
  }
  protected:
  explicit ObliqueFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeaturesFieldNumber = 1,
    kWeightsFieldNumber = 2,
  };
  // repeated .tensorflow.decision_trees.FeatureId features = 1;
  int features_size() const;
  void clear_features();
  ::tensorflow::decision_trees::FeatureId* mutable_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::FeatureId >*
      mutable_features();
  const ::tensorflow::decision_trees::FeatureId& features(int index) const;
  ::tensorflow::decision_trees::FeatureId* add_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::FeatureId >&
      features() const;

  // repeated float weights = 2;
  int weights_size() const;
  void clear_weights();
  float weights(int index) const;
  void set_weights(int index, float value);
  void add_weights(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      weights() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_weights();

  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.ObliqueFeatures)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::FeatureId > features_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > weights_;
  mutable std::atomic<int> _weights_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class InequalityTest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.InequalityTest) */ {
 public:
  InequalityTest();
  virtual ~InequalityTest();

  InequalityTest(const InequalityTest& from);
  InequalityTest(InequalityTest&& from) noexcept
    : InequalityTest() {
    *this = ::std::move(from);
  }

  inline InequalityTest& operator=(const InequalityTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InequalityTest& operator=(InequalityTest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InequalityTest& default_instance();

  enum FeatureSumCase {
    kFeatureId = 1,
    kOblique = 4,
    FEATURESUM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InequalityTest* internal_default_instance() {
    return reinterpret_cast<const InequalityTest*>(
               &_InequalityTest_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    17;

  friend void swap(InequalityTest& a, InequalityTest& b) {
    a.Swap(&b);
  }
  inline void Swap(InequalityTest* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InequalityTest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InequalityTest* New() const final {
    return CreateMaybeMessage<InequalityTest>(nullptr);
  }

  InequalityTest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InequalityTest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InequalityTest& from);
  void MergeFrom(const InequalityTest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InequalityTest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.InequalityTest";
  }
  protected:
  explicit InequalityTest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef InequalityTest_Type Type;
  static const /*constexpr*/ Type LESS_OR_EQUAL =
    InequalityTest_Type_LESS_OR_EQUAL;
  static const /*constexpr*/ Type LESS_THAN =
    InequalityTest_Type_LESS_THAN;
  static const /*constexpr*/ Type GREATER_OR_EQUAL =
    InequalityTest_Type_GREATER_OR_EQUAL;
  static const /*constexpr*/ Type GREATER_THAN =
    InequalityTest_Type_GREATER_THAN;
  static inline bool Type_IsValid(int value) {
    return InequalityTest_Type_IsValid(value);
  }
  static const /*constexpr*/ Type Type_MIN =
    InequalityTest_Type_Type_MIN;
  static const /*constexpr*/ Type Type_MAX =
    InequalityTest_Type_Type_MAX;
  static const /*constexpr*/ int Type_ARRAYSIZE =
    InequalityTest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return InequalityTest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return InequalityTest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return InequalityTest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kThresholdFieldNumber = 3,
    kTypeFieldNumber = 2,
    kFeatureIdFieldNumber = 1,
    kObliqueFieldNumber = 4,
  };
  // .tensorflow.decision_trees.Value threshold = 3;
  bool has_threshold() const;
  void clear_threshold();
  const ::tensorflow::decision_trees::Value& threshold() const;
  ::tensorflow::decision_trees::Value* release_threshold();
  ::tensorflow::decision_trees::Value* mutable_threshold();
  void set_allocated_threshold(::tensorflow::decision_trees::Value* threshold);
  void unsafe_arena_set_allocated_threshold(
      ::tensorflow::decision_trees::Value* threshold);
  ::tensorflow::decision_trees::Value* unsafe_arena_release_threshold();

  // .tensorflow.decision_trees.InequalityTest.Type type = 2;
  void clear_type();
  ::tensorflow::decision_trees::InequalityTest_Type type() const;
  void set_type(::tensorflow::decision_trees::InequalityTest_Type value);

  // .tensorflow.decision_trees.FeatureId feature_id = 1;
  bool has_feature_id() const;
  void clear_feature_id();
  const ::tensorflow::decision_trees::FeatureId& feature_id() const;
  ::tensorflow::decision_trees::FeatureId* release_feature_id();
  ::tensorflow::decision_trees::FeatureId* mutable_feature_id();
  void set_allocated_feature_id(::tensorflow::decision_trees::FeatureId* feature_id);
  void unsafe_arena_set_allocated_feature_id(
      ::tensorflow::decision_trees::FeatureId* feature_id);
  ::tensorflow::decision_trees::FeatureId* unsafe_arena_release_feature_id();

  // .tensorflow.decision_trees.ObliqueFeatures oblique = 4;
  bool has_oblique() const;
  void clear_oblique();
  const ::tensorflow::decision_trees::ObliqueFeatures& oblique() const;
  ::tensorflow::decision_trees::ObliqueFeatures* release_oblique();
  ::tensorflow::decision_trees::ObliqueFeatures* mutable_oblique();
  void set_allocated_oblique(::tensorflow::decision_trees::ObliqueFeatures* oblique);
  void unsafe_arena_set_allocated_oblique(
      ::tensorflow::decision_trees::ObliqueFeatures* oblique);
  ::tensorflow::decision_trees::ObliqueFeatures* unsafe_arena_release_oblique();

  void clear_FeatureSum();
  FeatureSumCase FeatureSum_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.InequalityTest)
 private:
  class _Internal;
  void set_has_feature_id();
  void set_has_oblique();

  inline bool has_FeatureSum() const;
  inline void clear_has_FeatureSum();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tensorflow::decision_trees::Value* threshold_;
  int type_;
  union FeatureSumUnion {
    FeatureSumUnion() {}
    ::tensorflow::decision_trees::FeatureId* feature_id_;
    ::tensorflow::decision_trees::ObliqueFeatures* oblique_;
  } FeatureSum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// -------------------------------------------------------------------

class Value :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tensorflow.decision_trees.Value) */ {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Value& default_instance();

  enum ValueCase {
    kFloatValue = 1,
    kDoubleValue = 2,
    kInt32Value = 3,
    kInt64Value = 4,
    kCustomValue = 5,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static const /*constexpr*/ int kIndexInFileMessages =
    18;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
    if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return CreateMaybeMessage<Value>(nullptr);
  }

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tensorflow.decision_trees.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_generic_5ftree_5fmodel_2eproto);
    return ::descriptor_table_generic_5ftree_5fmodel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFloatValueFieldNumber = 1,
    kDoubleValueFieldNumber = 2,
    kInt32ValueFieldNumber = 3,
    kInt64ValueFieldNumber = 4,
    kCustomValueFieldNumber = 5,
  };
  // float float_value = 1;
  private:
  bool has_float_value() const;
  public:
  void clear_float_value();
  float float_value() const;
  void set_float_value(float value);

  // double double_value = 2;
  private:
  bool has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);

  // int32 int32_value = 3;
  private:
  bool has_int32_value() const;
  public:
  void clear_int32_value();
  ::PROTOBUF_NAMESPACE_ID::int32 int32_value() const;
  void set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int64 int64_value = 4;
  private:
  bool has_int64_value() const;
  public:
  void clear_int64_value();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_value() const;
  void set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .google.protobuf.Any custom_value = 5;
  bool has_custom_value() const;
  void clear_custom_value();
  const ::google::protobuf::Any& custom_value() const;
  ::google::protobuf::Any* release_custom_value();
  ::google::protobuf::Any* mutable_custom_value();
  void set_allocated_custom_value(::google::protobuf::Any* custom_value);
  void unsafe_arena_set_allocated_custom_value(
      ::google::protobuf::Any* custom_value);
  ::google::protobuf::Any* unsafe_arena_release_custom_value();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.decision_trees.Value)
 private:
  class _Internal;
  void set_has_float_value();
  void set_has_double_value();
  void set_has_int32_value();
  void set_has_int64_value();
  void set_has_custom_value();

  inline bool has_value() const;
  inline void clear_has_value();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    ValueUnion() {}
    float float_value_;
    double double_value_;
    ::PROTOBUF_NAMESPACE_ID::int32 int32_value_;
    ::PROTOBUF_NAMESPACE_ID::int64 int64_value_;
    ::google::protobuf::Any* custom_value_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_generic_5ftree_5fmodel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Model

// .tensorflow.decision_trees.DecisionTree decision_tree = 1;
inline bool Model::has_decision_tree() const {
  return model_case() == kDecisionTree;
}
inline void Model::set_has_decision_tree() {
  _oneof_case_[0] = kDecisionTree;
}
inline void Model::clear_decision_tree() {
  if (has_decision_tree()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete model_.decision_tree_;
    }
    clear_has_model();
  }
}
inline ::tensorflow::decision_trees::DecisionTree* Model::release_decision_tree() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Model.decision_tree)
  if (has_decision_tree()) {
    clear_has_model();
      ::tensorflow::decision_trees::DecisionTree* temp = model_.decision_tree_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    model_.decision_tree_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::DecisionTree& Model::decision_tree() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Model.decision_tree)
  return has_decision_tree()
      ? *model_.decision_tree_
      : *reinterpret_cast< ::tensorflow::decision_trees::DecisionTree*>(&::tensorflow::decision_trees::_DecisionTree_default_instance_);
}
inline ::tensorflow::decision_trees::DecisionTree* Model::unsafe_arena_release_decision_tree() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Model.decision_tree)
  if (has_decision_tree()) {
    clear_has_model();
    ::tensorflow::decision_trees::DecisionTree* temp = model_.decision_tree_;
    model_.decision_tree_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_decision_tree(::tensorflow::decision_trees::DecisionTree* decision_tree) {
  clear_model();
  if (decision_tree) {
    set_has_decision_tree();
    model_.decision_tree_ = decision_tree;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.Model.decision_tree)
}
inline ::tensorflow::decision_trees::DecisionTree* Model::mutable_decision_tree() {
  if (!has_decision_tree()) {
    clear_model();
    set_has_decision_tree();
    model_.decision_tree_ = CreateMaybeMessage< ::tensorflow::decision_trees::DecisionTree >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Model.decision_tree)
  return model_.decision_tree_;
}

// .tensorflow.decision_trees.Ensemble ensemble = 2;
inline bool Model::has_ensemble() const {
  return model_case() == kEnsemble;
}
inline void Model::set_has_ensemble() {
  _oneof_case_[0] = kEnsemble;
}
inline void Model::clear_ensemble() {
  if (has_ensemble()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete model_.ensemble_;
    }
    clear_has_model();
  }
}
inline ::tensorflow::decision_trees::Ensemble* Model::release_ensemble() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Model.ensemble)
  if (has_ensemble()) {
    clear_has_model();
      ::tensorflow::decision_trees::Ensemble* temp = model_.ensemble_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    model_.ensemble_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::Ensemble& Model::ensemble() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Model.ensemble)
  return has_ensemble()
      ? *model_.ensemble_
      : *reinterpret_cast< ::tensorflow::decision_trees::Ensemble*>(&::tensorflow::decision_trees::_Ensemble_default_instance_);
}
inline ::tensorflow::decision_trees::Ensemble* Model::unsafe_arena_release_ensemble() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Model.ensemble)
  if (has_ensemble()) {
    clear_has_model();
    ::tensorflow::decision_trees::Ensemble* temp = model_.ensemble_;
    model_.ensemble_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_ensemble(::tensorflow::decision_trees::Ensemble* ensemble) {
  clear_model();
  if (ensemble) {
    set_has_ensemble();
    model_.ensemble_ = ensemble;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.Model.ensemble)
}
inline ::tensorflow::decision_trees::Ensemble* Model::mutable_ensemble() {
  if (!has_ensemble()) {
    clear_model();
    set_has_ensemble();
    model_.ensemble_ = CreateMaybeMessage< ::tensorflow::decision_trees::Ensemble >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Model.ensemble)
  return model_.ensemble_;
}

// .google.protobuf.Any custom_model = 3;
inline bool Model::has_custom_model() const {
  return model_case() == kCustomModel;
}
inline void Model::set_has_custom_model() {
  _oneof_case_[0] = kCustomModel;
}
inline ::google::protobuf::Any* Model::release_custom_model() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Model.custom_model)
  if (has_custom_model()) {
    clear_has_model();
      ::google::protobuf::Any* temp = model_.custom_model_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    model_.custom_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Any& Model::custom_model() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Model.custom_model)
  return has_custom_model()
      ? *model_.custom_model_
      : *reinterpret_cast< ::google::protobuf::Any*>(&::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Model::unsafe_arena_release_custom_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Model.custom_model)
  if (has_custom_model()) {
    clear_has_model();
    ::google::protobuf::Any* temp = model_.custom_model_;
    model_.custom_model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_custom_model(::google::protobuf::Any* custom_model) {
  clear_model();
  if (custom_model) {
    set_has_custom_model();
    model_.custom_model_ = custom_model;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.Model.custom_model)
}
inline ::google::protobuf::Any* Model::mutable_custom_model() {
  if (!has_custom_model()) {
    clear_model();
    set_has_custom_model();
    model_.custom_model_ = CreateMaybeMessage< ::google::protobuf::Any >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Model.custom_model)
  return model_.custom_model_;
}

// repeated .google.protobuf.Any additional_data = 4;
inline int Model::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* Model::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Model.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
Model::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.Model.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& Model::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Model.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* Model::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.Model.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
Model::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.Model.additional_data)
  return additional_data_;
}

inline bool Model::has_model() const {
  return model_case() != MODEL_NOT_SET;
}
inline void Model::clear_has_model() {
  _oneof_case_[0] = MODEL_NOT_SET;
}
inline Model::ModelCase Model::model_case() const {
  return Model::ModelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ModelAndFeatures_Feature

// .tensorflow.decision_trees.FeatureId feature_id = 1 [deprecated = true];
inline bool ModelAndFeatures_Feature::has_feature_id() const {
  return this != internal_default_instance() && feature_id_ != nullptr;
}
inline void ModelAndFeatures_Feature::clear_feature_id() {
  if (GetArenaNoVirtual() == nullptr && feature_id_ != nullptr) {
    delete feature_id_;
  }
  feature_id_ = nullptr;
}
inline const ::tensorflow::decision_trees::FeatureId& ModelAndFeatures_Feature::feature_id() const {
  const ::tensorflow::decision_trees::FeatureId* p = feature_id_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.ModelAndFeatures.Feature.feature_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::FeatureId*>(
      &::tensorflow::decision_trees::_FeatureId_default_instance_);
}
inline ::tensorflow::decision_trees::FeatureId* ModelAndFeatures_Feature::release_feature_id() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.ModelAndFeatures.Feature.feature_id)
  
  ::tensorflow::decision_trees::FeatureId* temp = feature_id_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  feature_id_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::FeatureId* ModelAndFeatures_Feature::unsafe_arena_release_feature_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.ModelAndFeatures.Feature.feature_id)
  
  ::tensorflow::decision_trees::FeatureId* temp = feature_id_;
  feature_id_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::FeatureId* ModelAndFeatures_Feature::mutable_feature_id() {
  
  if (feature_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::FeatureId>(GetArenaNoVirtual());
    feature_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.ModelAndFeatures.Feature.feature_id)
  return feature_id_;
}
inline void ModelAndFeatures_Feature::set_allocated_feature_id(::tensorflow::decision_trees::FeatureId* feature_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete feature_id_;
  }
  if (feature_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(feature_id);
    if (message_arena != submessage_arena) {
      feature_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_id, submessage_arena);
    }
    
  } else {
    
  }
  feature_id_ = feature_id;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.ModelAndFeatures.Feature.feature_id)
}

// repeated .google.protobuf.Any additional_data = 2;
inline int ModelAndFeatures_Feature::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* ModelAndFeatures_Feature::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.ModelAndFeatures.Feature.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
ModelAndFeatures_Feature::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.ModelAndFeatures.Feature.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& ModelAndFeatures_Feature::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.ModelAndFeatures.Feature.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* ModelAndFeatures_Feature::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.ModelAndFeatures.Feature.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
ModelAndFeatures_Feature::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.ModelAndFeatures.Feature.additional_data)
  return additional_data_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelAndFeatures

// map<string, .tensorflow.decision_trees.ModelAndFeatures.Feature> features = 1;
inline int ModelAndFeatures::features_size() const {
  return features_.size();
}
inline void ModelAndFeatures::clear_features() {
  features_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tensorflow::decision_trees::ModelAndFeatures_Feature >&
ModelAndFeatures::features() const {
  // @@protoc_insertion_point(field_map:tensorflow.decision_trees.ModelAndFeatures.features)
  return features_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::tensorflow::decision_trees::ModelAndFeatures_Feature >*
ModelAndFeatures::mutable_features() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.decision_trees.ModelAndFeatures.features)
  return features_.MutableMap();
}

// .tensorflow.decision_trees.Model model = 2;
inline bool ModelAndFeatures::has_model() const {
  return this != internal_default_instance() && model_ != nullptr;
}
inline void ModelAndFeatures::clear_model() {
  if (GetArenaNoVirtual() == nullptr && model_ != nullptr) {
    delete model_;
  }
  model_ = nullptr;
}
inline const ::tensorflow::decision_trees::Model& ModelAndFeatures::model() const {
  const ::tensorflow::decision_trees::Model* p = model_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.ModelAndFeatures.model)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::Model*>(
      &::tensorflow::decision_trees::_Model_default_instance_);
}
inline ::tensorflow::decision_trees::Model* ModelAndFeatures::release_model() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.ModelAndFeatures.model)
  
  ::tensorflow::decision_trees::Model* temp = model_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  model_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Model* ModelAndFeatures::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.ModelAndFeatures.model)
  
  ::tensorflow::decision_trees::Model* temp = model_;
  model_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Model* ModelAndFeatures::mutable_model() {
  
  if (model_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::Model>(GetArenaNoVirtual());
    model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.ModelAndFeatures.model)
  return model_;
}
inline void ModelAndFeatures::set_allocated_model(::tensorflow::decision_trees::Model* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete model_;
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(model);
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    
  } else {
    
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.ModelAndFeatures.model)
}

// repeated .google.protobuf.Any additional_data = 3;
inline int ModelAndFeatures::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* ModelAndFeatures::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.ModelAndFeatures.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
ModelAndFeatures::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.ModelAndFeatures.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& ModelAndFeatures::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.ModelAndFeatures.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* ModelAndFeatures::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.ModelAndFeatures.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
ModelAndFeatures::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.ModelAndFeatures.additional_data)
  return additional_data_;
}

// -------------------------------------------------------------------

// Ensemble_Member

// .tensorflow.decision_trees.Model submodel = 1;
inline bool Ensemble_Member::has_submodel() const {
  return this != internal_default_instance() && submodel_ != nullptr;
}
inline void Ensemble_Member::clear_submodel() {
  if (GetArenaNoVirtual() == nullptr && submodel_ != nullptr) {
    delete submodel_;
  }
  submodel_ = nullptr;
}
inline const ::tensorflow::decision_trees::Model& Ensemble_Member::submodel() const {
  const ::tensorflow::decision_trees::Model* p = submodel_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Ensemble.Member.submodel)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::Model*>(
      &::tensorflow::decision_trees::_Model_default_instance_);
}
inline ::tensorflow::decision_trees::Model* Ensemble_Member::release_submodel() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Ensemble.Member.submodel)
  
  ::tensorflow::decision_trees::Model* temp = submodel_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  submodel_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Model* Ensemble_Member::unsafe_arena_release_submodel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Ensemble.Member.submodel)
  
  ::tensorflow::decision_trees::Model* temp = submodel_;
  submodel_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Model* Ensemble_Member::mutable_submodel() {
  
  if (submodel_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::Model>(GetArenaNoVirtual());
    submodel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Ensemble.Member.submodel)
  return submodel_;
}
inline void Ensemble_Member::set_allocated_submodel(::tensorflow::decision_trees::Model* submodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete submodel_;
  }
  if (submodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(submodel);
    if (message_arena != submessage_arena) {
      submodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, submodel, submessage_arena);
    }
    
  } else {
    
  }
  submodel_ = submodel;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.Ensemble.Member.submodel)
}

// .google.protobuf.Int32Value submodel_id = 2;
inline bool Ensemble_Member::has_submodel_id() const {
  return this != internal_default_instance() && submodel_id_ != nullptr;
}
inline const ::google::protobuf::Int32Value& Ensemble_Member::submodel_id() const {
  const ::google::protobuf::Int32Value* p = submodel_id_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Ensemble.Member.submodel_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Ensemble_Member::release_submodel_id() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Ensemble.Member.submodel_id)
  
  ::google::protobuf::Int32Value* temp = submodel_id_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  submodel_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* Ensemble_Member::unsafe_arena_release_submodel_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Ensemble.Member.submodel_id)
  
  ::google::protobuf::Int32Value* temp = submodel_id_;
  submodel_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* Ensemble_Member::mutable_submodel_id() {
  
  if (submodel_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    submodel_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Ensemble.Member.submodel_id)
  return submodel_id_;
}
inline void Ensemble_Member::set_allocated_submodel_id(::google::protobuf::Int32Value* submodel_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(submodel_id_);
  }
  if (submodel_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(submodel_id)->GetArena();
    if (message_arena != submessage_arena) {
      submodel_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, submodel_id, submessage_arena);
    }
    
  } else {
    
  }
  submodel_id_ = submodel_id;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.Ensemble.Member.submodel_id)
}

// repeated .google.protobuf.Any additional_data = 3;
inline int Ensemble_Member::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* Ensemble_Member::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Ensemble.Member.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
Ensemble_Member::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.Ensemble.Member.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& Ensemble_Member::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Ensemble.Member.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* Ensemble_Member::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.Ensemble.Member.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
Ensemble_Member::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.Ensemble.Member.additional_data)
  return additional_data_;
}

// -------------------------------------------------------------------

// Ensemble

// repeated .tensorflow.decision_trees.Ensemble.Member members = 100;
inline int Ensemble::members_size() const {
  return members_.size();
}
inline void Ensemble::clear_members() {
  members_.Clear();
}
inline ::tensorflow::decision_trees::Ensemble_Member* Ensemble::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Ensemble.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Ensemble_Member >*
Ensemble::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.Ensemble.members)
  return &members_;
}
inline const ::tensorflow::decision_trees::Ensemble_Member& Ensemble::members(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Ensemble.members)
  return members_.Get(index);
}
inline ::tensorflow::decision_trees::Ensemble_Member* Ensemble::add_members() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.Ensemble.members)
  return members_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Ensemble_Member >&
Ensemble::members() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.Ensemble.members)
  return members_;
}

// .tensorflow.decision_trees.Summation summation_combination_technique = 1;
inline bool Ensemble::has_summation_combination_technique() const {
  return combination_technique_case() == kSummationCombinationTechnique;
}
inline void Ensemble::set_has_summation_combination_technique() {
  _oneof_case_[0] = kSummationCombinationTechnique;
}
inline void Ensemble::clear_summation_combination_technique() {
  if (has_summation_combination_technique()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete combination_technique_.summation_combination_technique_;
    }
    clear_has_combination_technique();
  }
}
inline ::tensorflow::decision_trees::Summation* Ensemble::release_summation_combination_technique() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Ensemble.summation_combination_technique)
  if (has_summation_combination_technique()) {
    clear_has_combination_technique();
      ::tensorflow::decision_trees::Summation* temp = combination_technique_.summation_combination_technique_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    combination_technique_.summation_combination_technique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::Summation& Ensemble::summation_combination_technique() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Ensemble.summation_combination_technique)
  return has_summation_combination_technique()
      ? *combination_technique_.summation_combination_technique_
      : *reinterpret_cast< ::tensorflow::decision_trees::Summation*>(&::tensorflow::decision_trees::_Summation_default_instance_);
}
inline ::tensorflow::decision_trees::Summation* Ensemble::unsafe_arena_release_summation_combination_technique() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Ensemble.summation_combination_technique)
  if (has_summation_combination_technique()) {
    clear_has_combination_technique();
    ::tensorflow::decision_trees::Summation* temp = combination_technique_.summation_combination_technique_;
    combination_technique_.summation_combination_technique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Ensemble::unsafe_arena_set_allocated_summation_combination_technique(::tensorflow::decision_trees::Summation* summation_combination_technique) {
  clear_combination_technique();
  if (summation_combination_technique) {
    set_has_summation_combination_technique();
    combination_technique_.summation_combination_technique_ = summation_combination_technique;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.Ensemble.summation_combination_technique)
}
inline ::tensorflow::decision_trees::Summation* Ensemble::mutable_summation_combination_technique() {
  if (!has_summation_combination_technique()) {
    clear_combination_technique();
    set_has_summation_combination_technique();
    combination_technique_.summation_combination_technique_ = CreateMaybeMessage< ::tensorflow::decision_trees::Summation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Ensemble.summation_combination_technique)
  return combination_technique_.summation_combination_technique_;
}

// .tensorflow.decision_trees.Averaging averaging_combination_technique = 2;
inline bool Ensemble::has_averaging_combination_technique() const {
  return combination_technique_case() == kAveragingCombinationTechnique;
}
inline void Ensemble::set_has_averaging_combination_technique() {
  _oneof_case_[0] = kAveragingCombinationTechnique;
}
inline void Ensemble::clear_averaging_combination_technique() {
  if (has_averaging_combination_technique()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete combination_technique_.averaging_combination_technique_;
    }
    clear_has_combination_technique();
  }
}
inline ::tensorflow::decision_trees::Averaging* Ensemble::release_averaging_combination_technique() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Ensemble.averaging_combination_technique)
  if (has_averaging_combination_technique()) {
    clear_has_combination_technique();
      ::tensorflow::decision_trees::Averaging* temp = combination_technique_.averaging_combination_technique_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    combination_technique_.averaging_combination_technique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::Averaging& Ensemble::averaging_combination_technique() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Ensemble.averaging_combination_technique)
  return has_averaging_combination_technique()
      ? *combination_technique_.averaging_combination_technique_
      : *reinterpret_cast< ::tensorflow::decision_trees::Averaging*>(&::tensorflow::decision_trees::_Averaging_default_instance_);
}
inline ::tensorflow::decision_trees::Averaging* Ensemble::unsafe_arena_release_averaging_combination_technique() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Ensemble.averaging_combination_technique)
  if (has_averaging_combination_technique()) {
    clear_has_combination_technique();
    ::tensorflow::decision_trees::Averaging* temp = combination_technique_.averaging_combination_technique_;
    combination_technique_.averaging_combination_technique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Ensemble::unsafe_arena_set_allocated_averaging_combination_technique(::tensorflow::decision_trees::Averaging* averaging_combination_technique) {
  clear_combination_technique();
  if (averaging_combination_technique) {
    set_has_averaging_combination_technique();
    combination_technique_.averaging_combination_technique_ = averaging_combination_technique;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.Ensemble.averaging_combination_technique)
}
inline ::tensorflow::decision_trees::Averaging* Ensemble::mutable_averaging_combination_technique() {
  if (!has_averaging_combination_technique()) {
    clear_combination_technique();
    set_has_averaging_combination_technique();
    combination_technique_.averaging_combination_technique_ = CreateMaybeMessage< ::tensorflow::decision_trees::Averaging >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Ensemble.averaging_combination_technique)
  return combination_technique_.averaging_combination_technique_;
}

// .google.protobuf.Any custom_combination_technique = 3;
inline bool Ensemble::has_custom_combination_technique() const {
  return combination_technique_case() == kCustomCombinationTechnique;
}
inline void Ensemble::set_has_custom_combination_technique() {
  _oneof_case_[0] = kCustomCombinationTechnique;
}
inline ::google::protobuf::Any* Ensemble::release_custom_combination_technique() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Ensemble.custom_combination_technique)
  if (has_custom_combination_technique()) {
    clear_has_combination_technique();
      ::google::protobuf::Any* temp = combination_technique_.custom_combination_technique_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    combination_technique_.custom_combination_technique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Any& Ensemble::custom_combination_technique() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Ensemble.custom_combination_technique)
  return has_custom_combination_technique()
      ? *combination_technique_.custom_combination_technique_
      : *reinterpret_cast< ::google::protobuf::Any*>(&::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Ensemble::unsafe_arena_release_custom_combination_technique() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Ensemble.custom_combination_technique)
  if (has_custom_combination_technique()) {
    clear_has_combination_technique();
    ::google::protobuf::Any* temp = combination_technique_.custom_combination_technique_;
    combination_technique_.custom_combination_technique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Ensemble::unsafe_arena_set_allocated_custom_combination_technique(::google::protobuf::Any* custom_combination_technique) {
  clear_combination_technique();
  if (custom_combination_technique) {
    set_has_custom_combination_technique();
    combination_technique_.custom_combination_technique_ = custom_combination_technique;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.Ensemble.custom_combination_technique)
}
inline ::google::protobuf::Any* Ensemble::mutable_custom_combination_technique() {
  if (!has_custom_combination_technique()) {
    clear_combination_technique();
    set_has_custom_combination_technique();
    combination_technique_.custom_combination_technique_ = CreateMaybeMessage< ::google::protobuf::Any >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Ensemble.custom_combination_technique)
  return combination_technique_.custom_combination_technique_;
}

// repeated .google.protobuf.Any additional_data = 4;
inline int Ensemble::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* Ensemble::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Ensemble.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
Ensemble::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.Ensemble.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& Ensemble::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Ensemble.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* Ensemble::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.Ensemble.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
Ensemble::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.Ensemble.additional_data)
  return additional_data_;
}

inline bool Ensemble::has_combination_technique() const {
  return combination_technique_case() != COMBINATION_TECHNIQUE_NOT_SET;
}
inline void Ensemble::clear_has_combination_technique() {
  _oneof_case_[0] = COMBINATION_TECHNIQUE_NOT_SET;
}
inline Ensemble::CombinationTechniqueCase Ensemble::combination_technique_case() const {
  return Ensemble::CombinationTechniqueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Summation

// repeated .google.protobuf.Any additional_data = 1;
inline int Summation::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* Summation::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Summation.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
Summation::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.Summation.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& Summation::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Summation.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* Summation::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.Summation.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
Summation::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.Summation.additional_data)
  return additional_data_;
}

// -------------------------------------------------------------------

// Averaging

// repeated .google.protobuf.Any additional_data = 1;
inline int Averaging::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* Averaging::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Averaging.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
Averaging::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.Averaging.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& Averaging::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Averaging.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* Averaging::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.Averaging.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
Averaging::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.Averaging.additional_data)
  return additional_data_;
}

// -------------------------------------------------------------------

// DecisionTree

// repeated .tensorflow.decision_trees.TreeNode nodes = 1;
inline int DecisionTree::nodes_size() const {
  return nodes_.size();
}
inline void DecisionTree::clear_nodes() {
  nodes_.Clear();
}
inline ::tensorflow::decision_trees::TreeNode* DecisionTree::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.DecisionTree.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >*
DecisionTree::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.DecisionTree.nodes)
  return &nodes_;
}
inline const ::tensorflow::decision_trees::TreeNode& DecisionTree::nodes(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.DecisionTree.nodes)
  return nodes_.Get(index);
}
inline ::tensorflow::decision_trees::TreeNode* DecisionTree::add_nodes() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.DecisionTree.nodes)
  return nodes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::TreeNode >&
DecisionTree::nodes() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.DecisionTree.nodes)
  return nodes_;
}

// repeated .google.protobuf.Any additional_data = 2;
inline int DecisionTree::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* DecisionTree::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.DecisionTree.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
DecisionTree::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.DecisionTree.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& DecisionTree::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.DecisionTree.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* DecisionTree::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.DecisionTree.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
DecisionTree::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.DecisionTree.additional_data)
  return additional_data_;
}

// -------------------------------------------------------------------

// TreeNode

// .google.protobuf.Int32Value node_id = 1;
inline bool TreeNode::has_node_id() const {
  return this != internal_default_instance() && node_id_ != nullptr;
}
inline const ::google::protobuf::Int32Value& TreeNode::node_id() const {
  const ::google::protobuf::Int32Value* p = node_id_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.TreeNode.node_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* TreeNode::release_node_id() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.TreeNode.node_id)
  
  ::google::protobuf::Int32Value* temp = node_id_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  node_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* TreeNode::unsafe_arena_release_node_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.TreeNode.node_id)
  
  ::google::protobuf::Int32Value* temp = node_id_;
  node_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* TreeNode::mutable_node_id() {
  
  if (node_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    node_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.TreeNode.node_id)
  return node_id_;
}
inline void TreeNode::set_allocated_node_id(::google::protobuf::Int32Value* node_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_id_);
  }
  if (node_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_id)->GetArena();
    if (message_arena != submessage_arena) {
      node_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_id, submessage_arena);
    }
    
  } else {
    
  }
  node_id_ = node_id;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.TreeNode.node_id)
}

// .google.protobuf.Int32Value depth = 2;
inline bool TreeNode::has_depth() const {
  return this != internal_default_instance() && depth_ != nullptr;
}
inline const ::google::protobuf::Int32Value& TreeNode::depth() const {
  const ::google::protobuf::Int32Value* p = depth_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.TreeNode.depth)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* TreeNode::release_depth() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.TreeNode.depth)
  
  ::google::protobuf::Int32Value* temp = depth_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  depth_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* TreeNode::unsafe_arena_release_depth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.TreeNode.depth)
  
  ::google::protobuf::Int32Value* temp = depth_;
  depth_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* TreeNode::mutable_depth() {
  
  if (depth_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    depth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.TreeNode.depth)
  return depth_;
}
inline void TreeNode::set_allocated_depth(::google::protobuf::Int32Value* depth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(depth_);
  }
  if (depth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(depth)->GetArena();
    if (message_arena != submessage_arena) {
      depth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, depth, submessage_arena);
    }
    
  } else {
    
  }
  depth_ = depth;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.TreeNode.depth)
}

// .google.protobuf.Int32Value subtree_size = 3;
inline bool TreeNode::has_subtree_size() const {
  return this != internal_default_instance() && subtree_size_ != nullptr;
}
inline const ::google::protobuf::Int32Value& TreeNode::subtree_size() const {
  const ::google::protobuf::Int32Value* p = subtree_size_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.TreeNode.subtree_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* TreeNode::release_subtree_size() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.TreeNode.subtree_size)
  
  ::google::protobuf::Int32Value* temp = subtree_size_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  subtree_size_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* TreeNode::unsafe_arena_release_subtree_size() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.TreeNode.subtree_size)
  
  ::google::protobuf::Int32Value* temp = subtree_size_;
  subtree_size_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* TreeNode::mutable_subtree_size() {
  
  if (subtree_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    subtree_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.TreeNode.subtree_size)
  return subtree_size_;
}
inline void TreeNode::set_allocated_subtree_size(::google::protobuf::Int32Value* subtree_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(subtree_size_);
  }
  if (subtree_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subtree_size)->GetArena();
    if (message_arena != submessage_arena) {
      subtree_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtree_size, submessage_arena);
    }
    
  } else {
    
  }
  subtree_size_ = subtree_size;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.TreeNode.subtree_size)
}

// .tensorflow.decision_trees.BinaryNode binary_node = 4;
inline bool TreeNode::has_binary_node() const {
  return node_type_case() == kBinaryNode;
}
inline void TreeNode::set_has_binary_node() {
  _oneof_case_[0] = kBinaryNode;
}
inline void TreeNode::clear_binary_node() {
  if (has_binary_node()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete node_type_.binary_node_;
    }
    clear_has_node_type();
  }
}
inline ::tensorflow::decision_trees::BinaryNode* TreeNode::release_binary_node() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.TreeNode.binary_node)
  if (has_binary_node()) {
    clear_has_node_type();
      ::tensorflow::decision_trees::BinaryNode* temp = node_type_.binary_node_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_type_.binary_node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::BinaryNode& TreeNode::binary_node() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.TreeNode.binary_node)
  return has_binary_node()
      ? *node_type_.binary_node_
      : *reinterpret_cast< ::tensorflow::decision_trees::BinaryNode*>(&::tensorflow::decision_trees::_BinaryNode_default_instance_);
}
inline ::tensorflow::decision_trees::BinaryNode* TreeNode::unsafe_arena_release_binary_node() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.TreeNode.binary_node)
  if (has_binary_node()) {
    clear_has_node_type();
    ::tensorflow::decision_trees::BinaryNode* temp = node_type_.binary_node_;
    node_type_.binary_node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_binary_node(::tensorflow::decision_trees::BinaryNode* binary_node) {
  clear_node_type();
  if (binary_node) {
    set_has_binary_node();
    node_type_.binary_node_ = binary_node;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.TreeNode.binary_node)
}
inline ::tensorflow::decision_trees::BinaryNode* TreeNode::mutable_binary_node() {
  if (!has_binary_node()) {
    clear_node_type();
    set_has_binary_node();
    node_type_.binary_node_ = CreateMaybeMessage< ::tensorflow::decision_trees::BinaryNode >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.TreeNode.binary_node)
  return node_type_.binary_node_;
}

// .tensorflow.decision_trees.Leaf leaf = 5;
inline bool TreeNode::has_leaf() const {
  return node_type_case() == kLeaf;
}
inline void TreeNode::set_has_leaf() {
  _oneof_case_[0] = kLeaf;
}
inline void TreeNode::clear_leaf() {
  if (has_leaf()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete node_type_.leaf_;
    }
    clear_has_node_type();
  }
}
inline ::tensorflow::decision_trees::Leaf* TreeNode::release_leaf() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.TreeNode.leaf)
  if (has_leaf()) {
    clear_has_node_type();
      ::tensorflow::decision_trees::Leaf* temp = node_type_.leaf_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::Leaf& TreeNode::leaf() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.TreeNode.leaf)
  return has_leaf()
      ? *node_type_.leaf_
      : *reinterpret_cast< ::tensorflow::decision_trees::Leaf*>(&::tensorflow::decision_trees::_Leaf_default_instance_);
}
inline ::tensorflow::decision_trees::Leaf* TreeNode::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.TreeNode.leaf)
  if (has_leaf()) {
    clear_has_node_type();
    ::tensorflow::decision_trees::Leaf* temp = node_type_.leaf_;
    node_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_leaf(::tensorflow::decision_trees::Leaf* leaf) {
  clear_node_type();
  if (leaf) {
    set_has_leaf();
    node_type_.leaf_ = leaf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.TreeNode.leaf)
}
inline ::tensorflow::decision_trees::Leaf* TreeNode::mutable_leaf() {
  if (!has_leaf()) {
    clear_node_type();
    set_has_leaf();
    node_type_.leaf_ = CreateMaybeMessage< ::tensorflow::decision_trees::Leaf >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.TreeNode.leaf)
  return node_type_.leaf_;
}

// .google.protobuf.Any custom_node_type = 6;
inline bool TreeNode::has_custom_node_type() const {
  return node_type_case() == kCustomNodeType;
}
inline void TreeNode::set_has_custom_node_type() {
  _oneof_case_[0] = kCustomNodeType;
}
inline ::google::protobuf::Any* TreeNode::release_custom_node_type() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.TreeNode.custom_node_type)
  if (has_custom_node_type()) {
    clear_has_node_type();
      ::google::protobuf::Any* temp = node_type_.custom_node_type_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_type_.custom_node_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Any& TreeNode::custom_node_type() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.TreeNode.custom_node_type)
  return has_custom_node_type()
      ? *node_type_.custom_node_type_
      : *reinterpret_cast< ::google::protobuf::Any*>(&::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* TreeNode::unsafe_arena_release_custom_node_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.TreeNode.custom_node_type)
  if (has_custom_node_type()) {
    clear_has_node_type();
    ::google::protobuf::Any* temp = node_type_.custom_node_type_;
    node_type_.custom_node_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_custom_node_type(::google::protobuf::Any* custom_node_type) {
  clear_node_type();
  if (custom_node_type) {
    set_has_custom_node_type();
    node_type_.custom_node_type_ = custom_node_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.TreeNode.custom_node_type)
}
inline ::google::protobuf::Any* TreeNode::mutable_custom_node_type() {
  if (!has_custom_node_type()) {
    clear_node_type();
    set_has_custom_node_type();
    node_type_.custom_node_type_ = CreateMaybeMessage< ::google::protobuf::Any >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.TreeNode.custom_node_type)
  return node_type_.custom_node_type_;
}

// repeated .google.protobuf.Any additional_data = 7;
inline int TreeNode::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* TreeNode::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.TreeNode.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
TreeNode::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.TreeNode.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& TreeNode::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.TreeNode.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* TreeNode::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.TreeNode.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
TreeNode::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.TreeNode.additional_data)
  return additional_data_;
}

inline bool TreeNode::has_node_type() const {
  return node_type_case() != NODE_TYPE_NOT_SET;
}
inline void TreeNode::clear_has_node_type() {
  _oneof_case_[0] = NODE_TYPE_NOT_SET;
}
inline TreeNode::NodeTypeCase TreeNode::node_type_case() const {
  return TreeNode::NodeTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BinaryNode

// .google.protobuf.Int32Value left_child_id = 1;
inline bool BinaryNode::has_left_child_id() const {
  return this != internal_default_instance() && left_child_id_ != nullptr;
}
inline const ::google::protobuf::Int32Value& BinaryNode::left_child_id() const {
  const ::google::protobuf::Int32Value* p = left_child_id_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.BinaryNode.left_child_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* BinaryNode::release_left_child_id() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.BinaryNode.left_child_id)
  
  ::google::protobuf::Int32Value* temp = left_child_id_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  left_child_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* BinaryNode::unsafe_arena_release_left_child_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.BinaryNode.left_child_id)
  
  ::google::protobuf::Int32Value* temp = left_child_id_;
  left_child_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* BinaryNode::mutable_left_child_id() {
  
  if (left_child_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    left_child_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.BinaryNode.left_child_id)
  return left_child_id_;
}
inline void BinaryNode::set_allocated_left_child_id(::google::protobuf::Int32Value* left_child_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_child_id_);
  }
  if (left_child_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_child_id)->GetArena();
    if (message_arena != submessage_arena) {
      left_child_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_child_id, submessage_arena);
    }
    
  } else {
    
  }
  left_child_id_ = left_child_id;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.BinaryNode.left_child_id)
}

// .google.protobuf.Int32Value right_child_id = 2;
inline bool BinaryNode::has_right_child_id() const {
  return this != internal_default_instance() && right_child_id_ != nullptr;
}
inline const ::google::protobuf::Int32Value& BinaryNode::right_child_id() const {
  const ::google::protobuf::Int32Value* p = right_child_id_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.BinaryNode.right_child_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* BinaryNode::release_right_child_id() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.BinaryNode.right_child_id)
  
  ::google::protobuf::Int32Value* temp = right_child_id_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  right_child_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* BinaryNode::unsafe_arena_release_right_child_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.BinaryNode.right_child_id)
  
  ::google::protobuf::Int32Value* temp = right_child_id_;
  right_child_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int32Value* BinaryNode::mutable_right_child_id() {
  
  if (right_child_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    right_child_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.BinaryNode.right_child_id)
  return right_child_id_;
}
inline void BinaryNode::set_allocated_right_child_id(::google::protobuf::Int32Value* right_child_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_child_id_);
  }
  if (right_child_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_child_id)->GetArena();
    if (message_arena != submessage_arena) {
      right_child_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_child_id, submessage_arena);
    }
    
  } else {
    
  }
  right_child_id_ = right_child_id;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.BinaryNode.right_child_id)
}

// .tensorflow.decision_trees.BinaryNode.Direction default_direction = 3;
inline void BinaryNode::clear_default_direction() {
  default_direction_ = 0;
}
inline ::tensorflow::decision_trees::BinaryNode_Direction BinaryNode::default_direction() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.BinaryNode.default_direction)
  return static_cast< ::tensorflow::decision_trees::BinaryNode_Direction >(default_direction_);
}
inline void BinaryNode::set_default_direction(::tensorflow::decision_trees::BinaryNode_Direction value) {
  
  default_direction_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.decision_trees.BinaryNode.default_direction)
}

// .tensorflow.decision_trees.InequalityTest inequality_left_child_test = 4;
inline bool BinaryNode::has_inequality_left_child_test() const {
  return left_child_test_case() == kInequalityLeftChildTest;
}
inline void BinaryNode::set_has_inequality_left_child_test() {
  _oneof_case_[0] = kInequalityLeftChildTest;
}
inline void BinaryNode::clear_inequality_left_child_test() {
  if (has_inequality_left_child_test()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete left_child_test_.inequality_left_child_test_;
    }
    clear_has_left_child_test();
  }
}
inline ::tensorflow::decision_trees::InequalityTest* BinaryNode::release_inequality_left_child_test() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.BinaryNode.inequality_left_child_test)
  if (has_inequality_left_child_test()) {
    clear_has_left_child_test();
      ::tensorflow::decision_trees::InequalityTest* temp = left_child_test_.inequality_left_child_test_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    left_child_test_.inequality_left_child_test_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::InequalityTest& BinaryNode::inequality_left_child_test() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.BinaryNode.inequality_left_child_test)
  return has_inequality_left_child_test()
      ? *left_child_test_.inequality_left_child_test_
      : *reinterpret_cast< ::tensorflow::decision_trees::InequalityTest*>(&::tensorflow::decision_trees::_InequalityTest_default_instance_);
}
inline ::tensorflow::decision_trees::InequalityTest* BinaryNode::unsafe_arena_release_inequality_left_child_test() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.BinaryNode.inequality_left_child_test)
  if (has_inequality_left_child_test()) {
    clear_has_left_child_test();
    ::tensorflow::decision_trees::InequalityTest* temp = left_child_test_.inequality_left_child_test_;
    left_child_test_.inequality_left_child_test_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BinaryNode::unsafe_arena_set_allocated_inequality_left_child_test(::tensorflow::decision_trees::InequalityTest* inequality_left_child_test) {
  clear_left_child_test();
  if (inequality_left_child_test) {
    set_has_inequality_left_child_test();
    left_child_test_.inequality_left_child_test_ = inequality_left_child_test;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.BinaryNode.inequality_left_child_test)
}
inline ::tensorflow::decision_trees::InequalityTest* BinaryNode::mutable_inequality_left_child_test() {
  if (!has_inequality_left_child_test()) {
    clear_left_child_test();
    set_has_inequality_left_child_test();
    left_child_test_.inequality_left_child_test_ = CreateMaybeMessage< ::tensorflow::decision_trees::InequalityTest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.BinaryNode.inequality_left_child_test)
  return left_child_test_.inequality_left_child_test_;
}

// .google.protobuf.Any custom_left_child_test = 5;
inline bool BinaryNode::has_custom_left_child_test() const {
  return left_child_test_case() == kCustomLeftChildTest;
}
inline void BinaryNode::set_has_custom_left_child_test() {
  _oneof_case_[0] = kCustomLeftChildTest;
}
inline ::google::protobuf::Any* BinaryNode::release_custom_left_child_test() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.BinaryNode.custom_left_child_test)
  if (has_custom_left_child_test()) {
    clear_has_left_child_test();
      ::google::protobuf::Any* temp = left_child_test_.custom_left_child_test_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    left_child_test_.custom_left_child_test_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Any& BinaryNode::custom_left_child_test() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.BinaryNode.custom_left_child_test)
  return has_custom_left_child_test()
      ? *left_child_test_.custom_left_child_test_
      : *reinterpret_cast< ::google::protobuf::Any*>(&::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* BinaryNode::unsafe_arena_release_custom_left_child_test() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.BinaryNode.custom_left_child_test)
  if (has_custom_left_child_test()) {
    clear_has_left_child_test();
    ::google::protobuf::Any* temp = left_child_test_.custom_left_child_test_;
    left_child_test_.custom_left_child_test_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BinaryNode::unsafe_arena_set_allocated_custom_left_child_test(::google::protobuf::Any* custom_left_child_test) {
  clear_left_child_test();
  if (custom_left_child_test) {
    set_has_custom_left_child_test();
    left_child_test_.custom_left_child_test_ = custom_left_child_test;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.BinaryNode.custom_left_child_test)
}
inline ::google::protobuf::Any* BinaryNode::mutable_custom_left_child_test() {
  if (!has_custom_left_child_test()) {
    clear_left_child_test();
    set_has_custom_left_child_test();
    left_child_test_.custom_left_child_test_ = CreateMaybeMessage< ::google::protobuf::Any >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.BinaryNode.custom_left_child_test)
  return left_child_test_.custom_left_child_test_;
}

inline bool BinaryNode::has_left_child_test() const {
  return left_child_test_case() != LEFT_CHILD_TEST_NOT_SET;
}
inline void BinaryNode::clear_has_left_child_test() {
  _oneof_case_[0] = LEFT_CHILD_TEST_NOT_SET;
}
inline BinaryNode::LeftChildTestCase BinaryNode::left_child_test_case() const {
  return BinaryNode::LeftChildTestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SparseVector

// map<int64, .tensorflow.decision_trees.Value> sparse_value = 1;
inline int SparseVector::sparse_value_size() const {
  return sparse_value_.size();
}
inline void SparseVector::clear_sparse_value() {
  sparse_value_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::tensorflow::decision_trees::Value >&
SparseVector::sparse_value() const {
  // @@protoc_insertion_point(field_map:tensorflow.decision_trees.SparseVector.sparse_value)
  return sparse_value_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::tensorflow::decision_trees::Value >*
SparseVector::mutable_sparse_value() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.decision_trees.SparseVector.sparse_value)
  return sparse_value_.MutableMap();
}

// -------------------------------------------------------------------

// Vector

// repeated .tensorflow.decision_trees.Value value = 1;
inline int Vector::value_size() const {
  return value_.size();
}
inline void Vector::clear_value() {
  value_.Clear();
}
inline ::tensorflow::decision_trees::Value* Vector::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Vector.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Value >*
Vector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.Vector.value)
  return &value_;
}
inline const ::tensorflow::decision_trees::Value& Vector::value(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Vector.value)
  return value_.Get(index);
}
inline ::tensorflow::decision_trees::Value* Vector::add_value() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.Vector.value)
  return value_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::Value >&
Vector::value() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.Vector.value)
  return value_;
}

// -------------------------------------------------------------------

// Leaf

// .tensorflow.decision_trees.Vector vector = 1;
inline bool Leaf::has_vector() const {
  return leaf_case() == kVector;
}
inline void Leaf::set_has_vector() {
  _oneof_case_[0] = kVector;
}
inline void Leaf::clear_vector() {
  if (has_vector()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete leaf_.vector_;
    }
    clear_has_leaf();
  }
}
inline ::tensorflow::decision_trees::Vector* Leaf::release_vector() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Leaf.vector)
  if (has_vector()) {
    clear_has_leaf();
      ::tensorflow::decision_trees::Vector* temp = leaf_.vector_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    leaf_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::Vector& Leaf::vector() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Leaf.vector)
  return has_vector()
      ? *leaf_.vector_
      : *reinterpret_cast< ::tensorflow::decision_trees::Vector*>(&::tensorflow::decision_trees::_Vector_default_instance_);
}
inline ::tensorflow::decision_trees::Vector* Leaf::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Leaf.vector)
  if (has_vector()) {
    clear_has_leaf();
    ::tensorflow::decision_trees::Vector* temp = leaf_.vector_;
    leaf_.vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Leaf::unsafe_arena_set_allocated_vector(::tensorflow::decision_trees::Vector* vector) {
  clear_leaf();
  if (vector) {
    set_has_vector();
    leaf_.vector_ = vector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.Leaf.vector)
}
inline ::tensorflow::decision_trees::Vector* Leaf::mutable_vector() {
  if (!has_vector()) {
    clear_leaf();
    set_has_vector();
    leaf_.vector_ = CreateMaybeMessage< ::tensorflow::decision_trees::Vector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Leaf.vector)
  return leaf_.vector_;
}

// .tensorflow.decision_trees.SparseVector sparse_vector = 2;
inline bool Leaf::has_sparse_vector() const {
  return leaf_case() == kSparseVector;
}
inline void Leaf::set_has_sparse_vector() {
  _oneof_case_[0] = kSparseVector;
}
inline void Leaf::clear_sparse_vector() {
  if (has_sparse_vector()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete leaf_.sparse_vector_;
    }
    clear_has_leaf();
  }
}
inline ::tensorflow::decision_trees::SparseVector* Leaf::release_sparse_vector() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Leaf.sparse_vector)
  if (has_sparse_vector()) {
    clear_has_leaf();
      ::tensorflow::decision_trees::SparseVector* temp = leaf_.sparse_vector_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    leaf_.sparse_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::SparseVector& Leaf::sparse_vector() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Leaf.sparse_vector)
  return has_sparse_vector()
      ? *leaf_.sparse_vector_
      : *reinterpret_cast< ::tensorflow::decision_trees::SparseVector*>(&::tensorflow::decision_trees::_SparseVector_default_instance_);
}
inline ::tensorflow::decision_trees::SparseVector* Leaf::unsafe_arena_release_sparse_vector() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Leaf.sparse_vector)
  if (has_sparse_vector()) {
    clear_has_leaf();
    ::tensorflow::decision_trees::SparseVector* temp = leaf_.sparse_vector_;
    leaf_.sparse_vector_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Leaf::unsafe_arena_set_allocated_sparse_vector(::tensorflow::decision_trees::SparseVector* sparse_vector) {
  clear_leaf();
  if (sparse_vector) {
    set_has_sparse_vector();
    leaf_.sparse_vector_ = sparse_vector;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.Leaf.sparse_vector)
}
inline ::tensorflow::decision_trees::SparseVector* Leaf::mutable_sparse_vector() {
  if (!has_sparse_vector()) {
    clear_leaf();
    set_has_sparse_vector();
    leaf_.sparse_vector_ = CreateMaybeMessage< ::tensorflow::decision_trees::SparseVector >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Leaf.sparse_vector)
  return leaf_.sparse_vector_;
}

// repeated .google.protobuf.Any additional_data = 3;
inline int Leaf::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* Leaf::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Leaf.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
Leaf::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.Leaf.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& Leaf::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Leaf.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* Leaf::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.Leaf.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
Leaf::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.Leaf.additional_data)
  return additional_data_;
}

inline bool Leaf::has_leaf() const {
  return leaf_case() != LEAF_NOT_SET;
}
inline void Leaf::clear_has_leaf() {
  _oneof_case_[0] = LEAF_NOT_SET;
}
inline Leaf::LeafCase Leaf::leaf_case() const {
  return Leaf::LeafCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FeatureId

// .google.protobuf.StringValue id = 1;
inline bool FeatureId::has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline const ::google::protobuf::StringValue& FeatureId::id() const {
  const ::google::protobuf::StringValue* p = id_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.FeatureId.id)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* FeatureId::release_id() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.FeatureId.id)
  
  ::google::protobuf::StringValue* temp = id_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  id_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* FeatureId::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.FeatureId.id)
  
  ::google::protobuf::StringValue* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* FeatureId::mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.FeatureId.id)
  return id_;
}
inline void FeatureId::set_allocated_id(::google::protobuf::StringValue* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.FeatureId.id)
}

// repeated .google.protobuf.Any additional_data = 2;
inline int FeatureId::additional_data_size() const {
  return additional_data_.size();
}
inline ::google::protobuf::Any* FeatureId::mutable_additional_data(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.FeatureId.additional_data)
  return additional_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >*
FeatureId::mutable_additional_data() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.FeatureId.additional_data)
  return &additional_data_;
}
inline const ::google::protobuf::Any& FeatureId::additional_data(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.FeatureId.additional_data)
  return additional_data_.Get(index);
}
inline ::google::protobuf::Any* FeatureId::add_additional_data() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.FeatureId.additional_data)
  return additional_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::google::protobuf::Any >&
FeatureId::additional_data() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.FeatureId.additional_data)
  return additional_data_;
}

// -------------------------------------------------------------------

// ObliqueFeatures

// repeated .tensorflow.decision_trees.FeatureId features = 1;
inline int ObliqueFeatures::features_size() const {
  return features_.size();
}
inline void ObliqueFeatures::clear_features() {
  features_.Clear();
}
inline ::tensorflow::decision_trees::FeatureId* ObliqueFeatures::mutable_features(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.ObliqueFeatures.features)
  return features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::FeatureId >*
ObliqueFeatures::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.ObliqueFeatures.features)
  return &features_;
}
inline const ::tensorflow::decision_trees::FeatureId& ObliqueFeatures::features(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.ObliqueFeatures.features)
  return features_.Get(index);
}
inline ::tensorflow::decision_trees::FeatureId* ObliqueFeatures::add_features() {
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.ObliqueFeatures.features)
  return features_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tensorflow::decision_trees::FeatureId >&
ObliqueFeatures::features() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.ObliqueFeatures.features)
  return features_;
}

// repeated float weights = 2;
inline int ObliqueFeatures::weights_size() const {
  return weights_.size();
}
inline void ObliqueFeatures::clear_weights() {
  weights_.Clear();
}
inline float ObliqueFeatures::weights(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.ObliqueFeatures.weights)
  return weights_.Get(index);
}
inline void ObliqueFeatures::set_weights(int index, float value) {
  weights_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.decision_trees.ObliqueFeatures.weights)
}
inline void ObliqueFeatures::add_weights(float value) {
  weights_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.decision_trees.ObliqueFeatures.weights)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ObliqueFeatures::weights() const {
  // @@protoc_insertion_point(field_list:tensorflow.decision_trees.ObliqueFeatures.weights)
  return weights_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ObliqueFeatures::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.decision_trees.ObliqueFeatures.weights)
  return &weights_;
}

// -------------------------------------------------------------------

// InequalityTest

// .tensorflow.decision_trees.FeatureId feature_id = 1;
inline bool InequalityTest::has_feature_id() const {
  return FeatureSum_case() == kFeatureId;
}
inline void InequalityTest::set_has_feature_id() {
  _oneof_case_[0] = kFeatureId;
}
inline void InequalityTest::clear_feature_id() {
  if (has_feature_id()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete FeatureSum_.feature_id_;
    }
    clear_has_FeatureSum();
  }
}
inline ::tensorflow::decision_trees::FeatureId* InequalityTest::release_feature_id() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.InequalityTest.feature_id)
  if (has_feature_id()) {
    clear_has_FeatureSum();
      ::tensorflow::decision_trees::FeatureId* temp = FeatureSum_.feature_id_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeatureSum_.feature_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::FeatureId& InequalityTest::feature_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.InequalityTest.feature_id)
  return has_feature_id()
      ? *FeatureSum_.feature_id_
      : *reinterpret_cast< ::tensorflow::decision_trees::FeatureId*>(&::tensorflow::decision_trees::_FeatureId_default_instance_);
}
inline ::tensorflow::decision_trees::FeatureId* InequalityTest::unsafe_arena_release_feature_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.InequalityTest.feature_id)
  if (has_feature_id()) {
    clear_has_FeatureSum();
    ::tensorflow::decision_trees::FeatureId* temp = FeatureSum_.feature_id_;
    FeatureSum_.feature_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InequalityTest::unsafe_arena_set_allocated_feature_id(::tensorflow::decision_trees::FeatureId* feature_id) {
  clear_FeatureSum();
  if (feature_id) {
    set_has_feature_id();
    FeatureSum_.feature_id_ = feature_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.InequalityTest.feature_id)
}
inline ::tensorflow::decision_trees::FeatureId* InequalityTest::mutable_feature_id() {
  if (!has_feature_id()) {
    clear_FeatureSum();
    set_has_feature_id();
    FeatureSum_.feature_id_ = CreateMaybeMessage< ::tensorflow::decision_trees::FeatureId >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.InequalityTest.feature_id)
  return FeatureSum_.feature_id_;
}

// .tensorflow.decision_trees.ObliqueFeatures oblique = 4;
inline bool InequalityTest::has_oblique() const {
  return FeatureSum_case() == kOblique;
}
inline void InequalityTest::set_has_oblique() {
  _oneof_case_[0] = kOblique;
}
inline void InequalityTest::clear_oblique() {
  if (has_oblique()) {
    if (GetArenaNoVirtual() == nullptr) {
      delete FeatureSum_.oblique_;
    }
    clear_has_FeatureSum();
  }
}
inline ::tensorflow::decision_trees::ObliqueFeatures* InequalityTest::release_oblique() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.InequalityTest.oblique)
  if (has_oblique()) {
    clear_has_FeatureSum();
      ::tensorflow::decision_trees::ObliqueFeatures* temp = FeatureSum_.oblique_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    FeatureSum_.oblique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tensorflow::decision_trees::ObliqueFeatures& InequalityTest::oblique() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.InequalityTest.oblique)
  return has_oblique()
      ? *FeatureSum_.oblique_
      : *reinterpret_cast< ::tensorflow::decision_trees::ObliqueFeatures*>(&::tensorflow::decision_trees::_ObliqueFeatures_default_instance_);
}
inline ::tensorflow::decision_trees::ObliqueFeatures* InequalityTest::unsafe_arena_release_oblique() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.InequalityTest.oblique)
  if (has_oblique()) {
    clear_has_FeatureSum();
    ::tensorflow::decision_trees::ObliqueFeatures* temp = FeatureSum_.oblique_;
    FeatureSum_.oblique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InequalityTest::unsafe_arena_set_allocated_oblique(::tensorflow::decision_trees::ObliqueFeatures* oblique) {
  clear_FeatureSum();
  if (oblique) {
    set_has_oblique();
    FeatureSum_.oblique_ = oblique;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.InequalityTest.oblique)
}
inline ::tensorflow::decision_trees::ObliqueFeatures* InequalityTest::mutable_oblique() {
  if (!has_oblique()) {
    clear_FeatureSum();
    set_has_oblique();
    FeatureSum_.oblique_ = CreateMaybeMessage< ::tensorflow::decision_trees::ObliqueFeatures >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.InequalityTest.oblique)
  return FeatureSum_.oblique_;
}

// .tensorflow.decision_trees.InequalityTest.Type type = 2;
inline void InequalityTest::clear_type() {
  type_ = 0;
}
inline ::tensorflow::decision_trees::InequalityTest_Type InequalityTest::type() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.InequalityTest.type)
  return static_cast< ::tensorflow::decision_trees::InequalityTest_Type >(type_);
}
inline void InequalityTest::set_type(::tensorflow::decision_trees::InequalityTest_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.decision_trees.InequalityTest.type)
}

// .tensorflow.decision_trees.Value threshold = 3;
inline bool InequalityTest::has_threshold() const {
  return this != internal_default_instance() && threshold_ != nullptr;
}
inline void InequalityTest::clear_threshold() {
  if (GetArenaNoVirtual() == nullptr && threshold_ != nullptr) {
    delete threshold_;
  }
  threshold_ = nullptr;
}
inline const ::tensorflow::decision_trees::Value& InequalityTest::threshold() const {
  const ::tensorflow::decision_trees::Value* p = threshold_;
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.InequalityTest.threshold)
  return p != nullptr ? *p : *reinterpret_cast<const ::tensorflow::decision_trees::Value*>(
      &::tensorflow::decision_trees::_Value_default_instance_);
}
inline ::tensorflow::decision_trees::Value* InequalityTest::release_threshold() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.InequalityTest.threshold)
  
  ::tensorflow::decision_trees::Value* temp = threshold_;
  if (GetArenaNoVirtual() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  threshold_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Value* InequalityTest::unsafe_arena_release_threshold() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.InequalityTest.threshold)
  
  ::tensorflow::decision_trees::Value* temp = threshold_;
  threshold_ = nullptr;
  return temp;
}
inline ::tensorflow::decision_trees::Value* InequalityTest::mutable_threshold() {
  
  if (threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::tensorflow::decision_trees::Value>(GetArenaNoVirtual());
    threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.InequalityTest.threshold)
  return threshold_;
}
inline void InequalityTest::set_allocated_threshold(::tensorflow::decision_trees::Value* threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete threshold_;
  }
  if (threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(threshold);
    if (message_arena != submessage_arena) {
      threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threshold, submessage_arena);
    }
    
  } else {
    
  }
  threshold_ = threshold;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.decision_trees.InequalityTest.threshold)
}

inline bool InequalityTest::has_FeatureSum() const {
  return FeatureSum_case() != FEATURESUM_NOT_SET;
}
inline void InequalityTest::clear_has_FeatureSum() {
  _oneof_case_[0] = FEATURESUM_NOT_SET;
}
inline InequalityTest::FeatureSumCase InequalityTest::FeatureSum_case() const {
  return InequalityTest::FeatureSumCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value

// float float_value = 1;
inline bool Value::has_float_value() const {
  return value_case() == kFloatValue;
}
inline void Value::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void Value::clear_float_value() {
  if (has_float_value()) {
    value_.float_value_ = 0;
    clear_has_value();
  }
}
inline float Value::float_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Value.float_value)
  if (has_float_value()) {
    return value_.float_value_;
  }
  return 0;
}
inline void Value::set_float_value(float value) {
  if (!has_float_value()) {
    clear_value();
    set_has_float_value();
  }
  value_.float_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.decision_trees.Value.float_value)
}

// double double_value = 2;
inline bool Value::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void Value::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void Value::clear_double_value() {
  if (has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double Value::double_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Value.double_value)
  if (has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void Value::set_double_value(double value) {
  if (!has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.decision_trees.Value.double_value)
}

// int32 int32_value = 3;
inline bool Value::has_int32_value() const {
  return value_case() == kInt32Value;
}
inline void Value::set_has_int32_value() {
  _oneof_case_[0] = kInt32Value;
}
inline void Value::clear_int32_value() {
  if (has_int32_value()) {
    value_.int32_value_ = 0;
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Value::int32_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Value.int32_value)
  if (has_int32_value()) {
    return value_.int32_value_;
  }
  return 0;
}
inline void Value::set_int32_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!has_int32_value()) {
    clear_value();
    set_has_int32_value();
  }
  value_.int32_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.decision_trees.Value.int32_value)
}

// int64 int64_value = 4;
inline bool Value::has_int64_value() const {
  return value_case() == kInt64Value;
}
inline void Value::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
inline void Value::clear_int64_value() {
  if (has_int64_value()) {
    value_.int64_value_ = PROTOBUF_LONGLONG(0);
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Value::int64_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Value.int64_value)
  if (has_int64_value()) {
    return value_.int64_value_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void Value::set_int64_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!has_int64_value()) {
    clear_value();
    set_has_int64_value();
  }
  value_.int64_value_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.decision_trees.Value.int64_value)
}

// .google.protobuf.Any custom_value = 5;
inline bool Value::has_custom_value() const {
  return value_case() == kCustomValue;
}
inline void Value::set_has_custom_value() {
  _oneof_case_[0] = kCustomValue;
}
inline ::google::protobuf::Any* Value::release_custom_value() {
  // @@protoc_insertion_point(field_release:tensorflow.decision_trees.Value.custom_value)
  if (has_custom_value()) {
    clear_has_value();
      ::google::protobuf::Any* temp = value_.custom_value_;
    if (GetArenaNoVirtual() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.custom_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Any& Value::custom_value() const {
  // @@protoc_insertion_point(field_get:tensorflow.decision_trees.Value.custom_value)
  return has_custom_value()
      ? *value_.custom_value_
      : *reinterpret_cast< ::google::protobuf::Any*>(&::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Value::unsafe_arena_release_custom_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tensorflow.decision_trees.Value.custom_value)
  if (has_custom_value()) {
    clear_has_value();
    ::google::protobuf::Any* temp = value_.custom_value_;
    value_.custom_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_custom_value(::google::protobuf::Any* custom_value) {
  clear_value();
  if (custom_value) {
    set_has_custom_value();
    value_.custom_value_ = custom_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tensorflow.decision_trees.Value.custom_value)
}
inline ::google::protobuf::Any* Value::mutable_custom_value() {
  if (!has_custom_value()) {
    clear_value();
    set_has_custom_value();
    value_.custom_value_ = CreateMaybeMessage< ::google::protobuf::Any >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.decision_trees.Value.custom_value)
  return value_.custom_value_;
}

inline bool Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Value::ValueCase Value::value_case() const {
  return Value::ValueCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace decision_trees
}  // namespace tensorflow

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tensorflow::decision_trees::BinaryNode_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::decision_trees::BinaryNode_Direction>() {
  return ::tensorflow::decision_trees::BinaryNode_Direction_descriptor();
}
template <> struct is_proto_enum< ::tensorflow::decision_trees::InequalityTest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::decision_trees::InequalityTest_Type>() {
  return ::tensorflow::decision_trees::InequalityTest_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "protobuf/port_undef.inc"
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_generic_5ftree_5fmodel_2eproto
